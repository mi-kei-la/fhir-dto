import { Address, Age, Annotation, Attachment, AvailabilityAvailableTime, AvailabilityNotAvailableTime, Availability, BackboneElement, BackboneType, Base, CodeableConcept, CodeableReference, Coding, ContactDetail, ContactPoint, Contributor, Count, DataRequirementCodeFilter, DataRequirementDateFilter, DataRequirementValueFilter, DataRequirementSort, DataRequirement, DataType, Distance, DosageDoseAndRate, Dosage, Duration, Element, ElementDefinitionSlicingDiscriminator, ElementDefinitionSlicing, ElementDefinitionBase, ElementDefinitionType, ElementDefinitionExample, ElementDefinitionConstraint, ElementDefinitionBindingAdditional, ElementDefinitionBinding, ElementDefinitionMapping, ElementDefinition, Expression, ExtendedContactDetail, Extension, HumanName, Identifier, MarketingStatus, Meta, MonetaryComponent, Money, Narrative, ParameterDefinition, Period, PrimitiveType, ProductShelfLife, Quantity, Range, Ratio, RatioRange, Reference, RelatedArtifact, SampledData, Signature, TimingRepeat, Timing, TriggerDefinition, UsageContext, VirtualServiceDetail, AccountCoverage, AccountGuarantor, AccountDiagnosis, AccountProcedure, AccountRelatedAccount, AccountBalance, Account, ActivityDefinitionParticipant, ActivityDefinitionDynamicValue, ActivityDefinition, ActorDefinition, AdministrableProductDefinitionProperty, AdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod, AdministrableProductDefinitionRouteOfAdministrationTargetSpecies, AdministrableProductDefinitionRouteOfAdministration, AdministrableProductDefinition, AdverseEventParticipant, AdverseEventSuspectEntityCausality, AdverseEventSuspectEntity, AdverseEventContributingFactor, AdverseEventPreventiveAction, AdverseEventMitigatingAction, AdverseEventSupportingInfo, AdverseEvent, AllergyIntoleranceParticipant, AllergyIntoleranceReaction, AllergyIntolerance, AppointmentParticipant, AppointmentRecurrenceTemplateWeeklyTemplate, AppointmentRecurrenceTemplateMonthlyTemplate, AppointmentRecurrenceTemplateYearlyTemplate, AppointmentRecurrenceTemplate, Appointment, AppointmentResponse, ArtifactAssessmentContent, ArtifactAssessment, AuditEventOutcome, AuditEventAgent, AuditEventSource, AuditEventEntityDetail, AuditEventEntity, AuditEvent, Basic, Binary, BiologicallyDerivedProductCollection, BiologicallyDerivedProductProperty, BiologicallyDerivedProduct, BiologicallyDerivedProductDispensePerformer, BiologicallyDerivedProductDispense, BodyStructureIncludedStructureBodyLandmarkOrientationDistanceFromLandmark, BodyStructureIncludedStructureBodyLandmarkOrientation, BodyStructureIncludedStructure, BodyStructure, BundleLink, BundleEntrySearch, BundleEntryRequest, BundleEntryResponse, BundleEntry, Bundle, CanonicalResource, CapabilityStatementSoftware, CapabilityStatementImplementation, CapabilityStatementRestSecurity, CapabilityStatementRestResourceInteraction, CapabilityStatementRestResourceSearchParam, CapabilityStatementRestResourceOperation, CapabilityStatementRestResource, CapabilityStatementRestInteraction, CapabilityStatementRest, CapabilityStatementMessagingEndpoint, CapabilityStatementMessagingSupportedMessage, CapabilityStatementMessaging, CapabilityStatementDocument, CapabilityStatement, CarePlanActivity, CarePlan, CareTeamParticipant, CareTeam, ChargeItemPerformer, ChargeItem, ChargeItemDefinitionApplicability, ChargeItemDefinitionPropertyGroup, ChargeItemDefinition, CitationSummary, CitationClassification, CitationStatusDate, CitationCitedArtifactVersion, CitationCitedArtifactStatusDate, CitationCitedArtifactTitle, CitationCitedArtifactAbstract, CitationCitedArtifactPart, CitationCitedArtifactRelatesTo, CitationCitedArtifactPublicationFormPublishedIn, CitationCitedArtifactPublicationForm, CitationCitedArtifactWebLocation, CitationCitedArtifactClassification, CitationCitedArtifactContributorshipEntryContributionInstance, CitationCitedArtifactContributorshipEntry, CitationCitedArtifactContributorshipSummary, CitationCitedArtifactContributorship, CitationCitedArtifact, Citation, ClaimRelated, ClaimPayee, ClaimEvent, ClaimCareTeam, ClaimSupportingInfo, ClaimDiagnosis, ClaimProcedure, ClaimInsurance, ClaimAccident, ClaimItemBodySite, ClaimItemDetailSubDetail, ClaimItemDetail, ClaimItem, Claim, ClaimResponseEvent, ClaimResponseItemReviewOutcome, ClaimResponseItemAdjudication, ClaimResponseItemDetailSubDetail, ClaimResponseItemDetail, ClaimResponseItem, ClaimResponseAddItemBodySite, ClaimResponseAddItemDetailSubDetail, ClaimResponseAddItemDetail, ClaimResponseAddItem, ClaimResponseTotal, ClaimResponsePayment, ClaimResponseProcessNote, ClaimResponseInsurance, ClaimResponseError, ClaimResponse, ClinicalImpressionFinding, ClinicalImpression, ClinicalUseDefinitionContraindicationOtherTherapy, ClinicalUseDefinitionContraindication, ClinicalUseDefinitionIndication, ClinicalUseDefinitionInteractionInteractant, ClinicalUseDefinitionInteraction, ClinicalUseDefinitionUndesirableEffect, ClinicalUseDefinitionWarning, ClinicalUseDefinition, CodeSystemFilter, CodeSystemProperty, CodeSystemConceptDesignation, CodeSystemConceptProperty, CodeSystemConcept, CodeSystem, CommunicationPayload, Communication, CommunicationRequestPayload, CommunicationRequest, CompartmentDefinitionResource, CompartmentDefinition, CompositionAttester, CompositionEvent, CompositionSection, Composition, ConceptMapProperty, ConceptMapAdditionalAttribute, ConceptMapGroupElementTargetProperty, ConceptMapGroupElementTargetDependsOn, ConceptMapGroupElementTarget, ConceptMapGroupElement, ConceptMapGroupUnmapped, ConceptMapGroup, ConceptMap, ConditionParticipant, ConditionStage, Condition, ConditionDefinitionObservation, ConditionDefinitionMedication, ConditionDefinitionPrecondition, ConditionDefinitionQuestionnaire, ConditionDefinitionPlan, ConditionDefinition, ConsentPolicyBasis, ConsentVerification, ConsentProvisionActor, ConsentProvisionData, ConsentProvision, Consent, ContractContentDefinition, ContractTermSecurityLabel, ContractTermOfferParty, ContractTermOfferAnswer, ContractTermOffer, ContractTermAssetContext, ContractTermAssetValuedItem, ContractTermAsset, ContractTermActionSubject, ContractTermAction, ContractTerm, ContractSigner, ContractFriendly, ContractLegal, ContractRule, Contract, CoveragePaymentBy, CoverageClass, CoverageCostToBeneficiaryException, CoverageCostToBeneficiary, Coverage, CoverageEligibilityRequestEvent, CoverageEligibilityRequestSupportingInfo, CoverageEligibilityRequestInsurance, CoverageEligibilityRequestItemDiagnosis, CoverageEligibilityRequestItem, CoverageEligibilityRequest, CoverageEligibilityResponseEvent, CoverageEligibilityResponseInsuranceItemBenefit, CoverageEligibilityResponseInsuranceItem, CoverageEligibilityResponseInsurance, CoverageEligibilityResponseError, CoverageEligibilityResponse, DetectedIssueEvidence, DetectedIssueMitigation, DetectedIssue, DeviceUdiCarrier, DeviceName, DeviceVersion, DeviceConformsTo, DeviceProperty, Device, DeviceAssociationOperation, DeviceAssociation, DeviceDefinitionUdiDeviceIdentifierMarketDistribution, DeviceDefinitionUdiDeviceIdentifier, DeviceDefinitionRegulatoryIdentifier, DeviceDefinitionDeviceName, DeviceDefinitionClassification, DeviceDefinitionConformsTo, DeviceDefinitionHasPart, DeviceDefinitionPackagingDistributor, DeviceDefinitionPackaging, DeviceDefinitionVersion, DeviceDefinitionProperty, DeviceDefinitionLink, DeviceDefinitionMaterial, DeviceDefinitionGuideline, DeviceDefinitionCorrectiveAction, DeviceDefinitionChargeItem, DeviceDefinition, DeviceDispensePerformer, DeviceDispense, DeviceMetricCalibration, DeviceMetric, DeviceRequestParameter, DeviceRequest, DeviceUsageAdherence, DeviceUsage, DiagnosticReportSupportingInfo, DiagnosticReportMedia, DiagnosticReport, DocumentReferenceAttester, DocumentReferenceRelatesTo, DocumentReferenceContentProfile, DocumentReferenceContent, DocumentReference, DomainResource, EncounterParticipant, EncounterReason, EncounterDiagnosis, EncounterAdmission, EncounterLocation, Encounter, EncounterHistoryLocation, EncounterHistory, EndpointPayload, Endpoint, EnrollmentRequest, EnrollmentResponse, EpisodeOfCareStatusHistory, EpisodeOfCareReason, EpisodeOfCareDiagnosis, EpisodeOfCare, EventDefinition, EvidenceVariableDefinition, EvidenceStatisticSampleSize, EvidenceStatisticAttributeEstimate, EvidenceStatisticModelCharacteristicVariable, EvidenceStatisticModelCharacteristic, EvidenceStatistic, EvidenceCertainty, Evidence, EvidenceReportSubjectCharacteristic, EvidenceReportSubject, EvidenceReportRelatesToTarget, EvidenceReportRelatesTo, EvidenceReportSection, EvidenceReport, EvidenceVariableCharacteristicDefinitionByTypeAndValue, EvidenceVariableCharacteristicDefinitionByCombination, EvidenceVariableCharacteristicTimeFromEvent, EvidenceVariableCharacteristic, EvidenceVariableCategory, EvidenceVariable, ExampleScenarioActor, ExampleScenarioInstanceVersion, ExampleScenarioInstanceContainedInstance, ExampleScenarioInstance, ExampleScenarioProcessStepOperation, ExampleScenarioProcessStepAlternative, ExampleScenarioProcessStep, ExampleScenarioProcess, ExampleScenario, ExplanationOfBenefitRelated, ExplanationOfBenefitEvent, ExplanationOfBenefitPayee, ExplanationOfBenefitCareTeam, ExplanationOfBenefitSupportingInfo, ExplanationOfBenefitDiagnosis, ExplanationOfBenefitProcedure, ExplanationOfBenefitInsurance, ExplanationOfBenefitAccident, ExplanationOfBenefitItemBodySite, ExplanationOfBenefitItemReviewOutcome, ExplanationOfBenefitItemAdjudication, ExplanationOfBenefitItemDetailSubDetail, ExplanationOfBenefitItemDetail, ExplanationOfBenefitItem, ExplanationOfBenefitAddItemBodySite, ExplanationOfBenefitAddItemDetailSubDetail, ExplanationOfBenefitAddItemDetail, ExplanationOfBenefitAddItem, ExplanationOfBenefitTotal, ExplanationOfBenefitPayment, ExplanationOfBenefitProcessNote, ExplanationOfBenefitBenefitBalanceFinancial, ExplanationOfBenefitBenefitBalance, ExplanationOfBenefit, FamilyMemberHistoryParticipant, FamilyMemberHistoryCondition, FamilyMemberHistoryProcedure, FamilyMemberHistory, Flag, FormularyItem, GenomicStudyAnalysisInput, GenomicStudyAnalysisOutput, GenomicStudyAnalysisPerformer, GenomicStudyAnalysisDevice, GenomicStudyAnalysis, GenomicStudy, GoalTarget, Goal, GraphDefinitionNode, GraphDefinitionLinkCompartment, GraphDefinitionLink, GraphDefinition, GroupCharacteristic, GroupMember, Group, GuidanceResponse, HealthcareServiceEligibility, HealthcareService, ImagingSelectionPerformer, ImagingSelectionInstanceImageRegion2D, ImagingSelectionInstanceImageRegion3D, ImagingSelectionInstance, ImagingSelection, ImagingStudySeriesPerformer, ImagingStudySeriesInstance, ImagingStudySeries, ImagingStudy, ImmunizationPerformer, ImmunizationProgramEligibility, ImmunizationReaction, ImmunizationProtocolApplied, Immunization, ImmunizationEvaluation, ImmunizationRecommendationRecommendationDateCriterion, ImmunizationRecommendationRecommendation, ImmunizationRecommendation, ImplementationGuideDependsOn, ImplementationGuideGlobal, ImplementationGuideDefinitionGrouping, ImplementationGuideDefinitionResource, ImplementationGuideDefinitionPage, ImplementationGuideDefinitionParameter, ImplementationGuideDefinitionTemplate, ImplementationGuideDefinition, ImplementationGuideManifestResource, ImplementationGuideManifestPage, ImplementationGuideManifest, ImplementationGuide, IngredientManufacturer, IngredientSubstanceStrengthReferenceStrength, IngredientSubstanceStrength, IngredientSubstance, Ingredient, InsurancePlanCoverageBenefitLimit, InsurancePlanCoverageBenefit, InsurancePlanCoverage, InsurancePlanPlanGeneralCost, InsurancePlanPlanSpecificCostBenefitCost, InsurancePlanPlanSpecificCostBenefit, InsurancePlanPlanSpecificCost, InsurancePlanPlan, InsurancePlan, InventoryItemName, InventoryItemResponsibleOrganization, InventoryItemDescription, InventoryItemAssociation, InventoryItemCharacteristic, InventoryItemInstance, InventoryItem, InventoryReportInventoryListingItem, InventoryReportInventoryListing, InventoryReport, InvoiceParticipant, InvoiceLineItem, Invoice, Library, LinkageItem, Linkage, ListEntry, List, LocationPosition, Location, ManufacturedItemDefinitionProperty, ManufacturedItemDefinitionComponentConstituent, ManufacturedItemDefinitionComponent, ManufacturedItemDefinition, MeasureTerm, MeasureGroupPopulation, MeasureGroupStratifierComponent, MeasureGroupStratifier, MeasureGroup, MeasureSupplementalData, Measure, MeasureReportGroupPopulation, MeasureReportGroupStratifierStratumComponent, MeasureReportGroupStratifierStratumPopulation, MeasureReportGroupStratifierStratum, MeasureReportGroupStratifier, MeasureReportGroup, MeasureReport, MedicationIngredient, MedicationBatch, Medication, MedicationAdministrationPerformer, MedicationAdministrationDosage, MedicationAdministration, MedicationDispensePerformer, MedicationDispenseSubstitution, MedicationDispense, MedicationKnowledgeRelatedMedicationKnowledge, MedicationKnowledgeMonograph, MedicationKnowledgeCost, MedicationKnowledgeMonitoringProgram, MedicationKnowledgeIndicationGuidelineDosingGuidelineDosage, MedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic, MedicationKnowledgeIndicationGuidelineDosingGuideline, MedicationKnowledgeIndicationGuideline, MedicationKnowledgeMedicineClassification, MedicationKnowledgePackaging, MedicationKnowledgeStorageGuidelineEnvironmentalSetting, MedicationKnowledgeStorageGuideline, MedicationKnowledgeRegulatorySubstitution, MedicationKnowledgeRegulatoryMaxDispense, MedicationKnowledgeRegulatory, MedicationKnowledgeDefinitionalIngredient, MedicationKnowledgeDefinitionalDrugCharacteristic, MedicationKnowledgeDefinitional, MedicationKnowledge, MedicationRequestDispenseRequestInitialFill, MedicationRequestDispenseRequest, MedicationRequestSubstitution, MedicationRequest, MedicationStatementAdherence, MedicationStatement, MedicinalProductDefinitionContact, MedicinalProductDefinitionNamePart, MedicinalProductDefinitionNameUsage, MedicinalProductDefinitionName, MedicinalProductDefinitionCrossReference, MedicinalProductDefinitionOperation, MedicinalProductDefinitionCharacteristic, MedicinalProductDefinition, MessageDefinitionFocus, MessageDefinitionAllowedResponse, MessageDefinition, MessageHeaderDestination, MessageHeaderSource, MessageHeaderResponse, MessageHeader, MetadataResource, MolecularSequenceRelativeStartingSequence, MolecularSequenceRelativeEdit, MolecularSequenceRelative, MolecularSequence, NamingSystemUniqueId, NamingSystem, NutritionIntakeConsumedItem, NutritionIntakeIngredientLabel, NutritionIntakePerformer, NutritionIntake, NutritionOrderOralDietSchedule, NutritionOrderOralDietNutrient, NutritionOrderOralDietTexture, NutritionOrderOralDiet, NutritionOrderSupplementSchedule, NutritionOrderSupplement, NutritionOrderEnteralFormulaAdditive, NutritionOrderEnteralFormulaAdministrationSchedule, NutritionOrderEnteralFormulaAdministration, NutritionOrderEnteralFormula, NutritionOrder, NutritionProductNutrient, NutritionProductIngredient, NutritionProductCharacteristic, NutritionProductInstance, NutritionProduct, ObservationTriggeredBy, ObservationReferenceRange, ObservationComponent, Observation, ObservationDefinitionQualifiedValue, ObservationDefinitionComponent, ObservationDefinition, OperationDefinitionParameterBinding, OperationDefinitionParameterReferencedFrom, OperationDefinitionParameter, OperationDefinitionOverload, OperationDefinition, OperationOutcomeIssue, OperationOutcome, OrganizationQualification, Organization, OrganizationAffiliation, PackagedProductDefinitionLegalStatusOfSupply, PackagedProductDefinitionPackagingProperty, PackagedProductDefinitionPackagingContainedItem, PackagedProductDefinitionPackaging, PackagedProductDefinition, ParametersParameter, Parameters, PatientContact, PatientCommunication, PatientLink, Patient, PaymentNotice, PaymentReconciliationAllocation, PaymentReconciliationProcessNote, PaymentReconciliation, PermissionJustification, PermissionRuleDataResource, PermissionRuleData, PermissionRuleActivity, PermissionRule, Permission, PersonCommunication, PersonLink, Person, PlanDefinitionGoalTarget, PlanDefinitionGoal, PlanDefinitionActorOption, PlanDefinitionActor, PlanDefinitionActionCondition, PlanDefinitionActionInput, PlanDefinitionActionOutput, PlanDefinitionActionRelatedAction, PlanDefinitionActionParticipant, PlanDefinitionActionDynamicValue, PlanDefinitionAction, PlanDefinition, PractitionerQualification, PractitionerCommunication, Practitioner, PractitionerRole, ProcedurePerformer, ProcedureFocalDevice, Procedure, ProvenanceAgent, ProvenanceEntity, Provenance, QuestionnaireItemEnableWhen, QuestionnaireItemAnswerOption, QuestionnaireItemInitial, QuestionnaireItem, Questionnaire, QuestionnaireResponseItemAnswer, QuestionnaireResponseItem, QuestionnaireResponse, RegulatedAuthorizationCase, RegulatedAuthorization, RelatedPersonCommunication, RelatedPerson, RequestOrchestrationActionCondition, RequestOrchestrationActionInput, RequestOrchestrationActionOutput, RequestOrchestrationActionRelatedAction, RequestOrchestrationActionParticipant, RequestOrchestrationActionDynamicValue, RequestOrchestrationAction, RequestOrchestration, RequirementsStatement, Requirements, ResearchStudyLabel, ResearchStudyAssociatedParty, ResearchStudyProgressStatus, ResearchStudyRecruitment, ResearchStudyComparisonGroup, ResearchStudyObjective, ResearchStudyOutcomeMeasure, ResearchStudy, ResearchSubjectProgress, ResearchSubject, Resource, RiskAssessmentPrediction, RiskAssessment, Schedule, SearchParameterComponent, SearchParameter, ServiceRequestOrderDetailParameter, ServiceRequestOrderDetail, ServiceRequestPatientInstruction, ServiceRequest, Slot, SpecimenFeature, SpecimenCollection, SpecimenProcessing, SpecimenContainer, Specimen, SpecimenDefinitionTypeTestedContainerAdditive, SpecimenDefinitionTypeTestedContainer, SpecimenDefinitionTypeTestedHandling, SpecimenDefinitionTypeTested, SpecimenDefinition, StructureDefinitionMapping, StructureDefinitionContext, StructureDefinitionSnapshot, StructureDefinitionDifferential, StructureDefinition, StructureMapStructure, StructureMapConst, StructureMapGroupInput, StructureMapGroupRuleSource, StructureMapGroupRuleTargetParameter, StructureMapGroupRuleTarget, StructureMapGroupRuleDependent, StructureMapGroupRule, StructureMapGroup, StructureMap, SubscriptionFilterBy, SubscriptionParameter, Subscription, SubscriptionStatusNotificationEvent, SubscriptionStatus, SubscriptionTopicResourceTriggerQueryCriteria, SubscriptionTopicResourceTrigger, SubscriptionTopicEventTrigger, SubscriptionTopicCanFilterBy, SubscriptionTopicNotificationShape, SubscriptionTopic, SubstanceIngredient, Substance, SubstanceDefinitionMoiety, SubstanceDefinitionCharacterization, SubstanceDefinitionProperty, SubstanceDefinitionMolecularWeight, SubstanceDefinitionStructureRepresentation, SubstanceDefinitionStructure, SubstanceDefinitionCode, SubstanceDefinitionNameOfficial, SubstanceDefinitionName, SubstanceDefinitionRelationship, SubstanceDefinitionSourceMaterial, SubstanceDefinition, SubstanceNucleicAcidSubunitLinkage, SubstanceNucleicAcidSubunitSugar, SubstanceNucleicAcidSubunit, SubstanceNucleicAcid, SubstancePolymerMonomerSetStartingMaterial, SubstancePolymerMonomerSet, SubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation, SubstancePolymerRepeatRepeatUnitStructuralRepresentation, SubstancePolymerRepeatRepeatUnit, SubstancePolymerRepeat, SubstancePolymer, SubstanceProteinSubunit, SubstanceProtein, SubstanceReferenceInformationGene, SubstanceReferenceInformationGeneElement, SubstanceReferenceInformationTarget, SubstanceReferenceInformation, SubstanceSourceMaterialFractionDescription, SubstanceSourceMaterialOrganismAuthor, SubstanceSourceMaterialOrganismHybrid, SubstanceSourceMaterialOrganismOrganismGeneral, SubstanceSourceMaterialOrganism, SubstanceSourceMaterialPartDescription, SubstanceSourceMaterial, SupplyDeliverySuppliedItem, SupplyDelivery, SupplyRequestParameter, SupplyRequest, TaskPerformer, TaskRestriction, TaskInput, TaskOutput, Task, TerminologyCapabilitiesSoftware, TerminologyCapabilitiesImplementation, TerminologyCapabilitiesCodeSystemVersionFilter, TerminologyCapabilitiesCodeSystemVersion, TerminologyCapabilitiesCodeSystem, TerminologyCapabilitiesExpansionParameter, TerminologyCapabilitiesExpansion, TerminologyCapabilitiesValidateCode, TerminologyCapabilitiesTranslation, TerminologyCapabilitiesClosure, TerminologyCapabilities, TestPlanDependency, TestPlanTestCaseDependency, TestPlanTestCaseTestRunScript, TestPlanTestCaseTestRun, TestPlanTestCaseTestData, TestPlanTestCaseAssertion, TestPlanTestCase, TestPlan, TestReportParticipant, TestReportSetupActionOperation, TestReportSetupActionAssertRequirement, TestReportSetupActionAssert, TestReportSetupAction, TestReportSetup, TestReportTestAction, TestReportTest, TestReportTeardownAction, TestReportTeardown, TestReport, TestScriptOrigin, TestScriptDestination, TestScriptMetadataLink, TestScriptMetadataCapability, TestScriptMetadata, TestScriptScope, TestScriptFixture, TestScriptVariable, TestScriptSetupActionOperationRequestHeader, TestScriptSetupActionOperation, TestScriptSetupActionAssertRequirement, TestScriptSetupActionAssert, TestScriptSetupAction, TestScriptSetup, TestScriptTestAction, TestScriptTest, TestScriptTeardownAction, TestScriptTeardown, TestScript, TransportRestriction, TransportInput, TransportOutput, Transport, ValueSetComposeIncludeConceptDesignation, ValueSetComposeIncludeConcept, ValueSetComposeIncludeFilter, ValueSetComposeInclude, ValueSetCompose, ValueSetExpansionParameter, ValueSetExpansionProperty, ValueSetExpansionContainsPropertySubProperty, ValueSetExpansionContainsProperty, ValueSetExpansionContains, ValueSetExpansion, ValueSetScope, ValueSet, VerificationResultPrimarySource, VerificationResultAttestation, VerificationResultValidator, VerificationResult, VisionPrescriptionLensSpecificationPrism, VisionPrescriptionLensSpecification, VisionPrescription, FhirResource } from "fhir/r5"
import { IsString, IsOptional, IsArray, ValidateNested, IsNotEmpty, IsIn, IsNumber, IsBoolean } from "class-validator"
import { Type } from "class-transformer"

namespace r5 {

  export class QuantityDto implements Quantity {
    @IsOptional()
    @IsString()
    code?: string

    @IsNotEmpty()
    @IsIn(["<", "<=", ">=", ">", "ad"])
    comparator: "<" | "<=" | ">=" | ">" | "ad"

    @IsOptional()
    @IsString()
    system?: string

    @IsOptional()
    @IsString()
    unit?: string

    @IsOptional()
    @IsNumber()
    value?: number

  }
  export class ElementDto implements Element {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExtensionDto)
    extension?: Extension[]

    @IsOptional()
    @IsString()
    id?: string

  }
  export class AddressDto implements Address {
    @IsOptional()
    @IsString()
    city?: string

    @IsOptional()
    @IsString()
    country?: string

    @IsOptional()
    @IsString()
    district?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    line?: string[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @IsString()
    postalCode?: string

    @IsOptional()
    @IsString()
    state?: string

    @IsOptional()
    @IsString()
    text?: string

    @IsNotEmpty()
    @IsIn(["postal", "physical", "both"])
    type: "postal" | "physical" | "both"

    @IsNotEmpty()
    @IsIn(["home", "work", "temp", "old", "billing"])
    use: "home" | "work" | "temp" | "old" | "billing"

  }
  export class AgeDto extends QuantityDto { }

  export class AnnotationDto implements Annotation {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    authorReference?: Reference

    @IsOptional()
    @IsString()
    authorString?: string

    @IsNotEmpty()
    @IsString()
    text: string

    @IsOptional()
    @IsString()
    time?: string

  }
  export class AttachmentDto implements Attachment {
    @IsOptional()
    @IsString()
    contentType?: string

    @IsOptional()
    @IsString()
    creation?: string

    @IsOptional()
    @IsString()
    data?: string

    @IsOptional()
    @IsNumber()
    duration?: number

    @IsOptional()
    @IsNumber()
    frames?: number

    @IsOptional()
    @IsString()
    hash?: string

    @IsOptional()
    @IsNumber()
    height?: number

    @IsOptional()
    @IsString()
    language?: string

    @IsOptional()
    @IsNumber()
    pages?: number

    @IsOptional()
    @IsString()
    size?: string

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsNumber()
    width?: number

  }
  export class AvailabilityAvailableTimeDto implements AvailabilityAvailableTime {
    @IsNotEmpty()
    @IsBoolean()
    allDay: boolean

    @IsOptional()
    @IsString()
    availableEndTime?: string

    @IsOptional()
    @IsString()
    availableStartTime?: string

    @IsOptional()
    @IsArray()
    @IsIn(["mon", "tue", "wed", "thu", "fri", "sat", "sun"], { each: true })
    daysOfWeek?: ("mon" | "tue" | "wed" | "thu" | "fri" | "sat" | "sun")[]

  }
  export class AvailabilityNotAvailableTimeDto implements AvailabilityNotAvailableTime {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    during?: Period

  }
  export class AvailabilityDto implements Availability {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AvailabilityAvailableTimeDto)
    availableTime?: AvailabilityAvailableTime[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AvailabilityNotAvailableTimeDto)
    notAvailableTime?: AvailabilityNotAvailableTime[]

  }
  export class BackboneElementDto implements BackboneElement {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExtensionDto)
    modifierExtension?: Extension[]

  }
  export class BackboneTypeDto implements BackboneType {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExtensionDto)
    modifierExtension?: Extension[]

  }
  export class BaseDto implements Base {
  }
  export class CodeableConceptDto implements CodeableConcept {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    coding?: Coding[]

    @IsOptional()
    @IsString()
    text?: string

  }
  export class CodeableReferenceDto implements CodeableReference {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    concept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    reference?: Reference

  }
  export class CodingDto implements Coding {
    @IsOptional()
    @IsString()
    code?: string

    @IsOptional()
    @IsString()
    display?: string

    @IsOptional()
    @IsString()
    system?: string

    @IsNotEmpty()
    @IsBoolean()
    userSelected: boolean

    @IsOptional()
    @IsString()
    version?: string

  }
  export class ContactDetailDto implements ContactDetail {
    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactPointDto)
    telecom?: ContactPoint[]

  }
  export class ContactPointDto implements ContactPoint {
    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @IsNumber()
    rank?: number

    @IsNotEmpty()
    @IsIn(["phone", "fax", "email", "pager", "url", "sms", "other"])
    system: "phone" | "fax" | "email" | "pager" | "url" | "sms" | "other"

    @IsNotEmpty()
    @IsIn(["home", "work", "temp", "old", "mobile"])
    use: "home" | "work" | "temp" | "old" | "mobile"

    @IsOptional()
    @IsString()
    value?: string

  }
  export class ContributorDto implements Contributor {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsNotEmpty()
    @IsString()
    name: string

    @IsNotEmpty()
    @IsIn(["author", "editor", "reviewer", "endorser"])
    type: "author" | "editor" | "reviewer" | "endorser"

  }
  export class CountDto extends QuantityDto { }

  export class DataRequirementCodeFilterDto implements DataRequirementCodeFilter {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    code?: Coding[]

    @IsOptional()
    @IsString()
    path?: string

    @IsOptional()
    @IsString()
    searchParam?: string

    @IsOptional()
    @IsString()
    valueSet?: string

  }
  export class DataRequirementDateFilterDto implements DataRequirementDateFilter {
    @IsOptional()
    @IsString()
    path?: string

    @IsOptional()
    @IsString()
    searchParam?: string

    @IsOptional()
    @IsString()
    valueDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    valuePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    valueDuration?: Duration

  }
  export class DataRequirementValueFilterDto implements DataRequirementValueFilter {
    @IsNotEmpty()
    @IsIn(["eq", "gt", "lt", "ge", "le", "sa", "eb"])
    comparator: "eq" | "gt" | "lt" | "ge" | "le" | "sa" | "eb"

    @IsOptional()
    @IsString()
    path?: string

    @IsOptional()
    @IsString()
    searchParam?: string

    @IsOptional()
    @IsString()
    valueDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    valuePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    valueDuration?: Duration

  }
  export class DataRequirementSortDto implements DataRequirementSort {
    @IsNotEmpty()
    @IsIn(["ascending", "descending"])
    direction: "ascending" | "descending"

    @IsNotEmpty()
    @IsString()
    path: string

  }
  export class DataRequirementDto implements DataRequirement {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DataRequirementCodeFilterDto)
    codeFilter?: DataRequirementCodeFilter[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DataRequirementDateFilterDto)
    dateFilter?: DataRequirementDateFilter[]

    @IsOptional()
    @IsNumber()
    limit?: number

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    mustSupport?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    profile?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DataRequirementSortDto)
    sort?: DataRequirementSort[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    subjectCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subjectReference?: Reference

    @IsNotEmpty()
    @IsString()
    type: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DataRequirementValueFilterDto)
    valueFilter?: DataRequirementValueFilter[]

  }
  export class DataTypeDto extends ElementDto { }

  export class DistanceDto extends QuantityDto { }

  export class DosageDoseAndRateDto implements DosageDoseAndRate {
    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    doseRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    doseQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    rateRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    rateRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    rateQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class DosageDto implements Dosage {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    additionalInstruction?: CodeableConcept[]

    @IsNotEmpty()
    @IsBoolean()
    asNeeded: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    asNeededFor?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DosageDoseAndRateDto)
    doseAndRate?: DosageDoseAndRate[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    maxDosePerAdministration?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    maxDosePerLifetime?: Quantity

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RatioDto)
    maxDosePerPeriod?: Ratio[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    method?: CodeableConcept

    @IsOptional()
    @IsString()
    patientInstruction?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    route?: CodeableConcept

    @IsOptional()
    @IsNumber()
    sequence?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    site?: CodeableConcept

    @IsOptional()
    @IsString()
    text?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    timing?: Timing

  }
  export class DurationDto extends QuantityDto { }

  export class ElementDefinitionSlicingDiscriminatorDto implements ElementDefinitionSlicingDiscriminator {
    @IsNotEmpty()
    @IsString()
    path: string

    @IsNotEmpty()
    @IsIn(["value", "exists", "type", "profile", "position", "pattern"])
    type: "value" | "exists" | "type" | "profile" | "position" | "pattern"

  }
  export class ElementDefinitionSlicingDto implements ElementDefinitionSlicing {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ElementDefinitionSlicingDiscriminatorDto)
    discriminator?: ElementDefinitionSlicingDiscriminator[]

    @IsNotEmpty()
    @IsBoolean()
    ordered: boolean

    @IsNotEmpty()
    @IsIn(["closed", "open", "openAtEnd"])
    rules: "closed" | "open" | "openAtEnd"

  }
  export class ElementDefinitionBaseDto implements ElementDefinitionBase {
    @IsNotEmpty()
    @IsString()
    max: string

    @IsNotEmpty()
    @IsNumber()
    min: number

    @IsNotEmpty()
    @IsString()
    path: string

  }
  export class ElementDefinitionTypeDto implements ElementDefinitionType {
    @IsOptional()
    @IsArray()
    @IsIn(["contained", "referenced", "bundled"], { each: true })
    aggregation?: ("contained" | "referenced" | "bundled")[]

    @IsNotEmpty()
    @IsString()
    code: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    profile?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    targetProfile?: string[]

    @IsNotEmpty()
    @IsIn(["either", "independent", "specific"])
    versioning: "either" | "independent" | "specific"

  }
  export class ElementDefinitionExampleDto implements ElementDefinitionExample {
    @IsNotEmpty()
    @IsString()
    label: string

    @IsOptional()
    @IsString()
    valueBase64Binary?: string

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsString()
    valueCanonical?: string

    @IsOptional()
    @IsString()
    valueCode?: string

    @IsOptional()
    @IsString()
    valueDate?: string

    @IsOptional()
    @IsString()
    valueDateTime?: string

    @IsOptional()
    @IsNumber()
    valueDecimal?: number

    @IsOptional()
    @IsString()
    valueId?: string

    @IsOptional()
    @IsString()
    valueInstant?: string

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsOptional()
    @IsString()
    valueInteger64?: string

    @IsOptional()
    @IsString()
    valueMarkdown?: string

    @IsOptional()
    @IsString()
    valueOid?: string

    @IsOptional()
    @IsNumber()
    valuePositiveInt?: number

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @IsString()
    valueTime?: string

    @IsOptional()
    @IsNumber()
    valueUnsignedInt?: number

    @IsOptional()
    @IsString()
    valueUri?: string

    @IsOptional()
    @IsString()
    valueUrl?: string

    @IsOptional()
    @IsString()
    valueUuid?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    valueAddress?: Address

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    valueAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => AnnotationDto)
    valueAnnotation?: Annotation

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    valueCodeableReference?: CodeableReference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    valueCoding?: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactPointDto)
    valueContactPoint?: ContactPoint

    @IsOptional()
    @ValidateNested()
    @Type(() => CountDto)
    valueCount?: Count

    @IsOptional()
    @ValidateNested()
    @Type(() => DistanceDto)
    valueDistance?: Distance

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    valueDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => HumanNameDto)
    valueHumanName?: HumanName

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    valueIdentifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    valueMoney?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    valuePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    valueRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioRangeDto)
    valueRatioRange?: RatioRange

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => SampledDataDto)
    valueSampledData?: SampledData

    @IsOptional()
    @ValidateNested()
    @Type(() => SignatureDto)
    valueSignature?: Signature

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    valueTiming?: Timing

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactDetailDto)
    valueContactDetail?: ContactDetail

    @IsOptional()
    @ValidateNested()
    @Type(() => DataRequirementDto)
    valueDataRequirement?: DataRequirement

    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    valueExpression?: Expression

    @IsOptional()
    @ValidateNested()
    @Type(() => ParameterDefinitionDto)
    valueParameterDefinition?: ParameterDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => RelatedArtifactDto)
    valueRelatedArtifact?: RelatedArtifact

    @IsOptional()
    @ValidateNested()
    @Type(() => TriggerDefinitionDto)
    valueTriggerDefinition?: TriggerDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => UsageContextDto)
    valueUsageContext?: UsageContext

    @IsOptional()
    @ValidateNested()
    @Type(() => AvailabilityDto)
    valueAvailability?: Availability

    @IsOptional()
    @ValidateNested()
    @Type(() => ExtendedContactDetailDto)
    valueExtendedContactDetail?: ExtendedContactDetail

    @IsOptional()
    @ValidateNested()
    @Type(() => DosageDto)
    valueDosage?: Dosage

    @IsOptional()
    @ValidateNested()
    @Type(() => MetaDto)
    valueMeta?: Meta

  }
  export class ElementDefinitionConstraintDto implements ElementDefinitionConstraint {
    @IsOptional()
    @IsString()
    expression?: string

    @IsNotEmpty()
    @IsString()
    human: string

    @IsNotEmpty()
    @IsString()
    key: string

    @IsOptional()
    @IsString()
    requirements?: string

    @IsNotEmpty()
    @IsIn(["error", "warning"])
    severity: "error" | "warning"

    @IsOptional()
    @IsString()
    source?: string

    @IsNotEmpty()
    @IsBoolean()
    suppress: boolean

  }
  export class ElementDefinitionBindingAdditionalDto implements ElementDefinitionBindingAdditional {
    @IsNotEmpty()
    @IsBoolean()
    any: boolean

    @IsOptional()
    @IsString()
    documentation?: string

    @IsNotEmpty()
    @IsIn(["maximum", "minimum", "required", "extensible", "candidate", "current", "preferred", "ui", "starter", "component"])
    purpose: "maximum" | "minimum" | "required" | "extensible" | "candidate" | "current" | "preferred" | "ui" | "starter" | "component"

    @IsOptional()
    @IsString()
    shortDoco?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    usage?: UsageContext[]

    @IsNotEmpty()
    @IsString()
    valueSet: string

  }
  export class ElementDefinitionBindingDto implements ElementDefinitionBinding {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ElementDefinitionBindingAdditionalDto)
    additional?: ElementDefinitionBindingAdditional[]

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsIn(["required", "extensible", "preferred", "example"])
    strength: "required" | "extensible" | "preferred" | "example"

    @IsOptional()
    @IsString()
    valueSet?: string

  }
  export class ElementDefinitionMappingDto implements ElementDefinitionMapping {
    @IsOptional()
    @IsString()
    comment?: string

    @IsNotEmpty()
    @IsString()
    identity: string

    @IsOptional()
    @IsString()
    language?: string

    @IsNotEmpty()
    @IsString()
    map: string

  }
  export class ElementDefinitionDto implements ElementDefinition {
    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    alias?: string[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ElementDefinitionBaseDto)
    base?: ElementDefinitionBase

    @IsOptional()
    @ValidateNested()
    @Type(() => ElementDefinitionBindingDto)
    binding?: ElementDefinitionBinding

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    code?: Coding[]

    @IsOptional()
    @IsString()
    comment?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    condition?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ElementDefinitionConstraintDto)
    constraint?: ElementDefinitionConstraint[]

    @IsOptional()
    @IsString()
    contentReference?: string

    @IsOptional()
    @IsString()
    defaultValueBase64Binary?: string

    @IsNotEmpty()
    @IsBoolean()
    defaultValueBoolean: boolean

    @IsOptional()
    @IsString()
    defaultValueCanonical?: string

    @IsOptional()
    @IsString()
    defaultValueCode?: string

    @IsOptional()
    @IsString()
    defaultValueDate?: string

    @IsOptional()
    @IsString()
    defaultValueDateTime?: string

    @IsOptional()
    @IsNumber()
    defaultValueDecimal?: number

    @IsOptional()
    @IsString()
    defaultValueId?: string

    @IsOptional()
    @IsString()
    defaultValueInstant?: string

    @IsOptional()
    @IsNumber()
    defaultValueInteger?: number

    @IsOptional()
    @IsString()
    defaultValueInteger64?: string

    @IsOptional()
    @IsString()
    defaultValueMarkdown?: string

    @IsOptional()
    @IsString()
    defaultValueOid?: string

    @IsOptional()
    @IsNumber()
    defaultValuePositiveInt?: number

    @IsOptional()
    @IsString()
    defaultValueString?: string

    @IsOptional()
    @IsString()
    defaultValueTime?: string

    @IsOptional()
    @IsNumber()
    defaultValueUnsignedInt?: number

    @IsOptional()
    @IsString()
    defaultValueUri?: string

    @IsOptional()
    @IsString()
    defaultValueUrl?: string

    @IsOptional()
    @IsString()
    defaultValueUuid?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    defaultValueAddress?: Address

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    defaultValueAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => AnnotationDto)
    defaultValueAnnotation?: Annotation

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    defaultValueAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    defaultValueCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    defaultValueCodeableReference?: CodeableReference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    defaultValueCoding?: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactPointDto)
    defaultValueContactPoint?: ContactPoint

    @IsOptional()
    @ValidateNested()
    @Type(() => CountDto)
    defaultValueCount?: Count

    @IsOptional()
    @ValidateNested()
    @Type(() => DistanceDto)
    defaultValueDistance?: Distance

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    defaultValueDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => HumanNameDto)
    defaultValueHumanName?: HumanName

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    defaultValueIdentifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    defaultValueMoney?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    defaultValuePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    defaultValueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    defaultValueRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    defaultValueRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioRangeDto)
    defaultValueRatioRange?: RatioRange

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    defaultValueReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => SampledDataDto)
    defaultValueSampledData?: SampledData

    @IsOptional()
    @ValidateNested()
    @Type(() => SignatureDto)
    defaultValueSignature?: Signature

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    defaultValueTiming?: Timing

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactDetailDto)
    defaultValueContactDetail?: ContactDetail

    @IsOptional()
    @ValidateNested()
    @Type(() => DataRequirementDto)
    defaultValueDataRequirement?: DataRequirement

    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    defaultValueExpression?: Expression

    @IsOptional()
    @ValidateNested()
    @Type(() => ParameterDefinitionDto)
    defaultValueParameterDefinition?: ParameterDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => RelatedArtifactDto)
    defaultValueRelatedArtifact?: RelatedArtifact

    @IsOptional()
    @ValidateNested()
    @Type(() => TriggerDefinitionDto)
    defaultValueTriggerDefinition?: TriggerDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => UsageContextDto)
    defaultValueUsageContext?: UsageContext

    @IsOptional()
    @ValidateNested()
    @Type(() => AvailabilityDto)
    defaultValueAvailability?: Availability

    @IsOptional()
    @ValidateNested()
    @Type(() => ExtendedContactDetailDto)
    defaultValueExtendedContactDetail?: ExtendedContactDetail

    @IsOptional()
    @ValidateNested()
    @Type(() => DosageDto)
    defaultValueDosage?: Dosage

    @IsOptional()
    @ValidateNested()
    @Type(() => MetaDto)
    defaultValueMeta?: Meta

    @IsOptional()
    @IsString()
    definition?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ElementDefinitionExampleDto)
    example?: ElementDefinitionExample[]

    @IsOptional()
    @IsString()
    fixedBase64Binary?: string

    @IsNotEmpty()
    @IsBoolean()
    fixedBoolean: boolean

    @IsOptional()
    @IsString()
    fixedCanonical?: string

    @IsOptional()
    @IsString()
    fixedCode?: string

    @IsOptional()
    @IsString()
    fixedDate?: string

    @IsOptional()
    @IsString()
    fixedDateTime?: string

    @IsOptional()
    @IsNumber()
    fixedDecimal?: number

    @IsOptional()
    @IsString()
    fixedId?: string

    @IsOptional()
    @IsString()
    fixedInstant?: string

    @IsOptional()
    @IsNumber()
    fixedInteger?: number

    @IsOptional()
    @IsString()
    fixedInteger64?: string

    @IsOptional()
    @IsString()
    fixedMarkdown?: string

    @IsOptional()
    @IsString()
    fixedOid?: string

    @IsOptional()
    @IsNumber()
    fixedPositiveInt?: number

    @IsOptional()
    @IsString()
    fixedString?: string

    @IsOptional()
    @IsString()
    fixedTime?: string

    @IsOptional()
    @IsNumber()
    fixedUnsignedInt?: number

    @IsOptional()
    @IsString()
    fixedUri?: string

    @IsOptional()
    @IsString()
    fixedUrl?: string

    @IsOptional()
    @IsString()
    fixedUuid?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    fixedAddress?: Address

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    fixedAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => AnnotationDto)
    fixedAnnotation?: Annotation

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    fixedAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    fixedCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    fixedCodeableReference?: CodeableReference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    fixedCoding?: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactPointDto)
    fixedContactPoint?: ContactPoint

    @IsOptional()
    @ValidateNested()
    @Type(() => CountDto)
    fixedCount?: Count

    @IsOptional()
    @ValidateNested()
    @Type(() => DistanceDto)
    fixedDistance?: Distance

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    fixedDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => HumanNameDto)
    fixedHumanName?: HumanName

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    fixedIdentifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    fixedMoney?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    fixedPeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    fixedQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    fixedRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    fixedRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioRangeDto)
    fixedRatioRange?: RatioRange

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    fixedReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => SampledDataDto)
    fixedSampledData?: SampledData

    @IsOptional()
    @ValidateNested()
    @Type(() => SignatureDto)
    fixedSignature?: Signature

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    fixedTiming?: Timing

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactDetailDto)
    fixedContactDetail?: ContactDetail

    @IsOptional()
    @ValidateNested()
    @Type(() => DataRequirementDto)
    fixedDataRequirement?: DataRequirement

    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    fixedExpression?: Expression

    @IsOptional()
    @ValidateNested()
    @Type(() => ParameterDefinitionDto)
    fixedParameterDefinition?: ParameterDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => RelatedArtifactDto)
    fixedRelatedArtifact?: RelatedArtifact

    @IsOptional()
    @ValidateNested()
    @Type(() => TriggerDefinitionDto)
    fixedTriggerDefinition?: TriggerDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => UsageContextDto)
    fixedUsageContext?: UsageContext

    @IsOptional()
    @ValidateNested()
    @Type(() => AvailabilityDto)
    fixedAvailability?: Availability

    @IsOptional()
    @ValidateNested()
    @Type(() => ExtendedContactDetailDto)
    fixedExtendedContactDetail?: ExtendedContactDetail

    @IsOptional()
    @ValidateNested()
    @Type(() => DosageDto)
    fixedDosage?: Dosage

    @IsOptional()
    @ValidateNested()
    @Type(() => MetaDto)
    fixedMeta?: Meta

    @IsNotEmpty()
    @IsBoolean()
    isModifier: boolean

    @IsOptional()
    @IsString()
    isModifierReason?: string

    @IsNotEmpty()
    @IsBoolean()
    isSummary: boolean

    @IsOptional()
    @IsString()
    label?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ElementDefinitionMappingDto)
    mapping?: ElementDefinitionMapping[]

    @IsOptional()
    @IsString()
    max?: string

    @IsOptional()
    @IsNumber()
    maxLength?: number

    @IsOptional()
    @IsString()
    maxValueDate?: string

    @IsOptional()
    @IsString()
    maxValueDateTime?: string

    @IsOptional()
    @IsString()
    maxValueInstant?: string

    @IsOptional()
    @IsString()
    maxValueTime?: string

    @IsOptional()
    @IsNumber()
    maxValueDecimal?: number

    @IsOptional()
    @IsNumber()
    maxValueInteger?: number

    @IsOptional()
    @IsString()
    maxValueInteger64?: string

    @IsOptional()
    @IsNumber()
    maxValuePositiveInt?: number

    @IsOptional()
    @IsNumber()
    maxValueUnsignedInt?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    maxValueQuantity?: Quantity

    @IsOptional()
    @IsString()
    meaningWhenMissing?: string

    @IsOptional()
    @IsNumber()
    min?: number

    @IsOptional()
    @IsString()
    minValueDate?: string

    @IsOptional()
    @IsString()
    minValueDateTime?: string

    @IsOptional()
    @IsString()
    minValueInstant?: string

    @IsOptional()
    @IsString()
    minValueTime?: string

    @IsOptional()
    @IsNumber()
    minValueDecimal?: number

    @IsOptional()
    @IsNumber()
    minValueInteger?: number

    @IsOptional()
    @IsString()
    minValueInteger64?: string

    @IsOptional()
    @IsNumber()
    minValuePositiveInt?: number

    @IsOptional()
    @IsNumber()
    minValueUnsignedInt?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    minValueQuantity?: Quantity

    @IsNotEmpty()
    @IsBoolean()
    mustHaveValue: boolean

    @IsNotEmpty()
    @IsBoolean()
    mustSupport: boolean

    @IsOptional()
    @IsString()
    orderMeaning?: string

    @IsNotEmpty()
    @IsString()
    path: string

    @IsOptional()
    @IsString()
    patternBase64Binary?: string

    @IsNotEmpty()
    @IsBoolean()
    patternBoolean: boolean

    @IsOptional()
    @IsString()
    patternCanonical?: string

    @IsOptional()
    @IsString()
    patternCode?: string

    @IsOptional()
    @IsString()
    patternDate?: string

    @IsOptional()
    @IsString()
    patternDateTime?: string

    @IsOptional()
    @IsNumber()
    patternDecimal?: number

    @IsOptional()
    @IsString()
    patternId?: string

    @IsOptional()
    @IsString()
    patternInstant?: string

    @IsOptional()
    @IsNumber()
    patternInteger?: number

    @IsOptional()
    @IsString()
    patternInteger64?: string

    @IsOptional()
    @IsString()
    patternMarkdown?: string

    @IsOptional()
    @IsString()
    patternOid?: string

    @IsOptional()
    @IsNumber()
    patternPositiveInt?: number

    @IsOptional()
    @IsString()
    patternString?: string

    @IsOptional()
    @IsString()
    patternTime?: string

    @IsOptional()
    @IsNumber()
    patternUnsignedInt?: number

    @IsOptional()
    @IsString()
    patternUri?: string

    @IsOptional()
    @IsString()
    patternUrl?: string

    @IsOptional()
    @IsString()
    patternUuid?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    patternAddress?: Address

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    patternAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => AnnotationDto)
    patternAnnotation?: Annotation

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    patternAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    patternCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    patternCodeableReference?: CodeableReference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    patternCoding?: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactPointDto)
    patternContactPoint?: ContactPoint

    @IsOptional()
    @ValidateNested()
    @Type(() => CountDto)
    patternCount?: Count

    @IsOptional()
    @ValidateNested()
    @Type(() => DistanceDto)
    patternDistance?: Distance

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    patternDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => HumanNameDto)
    patternHumanName?: HumanName

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    patternIdentifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    patternMoney?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    patternPeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    patternQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    patternRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    patternRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioRangeDto)
    patternRatioRange?: RatioRange

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patternReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => SampledDataDto)
    patternSampledData?: SampledData

    @IsOptional()
    @ValidateNested()
    @Type(() => SignatureDto)
    patternSignature?: Signature

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    patternTiming?: Timing

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactDetailDto)
    patternContactDetail?: ContactDetail

    @IsOptional()
    @ValidateNested()
    @Type(() => DataRequirementDto)
    patternDataRequirement?: DataRequirement

    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    patternExpression?: Expression

    @IsOptional()
    @ValidateNested()
    @Type(() => ParameterDefinitionDto)
    patternParameterDefinition?: ParameterDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => RelatedArtifactDto)
    patternRelatedArtifact?: RelatedArtifact

    @IsOptional()
    @ValidateNested()
    @Type(() => TriggerDefinitionDto)
    patternTriggerDefinition?: TriggerDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => UsageContextDto)
    patternUsageContext?: UsageContext

    @IsOptional()
    @ValidateNested()
    @Type(() => AvailabilityDto)
    patternAvailability?: Availability

    @IsOptional()
    @ValidateNested()
    @Type(() => ExtendedContactDetailDto)
    patternExtendedContactDetail?: ExtendedContactDetail

    @IsOptional()
    @ValidateNested()
    @Type(() => DosageDto)
    patternDosage?: Dosage

    @IsOptional()
    @ValidateNested()
    @Type(() => MetaDto)
    patternMeta?: Meta

    @IsOptional()
    @IsArray()
    @IsIn(["xmlAttr", "xmlText", "typeAttr", "cdaText", "xhtml"], { each: true })
    representation?: ("xmlAttr" | "xmlText" | "typeAttr" | "cdaText" | "xhtml")[]

    @IsOptional()
    @IsString()
    requirements?: string

    @IsOptional()
    @IsString()
    short?: string

    @IsNotEmpty()
    @IsBoolean()
    sliceIsConstraining: boolean

    @IsOptional()
    @IsString()
    sliceName?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ElementDefinitionSlicingDto)
    slicing?: ElementDefinitionSlicing

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ElementDefinitionTypeDto)
    type?: ElementDefinitionType[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    valueAlternatives?: string[]

  }
  export class ExpressionDto implements Expression {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    expression?: string

    @IsOptional()
    @IsString()
    language?: string

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsString()
    reference?: string

  }
  export class ExtendedContactDetailDto implements ExtendedContactDetail {
    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    address?: Address

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => HumanNameDto)
    name?: HumanName[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    organization?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    purpose?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactPointDto)
    telecom?: ContactPoint[]

  }
  export class ExtensionDto implements Extension {
    @IsNotEmpty()
    @IsString()
    url: string

    @IsOptional()
    @IsString()
    valueBase64Binary?: string

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsString()
    valueCanonical?: string

    @IsOptional()
    @IsString()
    valueCode?: string

    @IsOptional()
    @IsString()
    valueDate?: string

    @IsOptional()
    @IsString()
    valueDateTime?: string

    @IsOptional()
    @IsNumber()
    valueDecimal?: number

    @IsOptional()
    @IsString()
    valueId?: string

    @IsOptional()
    @IsString()
    valueInstant?: string

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsOptional()
    @IsString()
    valueInteger64?: string

    @IsOptional()
    @IsString()
    valueMarkdown?: string

    @IsOptional()
    @IsString()
    valueOid?: string

    @IsOptional()
    @IsNumber()
    valuePositiveInt?: number

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @IsString()
    valueTime?: string

    @IsOptional()
    @IsNumber()
    valueUnsignedInt?: number

    @IsOptional()
    @IsString()
    valueUri?: string

    @IsOptional()
    @IsString()
    valueUrl?: string

    @IsOptional()
    @IsString()
    valueUuid?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    valueAddress?: Address

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    valueAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => AnnotationDto)
    valueAnnotation?: Annotation

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    valueCodeableReference?: CodeableReference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    valueCoding?: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactPointDto)
    valueContactPoint?: ContactPoint

    @IsOptional()
    @ValidateNested()
    @Type(() => CountDto)
    valueCount?: Count

    @IsOptional()
    @ValidateNested()
    @Type(() => DistanceDto)
    valueDistance?: Distance

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    valueDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => HumanNameDto)
    valueHumanName?: HumanName

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    valueIdentifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    valueMoney?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    valuePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    valueRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioRangeDto)
    valueRatioRange?: RatioRange

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => SampledDataDto)
    valueSampledData?: SampledData

    @IsOptional()
    @ValidateNested()
    @Type(() => SignatureDto)
    valueSignature?: Signature

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    valueTiming?: Timing

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactDetailDto)
    valueContactDetail?: ContactDetail

    @IsOptional()
    @ValidateNested()
    @Type(() => DataRequirementDto)
    valueDataRequirement?: DataRequirement

    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    valueExpression?: Expression

    @IsOptional()
    @ValidateNested()
    @Type(() => ParameterDefinitionDto)
    valueParameterDefinition?: ParameterDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => RelatedArtifactDto)
    valueRelatedArtifact?: RelatedArtifact

    @IsOptional()
    @ValidateNested()
    @Type(() => TriggerDefinitionDto)
    valueTriggerDefinition?: TriggerDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => UsageContextDto)
    valueUsageContext?: UsageContext

    @IsOptional()
    @ValidateNested()
    @Type(() => AvailabilityDto)
    valueAvailability?: Availability

    @IsOptional()
    @ValidateNested()
    @Type(() => ExtendedContactDetailDto)
    valueExtendedContactDetail?: ExtendedContactDetail

    @IsOptional()
    @ValidateNested()
    @Type(() => DosageDto)
    valueDosage?: Dosage

    @IsOptional()
    @ValidateNested()
    @Type(() => MetaDto)
    valueMeta?: Meta

  }
  export class HumanNameDto implements HumanName {
    @IsOptional()
    @IsString()
    family?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    given?: string[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    prefix?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    suffix?: string[]

    @IsOptional()
    @IsString()
    text?: string

    @IsNotEmpty()
    @IsIn(["temp", "old", "usual", "official", "nickname", "anonymous", "maiden"])
    use: "temp" | "old" | "usual" | "official" | "nickname" | "anonymous" | "maiden"

  }
  export class IdentifierDto implements Identifier {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    assigner?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @IsString()
    system?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsNotEmpty()
    @IsIn(["temp", "old", "usual", "official", "secondary"])
    use: "temp" | "old" | "usual" | "official" | "secondary"

    @IsOptional()
    @IsString()
    value?: string

  }
  export class MarketingStatusDto implements MarketingStatus {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    country?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    dateRange?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept

    @IsOptional()
    @IsString()
    restoreDate?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    status: CodeableConcept

  }
  export class MetaDto implements Meta {
    @IsOptional()
    @IsString()
    lastUpdated?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    profile?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    security?: Coding[]

    @IsOptional()
    @IsString()
    source?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    tag?: Coding[]

    @IsOptional()
    @IsString()
    versionId?: string

  }
  export class MonetaryComponentDto implements MonetaryComponent {
    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    amount?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsNumber()
    factor?: number

    @IsNotEmpty()
    @IsIn(["base", "surcharge", "deduction", "discount", "tax", "informational"])
    type: "base" | "surcharge" | "deduction" | "discount" | "tax" | "informational"

  }
  export class MoneyDto implements Money {
    @IsOptional()
    @IsString()
    currency?: string

    @IsOptional()
    @IsNumber()
    value?: number

  }
  export class NarrativeDto implements Narrative {
    @IsNotEmpty()
    @IsString()
    div: string

    @IsNotEmpty()
    @IsIn(["generated", "extensions", "additional", "empty"])
    status: "generated" | "extensions" | "additional" | "empty"

  }
  export class ParameterDefinitionDto implements ParameterDefinition {
    @IsOptional()
    @IsString()
    documentation?: string

    @IsOptional()
    @IsString()
    max?: string

    @IsOptional()
    @IsNumber()
    min?: number

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsString()
    profile?: string

    @IsNotEmpty()
    @IsString()
    type: string

    @IsNotEmpty()
    @IsIn(["in", "out"])
    use: "in" | "out"

  }
  export class PeriodDto implements Period {
    @IsOptional()
    @IsString()
    end?: string

    @IsOptional()
    @IsString()
    start?: string

  }
  export class PrimitiveTypeDto extends DataTypeDto { }

  export class ProductShelfLifeDto implements ProductShelfLife {
    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    periodDuration?: Duration

    @IsOptional()
    @IsString()
    periodString?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    specialPrecautionsForStorage?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class RangeDto implements Range {
    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    high?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    low?: Quantity

  }
  export class RatioDto implements Ratio {
    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    denominator?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    numerator?: Quantity

  }
  export class RatioRangeDto implements RatioRange {
    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    denominator?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    highNumerator?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    lowNumerator?: Quantity

  }
  export class ReferenceDto implements Reference {
    @IsOptional()
    @IsString()
    display?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsOptional()
    @IsString()
    reference?: string

    @IsOptional()
    @IsString()
    type?: string

  }
  export class RelatedArtifactDto implements RelatedArtifact {
    @IsOptional()
    @IsString()
    citation?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    classifier?: CodeableConcept[]

    @IsOptional()
    @IsString()
    display?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    document?: Attachment

    @IsOptional()
    @IsString()
    label?: string

    @IsOptional()
    @IsString()
    publicationDate?: string

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    publicationStatus: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @IsString()
    resource?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    resourceReference?: Reference

    @IsNotEmpty()
    @IsIn(["documentation", "justification", "citation", "predecessor", "successor", "derived-from", "depends-on", "composed-of", "part-of", "amends", "amended-with", "appends", "appended-with", "cites", "cited-by", "comments-on", "comment-in", "contains", "contained-in", "corrects", "correction-in", "replaces", "replaced-with", "retracts", "retracted-by", "signs", "similar-to", "supports", "supported-with", "transforms", "transformed-into", "transformed-with", "documents", "specification-of", "created-with", "cite-as"])
    type: "documentation" | "justification" | "citation" | "predecessor" | "successor" | "derived-from" | "depends-on" | "composed-of" | "part-of" | "amends" | "amended-with" | "appends" | "appended-with" | "cites" | "cited-by" | "comments-on" | "comment-in" | "contains" | "contained-in" | "corrects" | "correction-in" | "replaces" | "replaced-with" | "retracts" | "retracted-by" | "signs" | "similar-to" | "supports" | "supported-with" | "transforms" | "transformed-into" | "transformed-with" | "documents" | "specification-of" | "created-with" | "cite-as"

  }
  export class SampledDataDto implements SampledData {
    @IsOptional()
    @IsString()
    codeMap?: string

    @IsOptional()
    @IsString()
    data?: string

    @IsNotEmpty()
    @IsNumber()
    dimensions: number

    @IsOptional()
    @IsNumber()
    factor?: number

    @IsOptional()
    @IsNumber()
    interval?: number

    @IsNotEmpty()
    @IsString()
    intervalUnit: string

    @IsOptional()
    @IsNumber()
    lowerLimit?: number

    @IsOptional()
    @IsString()
    offsets?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => QuantityDto)
    origin: Quantity

    @IsOptional()
    @IsNumber()
    upperLimit?: number

  }
  export class SignatureDto implements Signature {
    @IsOptional()
    @IsString()
    data?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    onBehalfOf?: Reference

    @IsOptional()
    @IsString()
    sigFormat?: string

    @IsOptional()
    @IsString()
    targetFormat?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    type?: Coding[]

    @IsOptional()
    @IsString()
    when?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    who?: Reference

  }
  export class TimingRepeatDto implements TimingRepeat {
    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    boundsDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    boundsRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    boundsPeriod?: Period

    @IsOptional()
    @IsNumber()
    count?: number

    @IsOptional()
    @IsNumber()
    countMax?: number

    @IsOptional()
    @IsArray()
    @IsIn(["mon", "tue", "wed", "thu", "fri", "sat", "sun"], { each: true })
    dayOfWeek?: ("mon" | "tue" | "wed" | "thu" | "fri" | "sat" | "sun")[]

    @IsOptional()
    @IsNumber()
    duration?: number

    @IsOptional()
    @IsNumber()
    durationMax?: number

    @IsNotEmpty()
    @IsIn(["s", "min", "h", "d", "wk", "mo", "a"])
    durationUnit: "s" | "min" | "h" | "d" | "wk" | "mo" | "a"

    @IsOptional()
    @IsNumber()
    frequency?: number

    @IsOptional()
    @IsNumber()
    frequencyMax?: number

    @IsOptional()
    @IsNumber()
    offset?: number

    @IsOptional()
    @IsNumber()
    period?: number

    @IsOptional()
    @IsNumber()
    periodMax?: number

    @IsNotEmpty()
    @IsIn(["s", "min", "h", "d", "wk", "mo", "a"])
    periodUnit: "s" | "min" | "h" | "d" | "wk" | "mo" | "a"

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    timeOfDay?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    when?: string[]

  }
  export class TimingDto implements Timing {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    event?: string[]

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingRepeatDto)
    repeat?: TimingRepeat

  }
  export class TriggerDefinitionDto implements TriggerDefinition {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    condition?: Expression

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DataRequirementDto)
    data?: DataRequirement[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsString()
    subscriptionTopic?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    timingTiming?: Timing

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    timingReference?: Reference

    @IsOptional()
    @IsString()
    timingDate?: string

    @IsOptional()
    @IsString()
    timingDateTime?: string

    @IsNotEmpty()
    @IsIn(["named-event", "periodic", "data-changed", "data-added", "data-modified", "data-removed", "data-accessed", "data-access-ended"])
    type: "named-event" | "periodic" | "data-changed" | "data-added" | "data-modified" | "data-removed" | "data-accessed" | "data-access-ended"

  }
  export class UsageContextDto implements UsageContext {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodingDto)
    code: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

  }
  export class VirtualServiceDetailDto implements VirtualServiceDetail {
    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    additionalInfo?: string[]

    @IsOptional()
    @IsString()
    addressUrl?: string

    @IsOptional()
    @IsString()
    addressString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactPointDto)
    addressContactPoint?: ContactPoint

    @IsOptional()
    @ValidateNested()
    @Type(() => ExtendedContactDetailDto)
    addressExtendedContactDetail?: ExtendedContactDetail

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    channelType?: Coding

    @IsOptional()
    @IsNumber()
    maxParticipants?: number

    @IsOptional()
    @IsString()
    sessionKey?: string

  }
  export class AccountCoverageDto implements AccountCoverage {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    coverage: Reference

    @IsOptional()
    @IsNumber()
    priority?: number

  }
  export class AccountGuarantorDto implements AccountGuarantor {
    @IsNotEmpty()
    @IsBoolean()
    onHold: boolean

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    party: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

  }
  export class AccountDiagnosisDto implements AccountDiagnosis {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    condition: CodeableReference

    @IsOptional()
    @IsString()
    dateOfDiagnosis?: string

    @IsNotEmpty()
    @IsBoolean()
    onAdmission: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    packageCode?: CodeableConcept[]

    @IsOptional()
    @IsNumber()
    sequence?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

  }
  export class AccountProcedureDto implements AccountProcedure {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    code: CodeableReference

    @IsOptional()
    @IsString()
    dateOfService?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    device?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    packageCode?: CodeableConcept[]

    @IsOptional()
    @IsNumber()
    sequence?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

  }
  export class AccountRelatedAccountDto implements AccountRelatedAccount {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    account: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    relationship?: CodeableConcept

  }
  export class AccountBalanceDto implements AccountBalance {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    aggregate?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => MoneyDto)
    amount: Money

    @IsNotEmpty()
    @IsBoolean()
    estimate: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    term?: CodeableConcept

  }
  export class AccountDto implements Account {
    @IsNotEmpty()
    @IsIn(["Account"])
    resourceType: "Account"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AccountBalanceDto)
    balance?: AccountBalance[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    billingStatus?: CodeableConcept

    @IsOptional()
    @IsString()
    calculatedAt?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AccountCoverageDto)
    coverage?: AccountCoverage[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    currency?: CodeableConcept

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AccountDiagnosisDto)
    diagnosis?: AccountDiagnosis[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AccountGuarantorDto)
    guarantor?: AccountGuarantor[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    owner?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AccountProcedureDto)
    procedure?: AccountProcedure[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AccountRelatedAccountDto)
    relatedAccount?: AccountRelatedAccount[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    servicePeriod?: Period

    @IsNotEmpty()
    @IsIn(["active", "unknown", "inactive", "entered-in-error", "on-hold"])
    status: "active" | "unknown" | "inactive" | "entered-in-error" | "on-hold"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    subject?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class ActivityDefinitionParticipantDto implements ActivityDefinitionParticipant {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    function?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    role?: CodeableConcept

    @IsNotEmpty()
    @IsIn(["careteam", "device", "group", "healthcareservice", "location", "organization", "patient", "practitioner", "practitionerrole", "relatedperson"])
    type: "careteam" | "device" | "group" | "healthcareservice" | "location" | "organization" | "patient" | "practitioner" | "practitionerrole" | "relatedperson"

    @IsOptional()
    @IsString()
    typeCanonical?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    typeReference?: Reference

  }
  export class ActivityDefinitionDynamicValueDto implements ActivityDefinitionDynamicValue {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ExpressionDto)
    expression: Expression

    @IsNotEmpty()
    @IsString()
    path: string

  }
  export class ActivityDefinitionDto implements ActivityDefinition {
    @IsNotEmpty()
    @IsIn(["ActivityDefinition"])
    resourceType: "ActivityDefinition"

    @IsOptional()
    @IsString()
    approvalDate?: string

    @IsNotEmpty()
    @IsBoolean()
    asNeededBoolean: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    asNeededCodeableConcept?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    author?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    bodySite?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    copyrightLabel?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsBoolean()
    doNotPerform: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DosageDto)
    dosage?: Dosage[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ActivityDefinitionDynamicValueDto)
    dynamicValue?: ActivityDefinitionDynamicValue[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    editor?: ContactDetail[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    endorser?: ContactDetail[]

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsNotEmpty()
    @IsIn(["proposal", "plan", "directive", "order", "original-order", "reflex-order", "filler-order", "instance-order", "option"])
    intent: "proposal" | "plan" | "directive" | "order" | "original-order" | "reflex-order" | "filler-order" | "instance-order" | "option"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    kind?: string

    @IsOptional()
    @IsString()
    lastReviewDate?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    library?: string[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    location?: CodeableReference

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    observationRequirement?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    observationResultRequirement?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ActivityDefinitionParticipantDto)
    participant?: ActivityDefinitionParticipant[]

    @IsNotEmpty()
    @IsIn(["routine", "urgent", "asap", "stat"])
    priority: "routine" | "urgent" | "asap" | "stat"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    productReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productCodeableConcept?: CodeableConcept

    @IsOptional()
    @IsString()
    profile?: string

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    relatedArtifact?: RelatedArtifact[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    reviewer?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    specimenRequirement?: string[]

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    subjectCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subjectReference?: Reference

    @IsOptional()
    @IsString()
    subjectCanonical?: string

    @IsOptional()
    @IsString()
    subtitle?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    timingTiming?: Timing

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    timingAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    timingRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    timingDuration?: Duration

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    topic?: CodeableConcept[]

    @IsOptional()
    @IsString()
    transform?: string

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsString()
    usage?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @IsString()
    versionAlgorithmString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    versionAlgorithmCoding?: Coding

  }
  export class ActorDefinitionDto implements ActorDefinition {
    @IsNotEmpty()
    @IsIn(["ActorDefinition"])
    resourceType: "ActorDefinition"

    @IsOptional()
    @IsString()
    capabilities?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    copyrightLabel?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    derivedFrom?: string[]

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    documentation?: string

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    reference?: string[]

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @IsString()
    title?: string

    @IsNotEmpty()
    @IsIn(["person", "system"])
    type: "person" | "system"

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @IsString()
    versionAlgorithmString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    versionAlgorithmCoding?: Coding

  }
  export class AdministrableProductDefinitionPropertyDto implements AdministrableProductDefinitionProperty {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    status?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @IsString()
    valueDate?: string

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsString()
    valueMarkdown?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

  }
  export class AdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodDto implements AdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod {
    @IsOptional()
    @IsString()
    supportingInformation?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    tissue: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => QuantityDto)
    value: Quantity

  }
  export class AdministrableProductDefinitionRouteOfAdministrationTargetSpeciesDto implements AdministrableProductDefinitionRouteOfAdministrationTargetSpecies {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodDto)
    withdrawalPeriod?: AdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod[]

  }
  export class AdministrableProductDefinitionRouteOfAdministrationDto implements AdministrableProductDefinitionRouteOfAdministration {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    firstDose?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    maxDosePerDay?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    maxDosePerTreatmentPeriod?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    maxSingleDose?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    maxTreatmentPeriod?: Duration

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AdministrableProductDefinitionRouteOfAdministrationTargetSpeciesDto)
    targetSpecies?: AdministrableProductDefinitionRouteOfAdministrationTargetSpecies[]

  }
  export class AdministrableProductDefinitionDto implements AdministrableProductDefinition {
    @IsNotEmpty()
    @IsIn(["AdministrableProductDefinition"])
    resourceType: "AdministrableProductDefinition"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    administrableDoseForm?: CodeableConcept

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    device?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    formOf?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    ingredient?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    producedFrom?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AdministrableProductDefinitionPropertyDto)
    property?: AdministrableProductDefinitionProperty[]

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AdministrableProductDefinitionRouteOfAdministrationDto)
    routeOfAdministration: AdministrableProductDefinitionRouteOfAdministration[]

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    unitOfPresentation?: CodeableConcept

  }
  export class AdverseEventParticipantDto implements AdverseEventParticipant {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    actor: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    function?: CodeableConcept

  }
  export class AdverseEventSuspectEntityCausalityDto implements AdverseEventSuspectEntityCausality {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    assessmentMethod?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    author?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    entityRelatedness?: CodeableConcept

  }
  export class AdverseEventSuspectEntityDto implements AdverseEventSuspectEntity {
    @IsOptional()
    @ValidateNested()
    @Type(() => AdverseEventSuspectEntityCausalityDto)
    causality?: AdverseEventSuspectEntityCausality

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    instanceCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    instanceReference?: Reference

  }
  export class AdverseEventContributingFactorDto implements AdverseEventContributingFactor {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    itemReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    itemCodeableConcept?: CodeableConcept

  }
  export class AdverseEventPreventiveActionDto implements AdverseEventPreventiveAction {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    itemReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    itemCodeableConcept?: CodeableConcept

  }
  export class AdverseEventMitigatingActionDto implements AdverseEventMitigatingAction {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    itemReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    itemCodeableConcept?: CodeableConcept

  }
  export class AdverseEventSupportingInfoDto implements AdverseEventSupportingInfo {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    itemReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    itemCodeableConcept?: CodeableConcept

  }
  export class AdverseEventDto implements AdverseEvent {
    @IsNotEmpty()
    @IsIn(["AdverseEvent"])
    resourceType: "AdverseEvent"

    @IsNotEmpty()
    @IsIn(["actual", "potential"])
    actuality: "actual" | "potential"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AdverseEventContributingFactorDto)
    contributingFactor?: AdverseEventContributingFactor[]

    @IsOptional()
    @IsString()
    detected?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsNotEmpty()
    @IsBoolean()
    expectedInResearchStudy: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    location?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AdverseEventMitigatingActionDto)
    mitigatingAction?: AdverseEventMitigatingAction[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    occurrenceDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    occurrencePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    occurrenceTiming?: Timing

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    outcome?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AdverseEventParticipantDto)
    participant?: AdverseEventParticipant[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AdverseEventPreventiveActionDto)
    preventiveAction?: AdverseEventPreventiveAction[]

    @IsOptional()
    @IsString()
    recordedDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    recorder?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    resultingEffect?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    seriousness?: CodeableConcept

    @IsNotEmpty()
    @IsIn(["unknown", "entered-in-error", "in-progress", "completed"])
    status: "unknown" | "entered-in-error" | "in-progress" | "completed"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    study?: Reference[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AdverseEventSupportingInfoDto)
    supportingInfo?: AdverseEventSupportingInfo[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AdverseEventSuspectEntityDto)
    suspectEntity?: AdverseEventSuspectEntity[]

  }
  export class AllergyIntoleranceParticipantDto implements AllergyIntoleranceParticipant {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    actor: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    function?: CodeableConcept

  }
  export class AllergyIntoleranceReactionDto implements AllergyIntoleranceReaction {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    exposureRoute?: CodeableConcept

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    manifestation: CodeableReference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    onset?: string

    @IsNotEmpty()
    @IsIn(["mild", "moderate", "severe"])
    severity: "mild" | "moderate" | "severe"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    substance?: CodeableConcept

  }
  export class AllergyIntoleranceDto implements AllergyIntolerance {
    @IsNotEmpty()
    @IsIn(["AllergyIntolerance"])
    resourceType: "AllergyIntolerance"

    @IsOptional()
    @IsArray()
    @IsIn(["food", "medication", "environment", "biologic"], { each: true })
    category?: ("food" | "medication" | "environment" | "biologic")[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    clinicalStatus?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsNotEmpty()
    @IsIn(["low", "high", "unable-to-assess"])
    criticality: "low" | "high" | "unable-to-assess"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsString()
    lastOccurrence?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    onsetDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    onsetAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    onsetPeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    onsetRange?: Range

    @IsOptional()
    @IsString()
    onsetString?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AllergyIntoleranceParticipantDto)
    participant?: AllergyIntoleranceParticipant[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AllergyIntoleranceReactionDto)
    reaction?: AllergyIntoleranceReaction[]

    @IsOptional()
    @IsString()
    recordedDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    verificationStatus?: CodeableConcept

  }
  export class AppointmentParticipantDto implements AppointmentParticipant {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    actor?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsNotEmpty()
    @IsBoolean()
    required: boolean

    @IsNotEmpty()
    @IsIn(["accepted", "declined", "tentative", "needs-action"])
    status: "accepted" | "declined" | "tentative" | "needs-action"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

  }
  export class AppointmentRecurrenceTemplateWeeklyTemplateDto implements AppointmentRecurrenceTemplateWeeklyTemplate {
    @IsNotEmpty()
    @IsBoolean()
    friday: boolean

    @IsNotEmpty()
    @IsBoolean()
    monday: boolean

    @IsNotEmpty()
    @IsBoolean()
    saturday: boolean

    @IsNotEmpty()
    @IsBoolean()
    sunday: boolean

    @IsNotEmpty()
    @IsBoolean()
    thursday: boolean

    @IsNotEmpty()
    @IsBoolean()
    tuesday: boolean

    @IsNotEmpty()
    @IsBoolean()
    wednesday: boolean

    @IsOptional()
    @IsNumber()
    weekInterval?: number

  }
  export class AppointmentRecurrenceTemplateMonthlyTemplateDto implements AppointmentRecurrenceTemplateMonthlyTemplate {
    @IsOptional()
    @IsNumber()
    dayOfMonth?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    dayOfWeek?: Coding

    @IsNotEmpty()
    @IsNumber()
    monthInterval: number

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    nthWeekOfMonth?: Coding

  }
  export class AppointmentRecurrenceTemplateYearlyTemplateDto implements AppointmentRecurrenceTemplateYearlyTemplate {
    @IsNotEmpty()
    @IsNumber()
    yearInterval: number

  }
  export class AppointmentRecurrenceTemplateDto implements AppointmentRecurrenceTemplate {
    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    excludingDate?: string[]

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    excludingRecurrenceId?: number[]

    @IsOptional()
    @IsString()
    lastOccurrenceDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AppointmentRecurrenceTemplateMonthlyTemplateDto)
    monthlyTemplate?: AppointmentRecurrenceTemplateMonthlyTemplate

    @IsOptional()
    @IsNumber()
    occurrenceCount?: number

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    occurrenceDate?: string[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    recurrenceType: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    timezone?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => AppointmentRecurrenceTemplateWeeklyTemplateDto)
    weeklyTemplate?: AppointmentRecurrenceTemplateWeeklyTemplate

    @IsOptional()
    @ValidateNested()
    @Type(() => AppointmentRecurrenceTemplateYearlyTemplateDto)
    yearlyTemplate?: AppointmentRecurrenceTemplateYearlyTemplate

  }
  export class AppointmentDto implements Appointment {
    @IsNotEmpty()
    @IsIn(["Appointment"])
    resourceType: "Appointment"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    account?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    appointmentType?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @IsString()
    cancellationDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    cancellationReason?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    class?: CodeableConcept[]

    @IsOptional()
    @IsString()
    created?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    end?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsNumber()
    minutesDuration?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsNotEmpty()
    @IsBoolean()
    occurrenceChanged: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    originatingAppointment?: Reference

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AppointmentParticipantDto)
    participant: AppointmentParticipant[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    patientInstruction?: CodeableReference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    previousAppointment?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    priority?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    reason?: CodeableReference[]

    @IsOptional()
    @IsNumber()
    recurrenceId?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AppointmentRecurrenceTemplateDto)
    recurrenceTemplate?: AppointmentRecurrenceTemplate[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    replaces?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PeriodDto)
    requestedPeriod?: Period[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    serviceCategory?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    serviceType?: CodeableReference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    slot?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    specialty?: CodeableConcept[]

    @IsOptional()
    @IsString()
    start?: string

    @IsNotEmpty()
    @IsIn(["entered-in-error", "proposed", "pending", "booked", "arrived", "fulfilled", "cancelled", "noshow", "checked-in", "waitlist"])
    status: "entered-in-error" | "proposed" | "pending" | "booked" | "arrived" | "fulfilled" | "cancelled" | "noshow" | "checked-in" | "waitlist"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    supportingInformation?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => VirtualServiceDetailDto)
    virtualService?: VirtualServiceDetail[]

  }
  export class AppointmentResponseDto implements AppointmentResponse {
    @IsNotEmpty()
    @IsIn(["AppointmentResponse"])
    resourceType: "AppointmentResponse"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    actor?: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    appointment: Reference

    @IsOptional()
    @IsString()
    comment?: string

    @IsOptional()
    @IsString()
    end?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsString()
    occurrenceDate?: string

    @IsNotEmpty()
    @IsIn(["entered-in-error", "accepted", "declined", "tentative", "needs-action"])
    participantStatus: "entered-in-error" | "accepted" | "declined" | "tentative" | "needs-action"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    participantType?: CodeableConcept[]

    @IsNotEmpty()
    @IsBoolean()
    proposedNewTime: boolean

    @IsOptional()
    @IsNumber()
    recurrenceId?: number

    @IsNotEmpty()
    @IsBoolean()
    recurring: boolean

    @IsOptional()
    @IsString()
    start?: string

  }
  export class ArtifactAssessmentContentDto implements ArtifactAssessmentContent {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    author?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    classifier?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ArtifactAssessmentContentDto)
    component?: ArtifactAssessmentContent[]

    @IsNotEmpty()
    @IsBoolean()
    freeToShare: boolean

    @IsNotEmpty()
    @IsIn(["comment", "classifier", "rating", "container", "response", "change-request"])
    informationType: "comment" | "classifier" | "rating" | "container" | "response" | "change-request"

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    path?: string[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    relatedArtifact?: RelatedArtifact[]

    @IsOptional()
    @IsString()
    summary?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class ArtifactAssessmentDto implements ArtifactAssessment {
    @IsNotEmpty()
    @IsIn(["ArtifactAssessment"])
    resourceType: "ArtifactAssessment"

    @IsOptional()
    @IsString()
    approvalDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    artifactReference?: Reference

    @IsOptional()
    @IsString()
    artifactCanonical?: string

    @IsOptional()
    @IsString()
    artifactUri?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    citeAsReference?: Reference

    @IsOptional()
    @IsString()
    citeAsMarkdown?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ArtifactAssessmentContentDto)
    content?: ArtifactAssessmentContent[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsNotEmpty()
    @IsIn(["unresolved", "not-persuasive", "persuasive", "persuasive-with-modification", "not-persuasive-with-modification"])
    disposition: "unresolved" | "not-persuasive" | "persuasive" | "persuasive-with-modification" | "not-persuasive-with-modification"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsString()
    lastReviewDate?: string

    @IsOptional()
    @IsString()
    title?: string

    @IsNotEmpty()
    @IsIn(["entered-in-error", "submitted", "triaged", "waiting-for-input", "resolved-no-change", "resolved-change-required", "deferred", "duplicate", "applied", "published"])
    workflowStatus: "entered-in-error" | "submitted" | "triaged" | "waiting-for-input" | "resolved-no-change" | "resolved-change-required" | "deferred" | "duplicate" | "applied" | "published"

  }
  export class AuditEventOutcomeDto implements AuditEventOutcome {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodingDto)
    code: Coding

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    detail?: CodeableConcept[]

  }
  export class AuditEventAgentDto implements AuditEventAgent {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    authorization?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    location?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    networkReference?: Reference

    @IsOptional()
    @IsString()
    networkUri?: string

    @IsOptional()
    @IsString()
    networkString?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    policy?: string[]

    @IsNotEmpty()
    @IsBoolean()
    requestor: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    role?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    who: Reference

  }
  export class AuditEventSourceDto implements AuditEventSource {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    observer: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    site?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

  }
  export class AuditEventEntityDetailDto implements AuditEventEntityDetail {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @IsString()
    valueString?: string

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    valueRatio?: Ratio

    @IsOptional()
    @IsString()
    valueTime?: string

    @IsOptional()
    @IsString()
    valueDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    valuePeriod?: Period

    @IsOptional()
    @IsString()
    valueBase64Binary?: string

  }
  export class AuditEventEntityDto implements AuditEventEntity {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AuditEventAgentDto)
    agent?: AuditEventAgent[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AuditEventEntityDetailDto)
    detail?: AuditEventEntityDetail[]

    @IsOptional()
    @IsString()
    query?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    role?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    securityLabel?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    what?: Reference

  }
  export class AuditEventDto implements AuditEvent {
    @IsNotEmpty()
    @IsIn(["AuditEvent"])
    resourceType: "AuditEvent"

    @IsOptional()
    @IsString()
    action?: string

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AuditEventAgentDto)
    agent: AuditEventAgent[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    authorization?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AuditEventEntityDto)
    entity?: AuditEventEntity[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    occurredPeriod?: Period

    @IsOptional()
    @IsString()
    occurredDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AuditEventOutcomeDto)
    outcome?: AuditEventOutcome

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient?: Reference

    @IsNotEmpty()
    @IsString()
    recorded: string

    @IsNotEmpty()
    @IsIn(["error", "warning", "informational", "emergency", "alert", "critical", "notice", "debug"])
    severity: "error" | "warning" | "informational" | "emergency" | "alert" | "critical" | "notice" | "debug"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => AuditEventSourceDto)
    source: AuditEventSource

  }
  export class BasicDto implements Basic {
    @IsNotEmpty()
    @IsIn(["Basic"])
    resourceType: "Basic"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    author?: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsOptional()
    @IsString()
    created?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

  }
  export class BinaryDto implements Binary {
    @IsNotEmpty()
    @IsIn(["Binary"])
    resourceType: "Binary"

    @IsNotEmpty()
    @IsString()
    contentType: string

    @IsOptional()
    @IsString()
    data?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    securityContext?: Reference

  }
  export class BiologicallyDerivedProductCollectionDto implements BiologicallyDerivedProductCollection {
    @IsOptional()
    @IsString()
    collectedDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    collectedPeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    collector?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    source?: Reference

  }
  export class BiologicallyDerivedProductPropertyDto implements BiologicallyDerivedProductProperty {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    valuePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    valueRatio?: Ratio

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

  }
  export class BiologicallyDerivedProductDto implements BiologicallyDerivedProduct {
    @IsNotEmpty()
    @IsIn(["BiologicallyDerivedProduct"])
    resourceType: "BiologicallyDerivedProduct"

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    biologicalSourceEvent?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => BiologicallyDerivedProductCollectionDto)
    collection?: BiologicallyDerivedProductCollection

    @IsOptional()
    @IsString()
    division?: string

    @IsOptional()
    @IsString()
    expirationDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    parent?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    processingFacility?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    productCategory?: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productCode?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    productStatus?: Coding

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => BiologicallyDerivedProductPropertyDto)
    property?: BiologicallyDerivedProductProperty[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    request?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    storageTempRequirements?: Range

  }
  export class BiologicallyDerivedProductDispensePerformerDto implements BiologicallyDerivedProductDispensePerformer {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    actor: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    function?: CodeableConcept

  }
  export class BiologicallyDerivedProductDispenseDto implements BiologicallyDerivedProductDispense {
    @IsNotEmpty()
    @IsIn(["BiologicallyDerivedProductDispense"])
    resourceType: "BiologicallyDerivedProductDispense"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    destination?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    location?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    matchStatus?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    originRelationshipType?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    partOf?: Reference[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => BiologicallyDerivedProductDispensePerformerDto)
    performer?: BiologicallyDerivedProductDispensePerformer[]

    @IsOptional()
    @IsString()
    preparedDate?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    product: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsNotEmpty()
    @IsIn(["unknown", "entered-in-error", "in-progress", "preparation", "allocated", "issued", "unfulfilled", "returned"])
    status: "unknown" | "entered-in-error" | "in-progress" | "preparation" | "allocated" | "issued" | "unfulfilled" | "returned"

    @IsOptional()
    @IsString()
    usageInstruction?: string

    @IsOptional()
    @IsString()
    whenHandedOver?: string

  }
  export class BodyStructureIncludedStructureBodyLandmarkOrientationDistanceFromLandmarkDto implements BodyStructureIncludedStructureBodyLandmarkOrientationDistanceFromLandmark {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    device?: CodeableReference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => QuantityDto)
    value?: Quantity[]

  }
  export class BodyStructureIncludedStructureBodyLandmarkOrientationDto implements BodyStructureIncludedStructureBodyLandmarkOrientation {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    clockFacePosition?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => BodyStructureIncludedStructureBodyLandmarkOrientationDistanceFromLandmarkDto)
    distanceFromLandmark?: BodyStructureIncludedStructureBodyLandmarkOrientationDistanceFromLandmark[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    landmarkDescription?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    surfaceOrientation?: CodeableConcept[]

  }
  export class BodyStructureIncludedStructureDto implements BodyStructureIncludedStructure {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => BodyStructureIncludedStructureBodyLandmarkOrientationDto)
    bodyLandmarkOrientation?: BodyStructureIncludedStructureBodyLandmarkOrientation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    laterality?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    qualifier?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    spatialReference?: Reference[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    structure: CodeableConcept

  }
  export class BodyStructureDto implements BodyStructure {
    @IsNotEmpty()
    @IsIn(["BodyStructure"])
    resourceType: "BodyStructure"

    @IsNotEmpty()
    @IsBoolean()
    active: boolean

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => BodyStructureIncludedStructureDto)
    excludedStructure?: BodyStructureIncludedStructure[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AttachmentDto)
    image?: Attachment[]

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => BodyStructureIncludedStructureDto)
    includedStructure: BodyStructureIncludedStructure[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    morphology?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient: Reference

  }
  export class BundleLinkDto implements BundleLink {
    @IsNotEmpty()
    @IsString()
    relation: string

    @IsNotEmpty()
    @IsString()
    url: string

  }
  export class BundleEntrySearchDto implements BundleEntrySearch {
    @IsNotEmpty()
    @IsIn(["match", "include", "outcome"])
    mode: "match" | "include" | "outcome"

    @IsOptional()
    @IsNumber()
    score?: number

  }
  export class BundleEntryRequestDto implements BundleEntryRequest {
    @IsOptional()
    @IsString()
    ifMatch?: string

    @IsOptional()
    @IsString()
    ifModifiedSince?: string

    @IsOptional()
    @IsString()
    ifNoneExist?: string

    @IsOptional()
    @IsString()
    ifNoneMatch?: string

    @IsNotEmpty()
    @IsIn(["GET", "HEAD", "POST", "PUT", "DELETE", "PATCH"])
    method: "GET" | "HEAD" | "POST" | "PUT" | "DELETE" | "PATCH"

    @IsNotEmpty()
    @IsString()
    url: string

  }
  export class BundleEntryResponseDto implements BundleEntryResponse {
    @IsOptional()
    @IsString()
    etag?: string

    @IsOptional()
    @IsString()
    lastModified?: string

    @IsOptional()
    @IsString()
    location?: string

    @IsNotEmpty()
    outcome: Account | ActivityDefinition | ActorDefinition | AdministrableProductDefinition | AdverseEvent | AllergyIntolerance | Appointment | AppointmentResponse | ArtifactAssessment | AuditEvent | Basic | Binary | BiologicallyDerivedProduct | BiologicallyDerivedProductDispense | BodyStructure | Bundle<FhirResource> | CapabilityStatement | CarePlan | CareTeam | ChargeItem | ChargeItemDefinition | Citation | Claim | ClaimResponse | ClinicalImpression | ClinicalUseDefinition | CodeSystem | Communication | CommunicationRequest | CompartmentDefinition | Composition | ConceptMap | Condition | ConditionDefinition | Consent | Contract | Coverage | CoverageEligibilityRequest | CoverageEligibilityResponse | DetectedIssue | Device | DeviceAssociation | DeviceDefinition | DeviceDispense | DeviceMetric | DeviceRequest | DeviceUsage | DiagnosticReport | DocumentReference | Encounter | EncounterHistory | Endpoint | EnrollmentRequest | EnrollmentResponse | EpisodeOfCare | EventDefinition | Evidence | EvidenceReport | EvidenceVariable | ExampleScenario | ExplanationOfBenefit | FamilyMemberHistory | Flag | FormularyItem | GenomicStudy | Goal | GraphDefinition | Group | GuidanceResponse | HealthcareService | ImagingSelection | ImagingStudy | Immunization | ImmunizationEvaluation | ImmunizationRecommendation | ImplementationGuide | Ingredient | InsurancePlan | InventoryItem | InventoryReport | Invoice | Library | Linkage | List | Location | ManufacturedItemDefinition | Measure | MeasureReport | Medication | MedicationAdministration | MedicationDispense | MedicationKnowledge | MedicationRequest | MedicationStatement | MedicinalProductDefinition | MessageDefinition | MessageHeader | MolecularSequence | NamingSystem | NutritionIntake | NutritionOrder | NutritionProduct | Observation | ObservationDefinition | OperationDefinition | OperationOutcome | Organization | OrganizationAffiliation | PackagedProductDefinition | Parameters | Patient | PaymentNotice | PaymentReconciliation | Permission | Person | PlanDefinition | Practitioner | PractitionerRole | Procedure | Provenance | Questionnaire | QuestionnaireResponse | RegulatedAuthorization | RelatedPerson | RequestOrchestration | Requirements | ResearchStudy | ResearchSubject | RiskAssessment | Schedule | SearchParameter | ServiceRequest | Slot | Specimen | SpecimenDefinition | StructureDefinition | StructureMap | Subscription | SubscriptionStatus | SubscriptionTopic | Substance | SubstanceDefinition | SubstanceNucleicAcid | SubstancePolymer | SubstanceProtein | SubstanceReferenceInformation | SubstanceSourceMaterial | SupplyDelivery | SupplyRequest | Task | TerminologyCapabilities | TestPlan | TestReport | TestScript | Transport | ValueSet | VerificationResult | VisionPrescription

    @IsNotEmpty()
    @IsString()
    status: string

  }
  export class BundleEntryDto<BundleContentType = FhirResource> implements BundleEntry<BundleContentType> {
    @IsOptional()
    @IsString()
    fullUrl?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => BundleLinkDto)
    link?: BundleLink[]

    @IsOptional()
    @ValidateNested()
    @Type(() => BundleEntryRequestDto)
    request?: BundleEntryRequest

    @IsOptional()
    resource?: BundleContentType

    @IsOptional()
    @ValidateNested()
    @Type(() => BundleEntryResponseDto)
    response?: BundleEntryResponse

    @IsOptional()
    @ValidateNested()
    @Type(() => BundleEntrySearchDto)
    search?: BundleEntrySearch

  }
  export class BundleDto<BundleContentType = FhirResource> implements Bundle<BundleContentType> {
    @IsNotEmpty()
    @IsIn(["Bundle"])
    resourceType: "Bundle"

    @IsOptional()
    @IsArray()
    entry?: BundleEntry<BundleContentType>[]

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsNotEmpty()
    issues: Account | ActivityDefinition | ActorDefinition | AdministrableProductDefinition | AdverseEvent | AllergyIntolerance | Appointment | AppointmentResponse | ArtifactAssessment | AuditEvent | Basic | Binary | BiologicallyDerivedProduct | BiologicallyDerivedProductDispense | BodyStructure | Bundle<FhirResource> | CapabilityStatement | CarePlan | CareTeam | ChargeItem | ChargeItemDefinition | Citation | Claim | ClaimResponse | ClinicalImpression | ClinicalUseDefinition | CodeSystem | Communication | CommunicationRequest | CompartmentDefinition | Composition | ConceptMap | Condition | ConditionDefinition | Consent | Contract | Coverage | CoverageEligibilityRequest | CoverageEligibilityResponse | DetectedIssue | Device | DeviceAssociation | DeviceDefinition | DeviceDispense | DeviceMetric | DeviceRequest | DeviceUsage | DiagnosticReport | DocumentReference | Encounter | EncounterHistory | Endpoint | EnrollmentRequest | EnrollmentResponse | EpisodeOfCare | EventDefinition | Evidence | EvidenceReport | EvidenceVariable | ExampleScenario | ExplanationOfBenefit | FamilyMemberHistory | Flag | FormularyItem | GenomicStudy | Goal | GraphDefinition | Group | GuidanceResponse | HealthcareService | ImagingSelection | ImagingStudy | Immunization | ImmunizationEvaluation | ImmunizationRecommendation | ImplementationGuide | Ingredient | InsurancePlan | InventoryItem | InventoryReport | Invoice | Library | Linkage | List | Location | ManufacturedItemDefinition | Measure | MeasureReport | Medication | MedicationAdministration | MedicationDispense | MedicationKnowledge | MedicationRequest | MedicationStatement | MedicinalProductDefinition | MessageDefinition | MessageHeader | MolecularSequence | NamingSystem | NutritionIntake | NutritionOrder | NutritionProduct | Observation | ObservationDefinition | OperationDefinition | OperationOutcome | Organization | OrganizationAffiliation | PackagedProductDefinition | Parameters | Patient | PaymentNotice | PaymentReconciliation | Permission | Person | PlanDefinition | Practitioner | PractitionerRole | Procedure | Provenance | Questionnaire | QuestionnaireResponse | RegulatedAuthorization | RelatedPerson | RequestOrchestration | Requirements | ResearchStudy | ResearchSubject | RiskAssessment | Schedule | SearchParameter | ServiceRequest | Slot | Specimen | SpecimenDefinition | StructureDefinition | StructureMap | Subscription | SubscriptionStatus | SubscriptionTopic | Substance | SubstanceDefinition | SubstanceNucleicAcid | SubstancePolymer | SubstanceProtein | SubstanceReferenceInformation | SubstanceSourceMaterial | SupplyDelivery | SupplyRequest | Task | TerminologyCapabilities | TestPlan | TestReport | TestScript | Transport | ValueSet | VerificationResult | VisionPrescription

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => BundleLinkDto)
    link?: BundleLink[]

    @IsOptional()
    @ValidateNested()
    @Type(() => SignatureDto)
    signature?: Signature

    @IsOptional()
    @IsString()
    timestamp?: string

    @IsOptional()
    @IsNumber()
    total?: number

    @IsNotEmpty()
    @IsIn(["document", "message", "transaction", "transaction-response", "batch", "batch-response", "history", "searchset", "collection", "subscription-notification"])
    type: "document" | "message" | "transaction" | "transaction-response" | "batch" | "batch-response" | "history" | "searchset" | "collection" | "subscription-notification"

  }
  export class CanonicalResourceDto implements CanonicalResource {
    @IsNotEmpty()
    @IsString()
    resourceType: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    copyrightLabel?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @IsString()
    versionAlgorithmString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    versionAlgorithmCoding?: Coding

  }
  export class CapabilityStatementSoftwareDto implements CapabilityStatementSoftware {
    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @IsString()
    releaseDate?: string

    @IsOptional()
    @IsString()
    version?: string

  }
  export class CapabilityStatementImplementationDto implements CapabilityStatementImplementation {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    custodian?: Reference

    @IsNotEmpty()
    @IsString()
    description: string

    @IsOptional()
    @IsString()
    url?: string

  }
  export class CapabilityStatementRestSecurityDto implements CapabilityStatementRestSecurity {
    @IsNotEmpty()
    @IsBoolean()
    cors: boolean

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    service?: CodeableConcept[]

  }
  export class CapabilityStatementRestResourceInteractionDto implements CapabilityStatementRestResourceInteraction {
    @IsNotEmpty()
    @IsIn(["read", "vread", "update", "patch", "delete", "history-instance", "history-type", "create", "search-type"])
    code: "read" | "vread" | "update" | "patch" | "delete" | "history-instance" | "history-type" | "create" | "search-type"

    @IsOptional()
    @IsString()
    documentation?: string

  }
  export class CapabilityStatementRestResourceSearchParamDto implements CapabilityStatementRestResourceSearchParam {
    @IsOptional()
    @IsString()
    definition?: string

    @IsOptional()
    @IsString()
    documentation?: string

    @IsNotEmpty()
    @IsString()
    name: string

    @IsNotEmpty()
    @IsIn(["string", "number", "date", "token", "reference", "composite", "quantity", "uri", "special"])
    type: "string" | "number" | "date" | "token" | "reference" | "composite" | "quantity" | "uri" | "special"

  }
  export class CapabilityStatementRestResourceOperationDto implements CapabilityStatementRestResourceOperation {
    @IsNotEmpty()
    @IsString()
    definition: string

    @IsOptional()
    @IsString()
    documentation?: string

    @IsNotEmpty()
    @IsString()
    name: string

  }
  export class CapabilityStatementRestResourceDto implements CapabilityStatementRestResource {
    @IsNotEmpty()
    @IsBoolean()
    conditionalCreate: boolean

    @IsNotEmpty()
    @IsIn(["not-supported", "single", "multiple"])
    conditionalDelete: "not-supported" | "single" | "multiple"

    @IsNotEmpty()
    @IsBoolean()
    conditionalPatch: boolean

    @IsNotEmpty()
    @IsIn(["not-supported", "modified-since", "not-match", "full-support"])
    conditionalRead: "not-supported" | "modified-since" | "not-match" | "full-support"

    @IsNotEmpty()
    @IsBoolean()
    conditionalUpdate: boolean

    @IsOptional()
    @IsString()
    documentation?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CapabilityStatementRestResourceInteractionDto)
    interaction?: CapabilityStatementRestResourceInteraction[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CapabilityStatementRestResourceOperationDto)
    operation?: CapabilityStatementRestResourceOperation[]

    @IsOptional()
    @IsString()
    profile?: string

    @IsNotEmpty()
    @IsBoolean()
    readHistory: boolean

    @IsOptional()
    @IsArray()
    @IsIn(["literal", "logical", "resolves", "enforced", "local"], { each: true })
    referencePolicy?: ("literal" | "logical" | "resolves" | "enforced" | "local")[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    searchInclude?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CapabilityStatementRestResourceSearchParamDto)
    searchParam?: CapabilityStatementRestResourceSearchParam[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    searchRevInclude?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    supportedProfile?: string[]

    @IsNotEmpty()
    @IsString()
    type: string

    @IsNotEmpty()
    @IsBoolean()
    updateCreate: boolean

    @IsNotEmpty()
    @IsIn(["no-version", "versioned", "versioned-update"])
    versioning: "no-version" | "versioned" | "versioned-update"

  }
  export class CapabilityStatementRestInteractionDto implements CapabilityStatementRestInteraction {
    @IsNotEmpty()
    @IsIn(["transaction", "batch", "search-system", "history-system"])
    code: "transaction" | "batch" | "search-system" | "history-system"

    @IsOptional()
    @IsString()
    documentation?: string

  }
  export class CapabilityStatementRestDto implements CapabilityStatementRest {
    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    compartment?: string[]

    @IsOptional()
    @IsString()
    documentation?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CapabilityStatementRestInteractionDto)
    interaction?: CapabilityStatementRestInteraction[]

    @IsNotEmpty()
    @IsIn(["client", "server"])
    mode: "client" | "server"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CapabilityStatementRestResourceOperationDto)
    operation?: CapabilityStatementRestResourceOperation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CapabilityStatementRestResourceDto)
    resource?: CapabilityStatementRestResource[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CapabilityStatementRestResourceSearchParamDto)
    searchParam?: CapabilityStatementRestResourceSearchParam[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CapabilityStatementRestSecurityDto)
    security?: CapabilityStatementRestSecurity

  }
  export class CapabilityStatementMessagingEndpointDto implements CapabilityStatementMessagingEndpoint {
    @IsNotEmpty()
    @IsString()
    address: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodingDto)
    protocol: Coding

  }
  export class CapabilityStatementMessagingSupportedMessageDto implements CapabilityStatementMessagingSupportedMessage {
    @IsNotEmpty()
    @IsString()
    definition: string

    @IsNotEmpty()
    @IsIn(["sender", "receiver"])
    mode: "sender" | "receiver"

  }
  export class CapabilityStatementMessagingDto implements CapabilityStatementMessaging {
    @IsOptional()
    @IsString()
    documentation?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CapabilityStatementMessagingEndpointDto)
    endpoint?: CapabilityStatementMessagingEndpoint[]

    @IsOptional()
    @IsNumber()
    reliableCache?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CapabilityStatementMessagingSupportedMessageDto)
    supportedMessage?: CapabilityStatementMessagingSupportedMessage[]

  }
  export class CapabilityStatementDocumentDto implements CapabilityStatementDocument {
    @IsOptional()
    @IsString()
    documentation?: string

    @IsNotEmpty()
    @IsIn(["producer", "consumer"])
    mode: "producer" | "consumer"

    @IsNotEmpty()
    @IsString()
    profile: string

  }
  export class CapabilityStatementDto implements CapabilityStatement {
    @IsNotEmpty()
    @IsIn(["CapabilityStatement"])
    resourceType: "CapabilityStatement"

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    acceptLanguage?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    copyrightLabel?: string

    @IsNotEmpty()
    @IsString()
    date: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CapabilityStatementDocumentDto)
    document?: CapabilityStatementDocument[]

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsNotEmpty()
    @IsString()
    fhirVersion: string

    @IsNotEmpty()
    @IsArray()
    @IsString({ each: true })
    format: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CapabilityStatementImplementationDto)
    implementation?: CapabilityStatementImplementation

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    implementationGuide?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    imports?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiates?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsNotEmpty()
    @IsIn(["instance", "capability", "requirements"])
    kind: "instance" | "capability" | "requirements"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CapabilityStatementMessagingDto)
    messaging?: CapabilityStatementMessaging[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    patchFormat?: string[]

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CapabilityStatementRestDto)
    rest?: CapabilityStatementRest[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CapabilityStatementSoftwareDto)
    software?: CapabilityStatementSoftware

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @IsString()
    versionAlgorithmString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    versionAlgorithmCoding?: Coding

  }
  export class CarePlanActivityDto implements CarePlanActivity {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    performedActivity?: CodeableReference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    plannedActivityReference?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    progress?: Annotation[]

  }
  export class CarePlanDto implements CarePlan {
    @IsNotEmpty()
    @IsIn(["CarePlan"])
    resourceType: "CarePlan"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CarePlanActivityDto)
    activity?: CarePlanActivity[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    addresses?: CodeableReference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    careTeam?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    contributor?: Reference[]

    @IsOptional()
    @IsString()
    created?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    custodian?: Reference

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    goal?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesCanonical?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesUri?: string[]

    @IsNotEmpty()
    @IsIn(["proposal", "plan", "directive", "order", "option"])
    intent: "proposal" | "plan" | "directive" | "order" | "option"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    partOf?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    replaces?: Reference[]

    @IsNotEmpty()
    @IsIn(["draft", "active", "unknown", "entered-in-error", "on-hold", "completed", "revoked"])
    status: "draft" | "active" | "unknown" | "entered-in-error" | "on-hold" | "completed" | "revoked"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    supportingInfo?: Reference[]

    @IsOptional()
    @IsString()
    title?: string

  }
  export class CareTeamParticipantDto implements CareTeamParticipant {
    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    coveragePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    coverageTiming?: Timing

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    member?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    onBehalfOf?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    role?: CodeableConcept

  }
  export class CareTeamDto implements CareTeam {
    @IsNotEmpty()
    @IsIn(["CareTeam"])
    resourceType: "CareTeam"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    managingOrganization?: Reference[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CareTeamParticipantDto)
    participant?: CareTeamParticipant[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    reason?: CodeableReference[]

    @IsNotEmpty()
    @IsIn(["active", "inactive", "entered-in-error", "proposed", "suspended"])
    status: "active" | "inactive" | "entered-in-error" | "proposed" | "suspended"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactPointDto)
    telecom?: ContactPoint[]

  }
  export class ChargeItemPerformerDto implements ChargeItemPerformer {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    actor: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    function?: CodeableConcept

  }
  export class ChargeItemDto implements ChargeItem {
    @IsNotEmpty()
    @IsIn(["ChargeItem"])
    resourceType: "ChargeItem"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    account?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    bodysite?: CodeableConcept[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    costCenter?: Reference

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    definitionCanonical?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    definitionUri?: string[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsString()
    enteredDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    enterer?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    occurrenceDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    occurrencePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    occurrenceTiming?: Timing

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    overrideReason?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    partOf?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ChargeItemPerformerDto)
    performer?: ChargeItemPerformer[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    performingOrganization?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    product?: CodeableReference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    reason?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    requestingOrganization?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    service?: CodeableReference[]

    @IsNotEmpty()
    @IsIn(["unknown", "entered-in-error", "planned", "billable", "not-billable", "aborted", "billed"])
    status: "unknown" | "entered-in-error" | "planned" | "billable" | "not-billable" | "aborted" | "billed"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    supportingInformation?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MonetaryComponentDto)
    totalPriceComponent?: MonetaryComponent

    @IsOptional()
    @ValidateNested()
    @Type(() => MonetaryComponentDto)
    unitPriceComponent?: MonetaryComponent

  }
  export class ChargeItemDefinitionApplicabilityDto implements ChargeItemDefinitionApplicability {
    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    condition?: Expression

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => RelatedArtifactDto)
    relatedArtifact?: RelatedArtifact

  }
  export class ChargeItemDefinitionPropertyGroupDto implements ChargeItemDefinitionPropertyGroup {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ChargeItemDefinitionApplicabilityDto)
    applicability?: ChargeItemDefinitionApplicability[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MonetaryComponentDto)
    priceComponent?: MonetaryComponent[]

  }
  export class ChargeItemDefinitionDto implements ChargeItemDefinition {
    @IsNotEmpty()
    @IsIn(["ChargeItemDefinition"])
    resourceType: "ChargeItemDefinition"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ChargeItemDefinitionApplicabilityDto)
    applicability?: ChargeItemDefinitionApplicability[]

    @IsOptional()
    @IsString()
    approvalDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    copyrightLabel?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    derivedFromUri?: string[]

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    instance?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    lastReviewDate?: string

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    partOf?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ChargeItemDefinitionPropertyGroupDto)
    propertyGroup?: ChargeItemDefinitionPropertyGroup[]

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    replaces?: string[]

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @IsString()
    versionAlgorithmString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    versionAlgorithmCoding?: Coding

  }
  export class CitationSummaryDto implements CitationSummary {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    style?: CodeableConcept

    @IsNotEmpty()
    @IsString()
    text: string

  }
  export class CitationClassificationDto implements CitationClassification {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    classifier?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class CitationStatusDateDto implements CitationStatusDate {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    activity: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    actual: boolean

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => PeriodDto)
    period: Period

  }
  export class CitationCitedArtifactVersionDto implements CitationCitedArtifactVersion {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    baseCitation?: Reference

    @IsNotEmpty()
    @IsString()
    value: string

  }
  export class CitationCitedArtifactStatusDateDto implements CitationCitedArtifactStatusDate {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    activity: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    actual: boolean

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => PeriodDto)
    period: Period

  }
  export class CitationCitedArtifactTitleDto implements CitationCitedArtifactTitle {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    language?: CodeableConcept

    @IsNotEmpty()
    @IsString()
    text: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

  }
  export class CitationCitedArtifactAbstractDto implements CitationCitedArtifactAbstract {
    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    language?: CodeableConcept

    @IsNotEmpty()
    @IsString()
    text: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class CitationCitedArtifactPartDto implements CitationCitedArtifactPart {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    baseCitation?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsOptional()
    @IsString()
    value?: string

  }
  export class CitationCitedArtifactRelatesToDto implements CitationCitedArtifactRelatesTo {
    @IsOptional()
    @IsString()
    citation?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    classifier?: CodeableConcept[]

    @IsOptional()
    @IsString()
    display?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    document?: Attachment

    @IsOptional()
    @IsString()
    label?: string

    @IsOptional()
    @IsString()
    resource?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    resourceReference?: Reference

    @IsNotEmpty()
    @IsIn(["documentation", "justification", "citation", "predecessor", "successor", "derived-from", "depends-on", "composed-of", "part-of", "amends", "amended-with", "appends", "appended-with", "cites", "cited-by", "comments-on", "comment-in", "contains", "contained-in", "corrects", "correction-in", "replaces", "replaced-with", "retracts", "retracted-by", "signs", "similar-to", "supports", "supported-with", "transforms", "transformed-into", "transformed-with", "documents", "specification-of", "created-with", "cite-as", "reprint", "reprint-of"])
    type: "documentation" | "justification" | "citation" | "predecessor" | "successor" | "derived-from" | "depends-on" | "composed-of" | "part-of" | "amends" | "amended-with" | "appends" | "appended-with" | "cites" | "cited-by" | "comments-on" | "comment-in" | "contains" | "contained-in" | "corrects" | "correction-in" | "replaces" | "replaced-with" | "retracts" | "retracted-by" | "signs" | "similar-to" | "supports" | "supported-with" | "transforms" | "transformed-into" | "transformed-with" | "documents" | "specification-of" | "created-with" | "cite-as" | "reprint" | "reprint-of"

  }
  export class CitationCitedArtifactPublicationFormPublishedInDto implements CitationCitedArtifactPublicationFormPublishedIn {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    publisher?: Reference

    @IsOptional()
    @IsString()
    publisherLocation?: string

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class CitationCitedArtifactPublicationFormDto implements CitationCitedArtifactPublicationForm {
    @IsOptional()
    @IsString()
    accessionNumber?: string

    @IsOptional()
    @IsString()
    articleDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    citedMedium?: CodeableConcept

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    firstPage?: string

    @IsOptional()
    @IsString()
    issue?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    language?: CodeableConcept[]

    @IsOptional()
    @IsString()
    lastPage?: string

    @IsOptional()
    @IsString()
    lastRevisionDate?: string

    @IsOptional()
    @IsString()
    pageCount?: string

    @IsOptional()
    @IsString()
    pageString?: string

    @IsOptional()
    @IsString()
    publicationDateSeason?: string

    @IsOptional()
    @IsString()
    publicationDateText?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CitationCitedArtifactPublicationFormPublishedInDto)
    publishedIn?: CitationCitedArtifactPublicationFormPublishedIn

    @IsOptional()
    @IsString()
    volume?: string

  }
  export class CitationCitedArtifactWebLocationDto implements CitationCitedArtifactWebLocation {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    classifier?: CodeableConcept[]

    @IsOptional()
    @IsString()
    url?: string

  }
  export class CitationCitedArtifactClassificationDto implements CitationCitedArtifactClassification {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    artifactAssessment?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    classifier?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class CitationCitedArtifactContributorshipEntryContributionInstanceDto implements CitationCitedArtifactContributorshipEntryContributionInstance {
    @IsOptional()
    @IsString()
    time?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class CitationCitedArtifactContributorshipEntryDto implements CitationCitedArtifactContributorshipEntry {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    affiliation?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CitationCitedArtifactContributorshipEntryContributionInstanceDto)
    contributionInstance?: CitationCitedArtifactContributorshipEntryContributionInstance[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    contributionType?: CodeableConcept[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    contributor: Reference

    @IsNotEmpty()
    @IsBoolean()
    correspondingContact: boolean

    @IsOptional()
    @IsString()
    forenameInitials?: string

    @IsOptional()
    @IsNumber()
    rankingOrder?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    role?: CodeableConcept

  }
  export class CitationCitedArtifactContributorshipSummaryDto implements CitationCitedArtifactContributorshipSummary {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    source?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    style?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsNotEmpty()
    @IsString()
    value: string

  }
  export class CitationCitedArtifactContributorshipDto implements CitationCitedArtifactContributorship {
    @IsNotEmpty()
    @IsBoolean()
    complete: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CitationCitedArtifactContributorshipEntryDto)
    entry?: CitationCitedArtifactContributorshipEntry[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CitationCitedArtifactContributorshipSummaryDto)
    summary?: CitationCitedArtifactContributorshipSummary[]

  }
  export class CitationCitedArtifactDto implements CitationCitedArtifact {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CitationCitedArtifactAbstractDto)
    abstract?: CitationCitedArtifactAbstract[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CitationCitedArtifactClassificationDto)
    classification?: CitationCitedArtifactClassification[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CitationCitedArtifactContributorshipDto)
    contributorship?: CitationCitedArtifactContributorship

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    currentState?: CodeableConcept[]

    @IsOptional()
    @IsString()
    dateAccessed?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CitationCitedArtifactPartDto)
    part?: CitationCitedArtifactPart

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CitationCitedArtifactPublicationFormDto)
    publicationForm?: CitationCitedArtifactPublicationForm[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    relatedIdentifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CitationCitedArtifactRelatesToDto)
    relatesTo?: CitationCitedArtifactRelatesTo[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CitationCitedArtifactStatusDateDto)
    statusDate?: CitationCitedArtifactStatusDate[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CitationCitedArtifactTitleDto)
    title?: CitationCitedArtifactTitle[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CitationCitedArtifactVersionDto)
    version?: CitationCitedArtifactVersion

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CitationCitedArtifactWebLocationDto)
    webLocation?: CitationCitedArtifactWebLocation[]

  }
  export class CitationDto implements Citation {
    @IsNotEmpty()
    @IsIn(["Citation"])
    resourceType: "Citation"

    @IsOptional()
    @IsString()
    approvalDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    author?: ContactDetail[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CitationCitedArtifactDto)
    citedArtifact?: CitationCitedArtifact

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CitationClassificationDto)
    classification?: CitationClassification[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    copyrightLabel?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    currentState?: CodeableConcept[]

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    editor?: ContactDetail[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    endorser?: ContactDetail[]

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    lastReviewDate?: string

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    relatedArtifact?: RelatedArtifact[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    reviewer?: ContactDetail[]

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CitationStatusDateDto)
    statusDate?: CitationStatusDate[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CitationSummaryDto)
    summary?: CitationSummary[]

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @IsString()
    versionAlgorithmString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    versionAlgorithmCoding?: Coding

  }
  export class ClaimRelatedDto implements ClaimRelated {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    claim?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    reference?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    relationship?: CodeableConcept

  }
  export class ClaimPayeeDto implements ClaimPayee {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    party?: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class ClaimEventDto implements ClaimEvent {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @IsString()
    whenDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    whenPeriod?: Period

  }
  export class ClaimCareTeamDto implements ClaimCareTeam {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    provider: Reference

    @IsNotEmpty()
    @IsBoolean()
    responsible: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    role?: CodeableConcept

    @IsNotEmpty()
    @IsNumber()
    sequence: number

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    specialty?: CodeableConcept

  }
  export class ClaimSupportingInfoDto implements ClaimSupportingInfo {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    reason?: CodeableConcept

    @IsNotEmpty()
    @IsNumber()
    sequence: number

    @IsOptional()
    @IsString()
    timingDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    timingPeriod?: Period

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    valueIdentifier?: Identifier

  }
  export class ClaimDiagnosisDto implements ClaimDiagnosis {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    diagnosisCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    diagnosisReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    onAdmission?: CodeableConcept

    @IsNotEmpty()
    @IsNumber()
    sequence: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

  }
  export class ClaimProcedureDto implements ClaimProcedure {
    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    procedureCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    procedureReference?: Reference

    @IsNotEmpty()
    @IsNumber()
    sequence: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    udi?: Reference[]

  }
  export class ClaimInsuranceDto implements ClaimInsurance {
    @IsOptional()
    @IsString()
    businessArrangement?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    claimResponse?: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    coverage: Reference

    @IsNotEmpty()
    @IsBoolean()
    focal: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    preAuthRef?: string[]

    @IsNotEmpty()
    @IsNumber()
    sequence: number

  }
  export class ClaimAccidentDto implements ClaimAccident {
    @IsNotEmpty()
    @IsString()
    date: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    locationAddress?: Address

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    locationReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class ClaimItemBodySiteDto implements ClaimItemBodySite {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    site: CodeableReference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    subSite?: CodeableConcept[]

  }
  export class ClaimItemDetailSubDetailDto implements ClaimItemDetailSubDetail {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept

    @IsOptional()
    @IsNumber()
    factor?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    modifier?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    net?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    patientPaid?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrService?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrServiceEnd?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    programCode?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    revenue?: CodeableConcept

    @IsNotEmpty()
    @IsNumber()
    sequence: number

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    tax?: Money

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    traceNumber?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    udi?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    unitPrice?: Money

  }
  export class ClaimItemDetailDto implements ClaimItemDetail {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept

    @IsOptional()
    @IsNumber()
    factor?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    modifier?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    net?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    patientPaid?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrService?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrServiceEnd?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    programCode?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    revenue?: CodeableConcept

    @IsNotEmpty()
    @IsNumber()
    sequence: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimItemDetailSubDetailDto)
    subDetail?: ClaimItemDetailSubDetail[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    tax?: Money

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    traceNumber?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    udi?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    unitPrice?: Money

  }
  export class ClaimItemDto implements ClaimItem {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimItemBodySiteDto)
    bodySite?: ClaimItemBodySite[]

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    careTeamSequence?: number[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimItemDetailDto)
    detail?: ClaimItemDetail[]

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    diagnosisSequence?: number[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    encounter?: Reference[]

    @IsOptional()
    @IsNumber()
    factor?: number

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    informationSequence?: number[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    locationCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    locationAddress?: Address

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    locationReference?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    modifier?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    net?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    patientPaid?: Money

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    procedureSequence?: number[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrService?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrServiceEnd?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    programCode?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    request?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    revenue?: CodeableConcept

    @IsNotEmpty()
    @IsNumber()
    sequence: number

    @IsOptional()
    @IsString()
    servicedDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    servicedPeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    tax?: Money

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    traceNumber?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    udi?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    unitPrice?: Money

  }
  export class ClaimDto implements Claim {
    @IsNotEmpty()
    @IsIn(["Claim"])
    resourceType: "Claim"

    @IsOptional()
    @ValidateNested()
    @Type(() => ClaimAccidentDto)
    accident?: ClaimAccident

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    billablePeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimCareTeamDto)
    careTeam?: ClaimCareTeam[]

    @IsNotEmpty()
    @IsString()
    created: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimDiagnosisDto)
    diagnosis?: ClaimDiagnosis[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    diagnosisRelatedGroup?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    encounter?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    enterer?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimEventDto)
    event?: ClaimEvent[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    facility?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    fundsReserve?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimInsuranceDto)
    insurance?: ClaimInsurance[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    insurer?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimItemDto)
    item?: ClaimItem[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    originalPrescription?: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    patientPaid?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => ClaimPayeeDto)
    payee?: ClaimPayee

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    prescription?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    priority?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimProcedureDto)
    procedure?: ClaimProcedure[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    provider?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    referral?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimRelatedDto)
    related?: ClaimRelated[]

    @IsNotEmpty()
    @IsIn(["draft", "active", "entered-in-error", "cancelled"])
    status: "draft" | "active" | "entered-in-error" | "cancelled"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    subType?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimSupportingInfoDto)
    supportingInfo?: ClaimSupportingInfo[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    total?: Money

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    traceNumber?: Identifier[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsNotEmpty()
    @IsIn(["claim", "preauthorization", "predetermination"])
    use: "claim" | "preauthorization" | "predetermination"

  }
  export class ClaimResponseEventDto implements ClaimResponseEvent {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @IsString()
    whenDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    whenPeriod?: Period

  }
  export class ClaimResponseItemReviewOutcomeDto implements ClaimResponseItemReviewOutcome {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    decision?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    preAuthPeriod?: Period

    @IsOptional()
    @IsString()
    preAuthRef?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    reason?: CodeableConcept[]

  }
  export class ClaimResponseItemAdjudicationDto implements ClaimResponseItemAdjudication {
    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    amount?: Money

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    reason?: CodeableConcept

  }
  export class ClaimResponseItemDetailSubDetailDto implements ClaimResponseItemDetailSubDetail {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimResponseItemAdjudicationDto)
    adjudication?: ClaimResponseItemAdjudication[]

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    noteNumber?: number[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ClaimResponseItemReviewOutcomeDto)
    reviewOutcome?: ClaimResponseItemReviewOutcome

    @IsNotEmpty()
    @IsNumber()
    subDetailSequence: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    traceNumber?: Identifier[]

  }
  export class ClaimResponseItemDetailDto implements ClaimResponseItemDetail {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimResponseItemAdjudicationDto)
    adjudication?: ClaimResponseItemAdjudication[]

    @IsNotEmpty()
    @IsNumber()
    detailSequence: number

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    noteNumber?: number[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ClaimResponseItemReviewOutcomeDto)
    reviewOutcome?: ClaimResponseItemReviewOutcome

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimResponseItemDetailSubDetailDto)
    subDetail?: ClaimResponseItemDetailSubDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    traceNumber?: Identifier[]

  }
  export class ClaimResponseItemDto implements ClaimResponseItem {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimResponseItemAdjudicationDto)
    adjudication?: ClaimResponseItemAdjudication[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimResponseItemDetailDto)
    detail?: ClaimResponseItemDetail[]

    @IsNotEmpty()
    @IsNumber()
    itemSequence: number

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    noteNumber?: number[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ClaimResponseItemReviewOutcomeDto)
    reviewOutcome?: ClaimResponseItemReviewOutcome

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    traceNumber?: Identifier[]

  }
  export class ClaimResponseAddItemBodySiteDto implements ClaimResponseAddItemBodySite {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    site: CodeableReference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    subSite?: CodeableConcept[]

  }
  export class ClaimResponseAddItemDetailSubDetailDto implements ClaimResponseAddItemDetailSubDetail {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimResponseItemAdjudicationDto)
    adjudication?: ClaimResponseItemAdjudication[]

    @IsOptional()
    @IsNumber()
    factor?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    modifier?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    net?: Money

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    noteNumber?: number[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrService?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrServiceEnd?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    revenue?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ClaimResponseItemReviewOutcomeDto)
    reviewOutcome?: ClaimResponseItemReviewOutcome

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    tax?: Money

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    traceNumber?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    unitPrice?: Money

  }
  export class ClaimResponseAddItemDetailDto implements ClaimResponseAddItemDetail {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimResponseItemAdjudicationDto)
    adjudication?: ClaimResponseItemAdjudication[]

    @IsOptional()
    @IsNumber()
    factor?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    modifier?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    net?: Money

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    noteNumber?: number[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrService?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrServiceEnd?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    revenue?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ClaimResponseItemReviewOutcomeDto)
    reviewOutcome?: ClaimResponseItemReviewOutcome

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimResponseAddItemDetailSubDetailDto)
    subDetail?: ClaimResponseAddItemDetailSubDetail[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    tax?: Money

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    traceNumber?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    unitPrice?: Money

  }
  export class ClaimResponseAddItemDto implements ClaimResponseAddItem {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimResponseItemAdjudicationDto)
    adjudication?: ClaimResponseItemAdjudication[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimResponseAddItemBodySiteDto)
    bodySite?: ClaimResponseAddItemBodySite[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimResponseAddItemDetailDto)
    detail?: ClaimResponseAddItemDetail[]

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    detailSequence?: number[]

    @IsOptional()
    @IsNumber()
    factor?: number

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    itemSequence?: number[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    locationCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    locationAddress?: Address

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    locationReference?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    modifier?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    net?: Money

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    noteNumber?: number[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrService?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrServiceEnd?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    programCode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    provider?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    request?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    revenue?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ClaimResponseItemReviewOutcomeDto)
    reviewOutcome?: ClaimResponseItemReviewOutcome

    @IsOptional()
    @IsString()
    servicedDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    servicedPeriod?: Period

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    subdetailSequence?: number[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    tax?: Money

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    traceNumber?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    unitPrice?: Money

  }
  export class ClaimResponseTotalDto implements ClaimResponseTotal {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => MoneyDto)
    amount: Money

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category: CodeableConcept

  }
  export class ClaimResponsePaymentDto implements ClaimResponsePayment {
    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    adjustment?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    adjustmentReason?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => MoneyDto)
    amount: Money

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class ClaimResponseProcessNoteDto implements ClaimResponseProcessNote {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    language?: CodeableConcept

    @IsOptional()
    @IsNumber()
    number?: number

    @IsNotEmpty()
    @IsString()
    text: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class ClaimResponseInsuranceDto implements ClaimResponseInsurance {
    @IsOptional()
    @IsString()
    businessArrangement?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    claimResponse?: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    coverage: Reference

    @IsNotEmpty()
    @IsBoolean()
    focal: boolean

    @IsNotEmpty()
    @IsNumber()
    sequence: number

  }
  export class ClaimResponseErrorDto implements ClaimResponseError {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsOptional()
    @IsNumber()
    detailSequence?: number

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    expression?: string[]

    @IsOptional()
    @IsNumber()
    itemSequence?: number

    @IsOptional()
    @IsNumber()
    subDetailSequence?: number

  }
  export class ClaimResponseDto implements ClaimResponse {
    @IsNotEmpty()
    @IsIn(["ClaimResponse"])
    resourceType: "ClaimResponse"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimResponseAddItemDto)
    addItem?: ClaimResponseAddItem[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimResponseItemAdjudicationDto)
    adjudication?: ClaimResponseItemAdjudication[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    communicationRequest?: Reference[]

    @IsNotEmpty()
    @IsString()
    created: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    decision?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    diagnosisRelatedGroup?: CodeableConcept

    @IsOptional()
    @IsString()
    disposition?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    encounter?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimResponseErrorDto)
    error?: ClaimResponseError[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimResponseEventDto)
    event?: ClaimResponseEvent[]

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    form?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    formCode?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    fundsReserve?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimResponseInsuranceDto)
    insurance?: ClaimResponseInsurance[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    insurer?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimResponseItemDto)
    item?: ClaimResponseItem[]

    @IsNotEmpty()
    @IsIn(["error", "queued", "complete", "partial"])
    outcome: "error" | "queued" | "complete" | "partial"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    payeeType?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ClaimResponsePaymentDto)
    payment?: ClaimResponsePayment

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    preAuthPeriod?: Period

    @IsOptional()
    @IsString()
    preAuthRef?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimResponseProcessNoteDto)
    processNote?: ClaimResponseProcessNote[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    request?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    requestor?: Reference

    @IsNotEmpty()
    @IsIn(["draft", "active", "entered-in-error", "cancelled"])
    status: "draft" | "active" | "entered-in-error" | "cancelled"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    subType?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimResponseTotalDto)
    total?: ClaimResponseTotal[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    traceNumber?: Identifier[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsNotEmpty()
    @IsIn(["claim", "preauthorization", "predetermination"])
    use: "claim" | "preauthorization" | "predetermination"

  }
  export class ClinicalImpressionFindingDto implements ClinicalImpressionFinding {
    @IsOptional()
    @IsString()
    basis?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    item?: CodeableReference

  }
  export class ClinicalImpressionDto implements ClinicalImpression {
    @IsNotEmpty()
    @IsIn(["ClinicalImpression"])
    resourceType: "ClinicalImpression"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    changePattern?: CodeableConcept

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    effectiveDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClinicalImpressionFindingDto)
    finding?: ClinicalImpressionFinding[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    performer?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    previous?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    problem?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    prognosisCodeableConcept?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    prognosisReference?: Reference[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    protocol?: string[]

    @IsNotEmpty()
    @IsIn(["unknown", "entered-in-error", "on-hold", "in-progress", "completed", "preparation", "not-done", "stopped"])
    status: "unknown" | "entered-in-error" | "on-hold" | "in-progress" | "completed" | "preparation" | "not-done" | "stopped"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    statusReason?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

    @IsOptional()
    @IsString()
    summary?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    supportingInfo?: Reference[]

  }
  export class ClinicalUseDefinitionContraindicationOtherTherapyDto implements ClinicalUseDefinitionContraindicationOtherTherapy {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    relationshipType: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    treatment: CodeableReference

  }
  export class ClinicalUseDefinitionContraindicationDto implements ClinicalUseDefinitionContraindication {
    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    applicability?: Expression

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    comorbidity?: CodeableReference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    diseaseStatus?: CodeableReference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    diseaseSymptomProcedure?: CodeableReference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    indication?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClinicalUseDefinitionContraindicationOtherTherapyDto)
    otherTherapy?: ClinicalUseDefinitionContraindicationOtherTherapy[]

  }
  export class ClinicalUseDefinitionIndicationDto implements ClinicalUseDefinitionIndication {
    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    applicability?: Expression

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    comorbidity?: CodeableReference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    diseaseStatus?: CodeableReference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    diseaseSymptomProcedure?: CodeableReference

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    durationRange?: Range

    @IsOptional()
    @IsString()
    durationString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    intendedEffect?: CodeableReference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClinicalUseDefinitionContraindicationOtherTherapyDto)
    otherTherapy?: ClinicalUseDefinitionContraindicationOtherTherapy[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    undesirableEffect?: Reference[]

  }
  export class ClinicalUseDefinitionInteractionInteractantDto implements ClinicalUseDefinitionInteractionInteractant {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    itemReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    itemCodeableConcept?: CodeableConcept

  }
  export class ClinicalUseDefinitionInteractionDto implements ClinicalUseDefinitionInteraction {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    effect?: CodeableReference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    incidence?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClinicalUseDefinitionInteractionInteractantDto)
    interactant?: ClinicalUseDefinitionInteractionInteractant[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    management?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class ClinicalUseDefinitionUndesirableEffectDto implements ClinicalUseDefinitionUndesirableEffect {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    classification?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    frequencyOfOccurrence?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    symptomConditionEffect?: CodeableReference

  }
  export class ClinicalUseDefinitionWarningDto implements ClinicalUseDefinitionWarning {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsString()
    description?: string

  }
  export class ClinicalUseDefinitionDto implements ClinicalUseDefinition {
    @IsNotEmpty()
    @IsIn(["ClinicalUseDefinition"])
    resourceType: "ClinicalUseDefinition"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ClinicalUseDefinitionContraindicationDto)
    contraindication?: ClinicalUseDefinitionContraindication

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ClinicalUseDefinitionIndicationDto)
    indication?: ClinicalUseDefinitionIndication

    @IsOptional()
    @ValidateNested()
    @Type(() => ClinicalUseDefinitionInteractionDto)
    interaction?: ClinicalUseDefinitionInteraction

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    library?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    population?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    status?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    subject?: Reference[]

    @IsNotEmpty()
    @IsIn(["warning", "indication", "contraindication", "interaction", "undesirable-effect"])
    type: "warning" | "indication" | "contraindication" | "interaction" | "undesirable-effect"

    @IsOptional()
    @ValidateNested()
    @Type(() => ClinicalUseDefinitionUndesirableEffectDto)
    undesirableEffect?: ClinicalUseDefinitionUndesirableEffect

    @IsOptional()
    @ValidateNested()
    @Type(() => ClinicalUseDefinitionWarningDto)
    warning?: ClinicalUseDefinitionWarning

  }
  export class CodeSystemFilterDto implements CodeSystemFilter {
    @IsNotEmpty()
    @IsString()
    code: string

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsArray()
    @IsIn(["exists", "in", "=", "is-a", "descendent-of", "is-not-a", "regex", "not-in", "generalizes", "child-of", "descendent-leaf"], { each: true })
    operator: ("exists" | "in" | "=" | "is-a" | "descendent-of" | "is-not-a" | "regex" | "not-in" | "generalizes" | "child-of" | "descendent-leaf")[]

    @IsNotEmpty()
    @IsString()
    value: string

  }
  export class CodeSystemPropertyDto implements CodeSystemProperty {
    @IsNotEmpty()
    @IsString()
    code: string

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsIn(["string", "boolean", "code", "Coding", "integer", "dateTime", "decimal"])
    type: "string" | "boolean" | "code" | "Coding" | "integer" | "dateTime" | "decimal"

    @IsOptional()
    @IsString()
    uri?: string

  }
  export class CodeSystemConceptDesignationDto implements CodeSystemConceptDesignation {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    additionalUse?: Coding[]

    @IsOptional()
    @IsString()
    language?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    use?: Coding

    @IsNotEmpty()
    @IsString()
    value: string

  }
  export class CodeSystemConceptPropertyDto implements CodeSystemConceptProperty {
    @IsNotEmpty()
    @IsString()
    code: string

    @IsOptional()
    @IsString()
    valueCode?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    valueCoding?: Coding

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsString()
    valueDateTime?: string

    @IsOptional()
    @IsNumber()
    valueDecimal?: number

  }
  export class CodeSystemConceptDto implements CodeSystemConcept {
    @IsNotEmpty()
    @IsString()
    code: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeSystemConceptDto)
    concept?: CodeSystemConcept[]

    @IsOptional()
    @IsString()
    definition?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeSystemConceptDesignationDto)
    designation?: CodeSystemConceptDesignation[]

    @IsOptional()
    @IsString()
    display?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeSystemConceptPropertyDto)
    property?: CodeSystemConceptProperty[]

  }
  export class CodeSystemDto implements CodeSystem {
    @IsNotEmpty()
    @IsIn(["CodeSystem"])
    resourceType: "CodeSystem"

    @IsOptional()
    @IsString()
    approvalDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    author?: ContactDetail[]

    @IsNotEmpty()
    @IsBoolean()
    caseSensitive: boolean

    @IsNotEmpty()
    @IsBoolean()
    compositional: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeSystemConceptDto)
    concept?: CodeSystemConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsNotEmpty()
    @IsIn(["example", "complete", "not-present", "fragment", "supplement"])
    content: "example" | "complete" | "not-present" | "fragment" | "supplement"

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    copyrightLabel?: string

    @IsOptional()
    @IsNumber()
    count?: number

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    editor?: ContactDetail[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    endorser?: ContactDetail[]

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeSystemFilterDto)
    filter?: CodeSystemFilter[]

    @IsNotEmpty()
    @IsIn(["part-of", "is-a", "grouped-by", "classified-with"])
    hierarchyMeaning: "part-of" | "is-a" | "grouped-by" | "classified-with"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    lastReviewDate?: string

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeSystemPropertyDto)
    property?: CodeSystemProperty[]

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    relatedArtifact?: RelatedArtifact[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    reviewer?: ContactDetail[]

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @IsString()
    supplements?: string

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    topic?: CodeableConcept[]

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    valueSet?: string

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @IsString()
    versionAlgorithmString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    versionAlgorithmCoding?: Coding

    @IsNotEmpty()
    @IsBoolean()
    versionNeeded: boolean

  }
  export class CommunicationPayloadDto implements CommunicationPayload {
    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    contentAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    contentReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    contentCodeableConcept?: CodeableConcept

  }
  export class CommunicationDto implements Communication {
    @IsNotEmpty()
    @IsIn(["Communication"])
    resourceType: "Communication"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    about?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    inResponseTo?: Reference[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesCanonical?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesUri?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    medium?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    partOf?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CommunicationPayloadDto)
    payload?: CommunicationPayload[]

    @IsNotEmpty()
    @IsIn(["routine", "urgent", "asap", "stat"])
    priority: "routine" | "urgent" | "asap" | "stat"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    reason?: CodeableReference[]

    @IsOptional()
    @IsString()
    received?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    recipient?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    sender?: Reference

    @IsOptional()
    @IsString()
    sent?: string

    @IsNotEmpty()
    @IsIn(["unknown", "entered-in-error", "on-hold", "in-progress", "completed", "preparation", "not-done", "stopped"])
    status: "unknown" | "entered-in-error" | "on-hold" | "in-progress" | "completed" | "preparation" | "not-done" | "stopped"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    statusReason?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    topic?: CodeableConcept

  }
  export class CommunicationRequestPayloadDto implements CommunicationRequestPayload {
    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    contentAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    contentReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    contentCodeableConcept?: CodeableConcept

  }
  export class CommunicationRequestDto implements CommunicationRequest {
    @IsNotEmpty()
    @IsIn(["CommunicationRequest"])
    resourceType: "CommunicationRequest"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    about?: Reference[]

    @IsOptional()
    @IsString()
    authoredOn?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsNotEmpty()
    @IsBoolean()
    doNotPerform: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    groupIdentifier?: Identifier

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    informationProvider?: Reference[]

    @IsNotEmpty()
    @IsIn(["proposal", "plan", "directive", "order", "original-order", "reflex-order", "filler-order", "instance-order", "option"])
    intent: "proposal" | "plan" | "directive" | "order" | "original-order" | "reflex-order" | "filler-order" | "instance-order" | "option"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    medium?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    occurrenceDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    occurrencePeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CommunicationRequestPayloadDto)
    payload?: CommunicationRequestPayload[]

    @IsNotEmpty()
    @IsIn(["routine", "urgent", "asap", "stat"])
    priority: "routine" | "urgent" | "asap" | "stat"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    reason?: CodeableReference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    recipient?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    replaces?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    requester?: Reference

    @IsNotEmpty()
    @IsIn(["draft", "active", "unknown", "entered-in-error", "on-hold", "completed", "revoked"])
    status: "draft" | "active" | "unknown" | "entered-in-error" | "on-hold" | "completed" | "revoked"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    statusReason?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

  }
  export class CompartmentDefinitionResourceDto implements CompartmentDefinitionResource {
    @IsNotEmpty()
    @IsString()
    code: string

    @IsOptional()
    @IsString()
    documentation?: string

    @IsOptional()
    @IsString()
    endParam?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    param?: string[]

    @IsOptional()
    @IsString()
    startParam?: string

  }
  export class CompartmentDefinitionDto implements CompartmentDefinition {
    @IsNotEmpty()
    @IsIn(["CompartmentDefinition"])
    resourceType: "CompartmentDefinition"

    @IsNotEmpty()
    @IsIn(["Patient", "Encounter", "RelatedPerson", "Practitioner", "Device", "EpisodeOfCare"])
    code: "Patient" | "Encounter" | "RelatedPerson" | "Practitioner" | "Device" | "EpisodeOfCare"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CompartmentDefinitionResourceDto)
    resource?: CompartmentDefinitionResource[]

    @IsNotEmpty()
    @IsBoolean()
    search: boolean

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @IsString()
    title?: string

    @IsNotEmpty()
    @IsString()
    url: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @IsString()
    versionAlgorithmString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    versionAlgorithmCoding?: Coding

  }
  export class CompositionAttesterDto implements CompositionAttester {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    mode: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    party?: Reference

    @IsOptional()
    @IsString()
    time?: string

  }
  export class CompositionEventDto implements CompositionEvent {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    detail?: CodeableReference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

  }
  export class CompositionSectionDto implements CompositionSection {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    author?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    emptyReason?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    entry?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    focus?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    orderedBy?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CompositionSectionDto)
    section?: CompositionSection[]

    @IsOptional()
    @ValidateNested()
    @Type(() => NarrativeDto)
    text?: Narrative

    @IsOptional()
    @IsString()
    title?: string

  }
  export class CompositionDto implements Composition {
    @IsNotEmpty()
    @IsIn(["Composition"])
    resourceType: "Composition"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CompositionAttesterDto)
    attester?: CompositionAttester[]

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    author: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    custodian?: Reference

    @IsNotEmpty()
    @IsString()
    date: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CompositionEventDto)
    event?: CompositionEvent[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    relatesTo?: RelatedArtifact[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CompositionSectionDto)
    section?: CompositionSection[]

    @IsNotEmpty()
    @IsIn(["unknown", "entered-in-error", "cancelled", "partial", "registered", "preliminary", "final", "amended", "corrected", "appended", "deprecated"])
    status: "unknown" | "entered-in-error" | "cancelled" | "partial" | "registered" | "preliminary" | "final" | "amended" | "corrected" | "appended" | "deprecated"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    subject?: Reference[]

    @IsNotEmpty()
    @IsString()
    title: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

  }
  export class ConceptMapPropertyDto implements ConceptMapProperty {
    @IsNotEmpty()
    @IsString()
    code: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    system?: string

    @IsNotEmpty()
    @IsIn(["string", "boolean", "code", "Coding", "integer", "dateTime", "decimal"])
    type: "string" | "boolean" | "code" | "Coding" | "integer" | "dateTime" | "decimal"

    @IsOptional()
    @IsString()
    uri?: string

  }
  export class ConceptMapAdditionalAttributeDto implements ConceptMapAdditionalAttribute {
    @IsNotEmpty()
    @IsString()
    code: string

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsIn(["string", "boolean", "code", "Coding", "Quantity"])
    type: "string" | "boolean" | "code" | "Coding" | "Quantity"

    @IsOptional()
    @IsString()
    uri?: string

  }
  export class ConceptMapGroupElementTargetPropertyDto implements ConceptMapGroupElementTargetProperty {
    @IsNotEmpty()
    @IsString()
    code: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    valueCoding?: Coding

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsString()
    valueDateTime?: string

    @IsOptional()
    @IsNumber()
    valueDecimal?: number

    @IsOptional()
    @IsString()
    valueCode?: string

  }
  export class ConceptMapGroupElementTargetDependsOnDto implements ConceptMapGroupElementTargetDependsOn {
    @IsNotEmpty()
    @IsString()
    attribute: string

    @IsOptional()
    @IsString()
    valueCode?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    valueCoding?: Coding

    @IsOptional()
    @IsString()
    valueString?: string

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @IsString()
    valueSet?: string

  }
  export class ConceptMapGroupElementTargetDto implements ConceptMapGroupElementTarget {
    @IsOptional()
    @IsString()
    code?: string

    @IsOptional()
    @IsString()
    comment?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ConceptMapGroupElementTargetDependsOnDto)
    dependsOn?: ConceptMapGroupElementTargetDependsOn[]

    @IsOptional()
    @IsString()
    display?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ConceptMapGroupElementTargetDependsOnDto)
    product?: ConceptMapGroupElementTargetDependsOn[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ConceptMapGroupElementTargetPropertyDto)
    property?: ConceptMapGroupElementTargetProperty[]

    @IsNotEmpty()
    @IsIn(["related-to", "equivalent", "source-is-narrower-than-target", "source-is-broader-than-target", "not-related-to"])
    relationship: "related-to" | "equivalent" | "source-is-narrower-than-target" | "source-is-broader-than-target" | "not-related-to"

    @IsOptional()
    @IsString()
    valueSet?: string

  }
  export class ConceptMapGroupElementDto implements ConceptMapGroupElement {
    @IsOptional()
    @IsString()
    code?: string

    @IsOptional()
    @IsString()
    display?: string

    @IsNotEmpty()
    @IsBoolean()
    noMap: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ConceptMapGroupElementTargetDto)
    target?: ConceptMapGroupElementTarget[]

    @IsOptional()
    @IsString()
    valueSet?: string

  }
  export class ConceptMapGroupUnmappedDto implements ConceptMapGroupUnmapped {
    @IsOptional()
    @IsString()
    code?: string

    @IsOptional()
    @IsString()
    display?: string

    @IsNotEmpty()
    @IsIn(["use-source-code", "fixed", "other-map"])
    mode: "use-source-code" | "fixed" | "other-map"

    @IsOptional()
    @IsString()
    otherMap?: string

    @IsNotEmpty()
    @IsIn(["related-to", "equivalent", "source-is-narrower-than-target", "source-is-broader-than-target", "not-related-to"])
    relationship: "related-to" | "equivalent" | "source-is-narrower-than-target" | "source-is-broader-than-target" | "not-related-to"

    @IsOptional()
    @IsString()
    valueSet?: string

  }
  export class ConceptMapGroupDto implements ConceptMapGroup {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ConceptMapGroupElementDto)
    element: ConceptMapGroupElement[]

    @IsOptional()
    @IsString()
    source?: string

    @IsOptional()
    @IsString()
    target?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ConceptMapGroupUnmappedDto)
    unmapped?: ConceptMapGroupUnmapped

  }
  export class ConceptMapDto implements ConceptMap {
    @IsNotEmpty()
    @IsIn(["ConceptMap"])
    resourceType: "ConceptMap"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ConceptMapAdditionalAttributeDto)
    additionalAttribute?: ConceptMapAdditionalAttribute[]

    @IsOptional()
    @IsString()
    approvalDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    author?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    copyrightLabel?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    editor?: ContactDetail[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    endorser?: ContactDetail[]

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ConceptMapGroupDto)
    group?: ConceptMapGroup[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    lastReviewDate?: string

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ConceptMapPropertyDto)
    property?: ConceptMapProperty[]

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    relatedArtifact?: RelatedArtifact[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    reviewer?: ContactDetail[]

    @IsOptional()
    @IsString()
    sourceScopeUri?: string

    @IsOptional()
    @IsString()
    sourceScopeCanonical?: string

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @IsString()
    targetScopeUri?: string

    @IsOptional()
    @IsString()
    targetScopeCanonical?: string

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    topic?: CodeableConcept[]

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @IsString()
    versionAlgorithmString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    versionAlgorithmCoding?: Coding

  }
  export class ConditionParticipantDto implements ConditionParticipant {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    actor: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    function?: CodeableConcept

  }
  export class ConditionStageDto implements ConditionStage {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    assessment?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    summary?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class ConditionDto implements Condition {
    @IsNotEmpty()
    @IsIn(["Condition"])
    resourceType: "Condition"

    @IsOptional()
    @IsString()
    abatementDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    abatementAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    abatementPeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    abatementRange?: Range

    @IsOptional()
    @IsString()
    abatementString?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    bodySite?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    clinicalStatus: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    evidence?: CodeableReference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    onsetDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    onsetAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    onsetPeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    onsetRange?: Range

    @IsOptional()
    @IsString()
    onsetString?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ConditionParticipantDto)
    participant?: ConditionParticipant[]

    @IsOptional()
    @IsString()
    recordedDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    severity?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ConditionStageDto)
    stage?: ConditionStage[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    verificationStatus?: CodeableConcept

  }
  export class ConditionDefinitionObservationDto implements ConditionDefinitionObservation {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

  }
  export class ConditionDefinitionMedicationDto implements ConditionDefinitionMedication {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

  }
  export class ConditionDefinitionPreconditionDto implements ConditionDefinitionPrecondition {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsNotEmpty()
    @IsIn(["specific", "sensitive"])
    type: "specific" | "sensitive"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

  }
  export class ConditionDefinitionQuestionnaireDto implements ConditionDefinitionQuestionnaire {
    @IsNotEmpty()
    @IsIn(["outcome", "preadmit", "diff-diagnosis"])
    purpose: "outcome" | "preadmit" | "diff-diagnosis"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    reference: Reference

  }
  export class ConditionDefinitionPlanDto implements ConditionDefinitionPlan {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    reference: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    role?: CodeableConcept

  }
  export class ConditionDefinitionDto implements ConditionDefinition {
    @IsNotEmpty()
    @IsIn(["ConditionDefinition"])
    resourceType: "ConditionDefinition"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    bodySite?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    definition?: string[]

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsNotEmpty()
    @IsBoolean()
    hasBodySite: boolean

    @IsNotEmpty()
    @IsBoolean()
    hasSeverity: boolean

    @IsNotEmpty()
    @IsBoolean()
    hasStage: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ConditionDefinitionMedicationDto)
    medication?: ConditionDefinitionMedication[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ConditionDefinitionObservationDto)
    observation?: ConditionDefinitionObservation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ConditionDefinitionPlanDto)
    plan?: ConditionDefinitionPlan[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ConditionDefinitionPreconditionDto)
    precondition?: ConditionDefinitionPrecondition[]

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ConditionDefinitionQuestionnaireDto)
    questionnaire?: ConditionDefinitionQuestionnaire[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    severity?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    stage?: CodeableConcept

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @IsString()
    subtitle?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    team?: Reference[]

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @IsString()
    versionAlgorithmString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    versionAlgorithmCoding?: Coding

  }
  export class ConsentPolicyBasisDto implements ConsentPolicyBasis {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    reference?: Reference

    @IsOptional()
    @IsString()
    url?: string

  }
  export class ConsentVerificationDto implements ConsentVerification {
    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    verificationDate?: string[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    verificationType?: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    verified: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    verifiedBy?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    verifiedWith?: Reference

  }
  export class ConsentProvisionActorDto implements ConsentProvisionActor {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    reference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    role?: CodeableConcept

  }
  export class ConsentProvisionDataDto implements ConsentProvisionData {
    @IsNotEmpty()
    @IsIn(["instance", "related", "dependents", "authoredby"])
    meaning: "instance" | "related" | "dependents" | "authoredby"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    reference: Reference

  }
  export class ConsentProvisionDto implements ConsentProvision {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    action?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ConsentProvisionActorDto)
    actor?: ConsentProvisionActor[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ConsentProvisionDataDto)
    data?: ConsentProvisionData[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    dataPeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    documentType?: Coding[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    expression?: Expression

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ConsentProvisionDto)
    provision?: ConsentProvision[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    purpose?: Coding[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    resourceType?: Coding[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    securityLabel?: Coding[]

  }
  export class ConsentDto implements Consent {
    @IsNotEmpty()
    @IsIn(["Consent"])
    resourceType: "Consent"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    controller?: Reference[]

    @IsOptional()
    @IsString()
    date?: string

    @IsNotEmpty()
    @IsIn(["deny", "permit"])
    decision: "deny" | "permit"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    grantee?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    grantor?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    manager?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => ConsentPolicyBasisDto)
    policyBasis?: ConsentPolicyBasis

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    policyText?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ConsentProvisionDto)
    provision?: ConsentProvision[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    regulatoryBasis?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AttachmentDto)
    sourceAttachment?: Attachment[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    sourceReference?: Reference[]

    @IsNotEmpty()
    @IsIn(["draft", "active", "unknown", "inactive", "entered-in-error", "not-done"])
    status: "draft" | "active" | "unknown" | "inactive" | "entered-in-error" | "not-done"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ConsentVerificationDto)
    verification?: ConsentVerification[]

  }
  export class ContractContentDefinitionDto implements ContractContentDefinition {
    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    publicationDate?: string

    @IsNotEmpty()
    @IsIn(["entered-in-error", "cancelled", "revoked", "amended", "appended", "disputed", "executable", "executed", "negotiable", "offered", "policy", "rejected", "renewed", "resolved", "terminated"])
    publicationStatus: "entered-in-error" | "cancelled" | "revoked" | "amended" | "appended" | "disputed" | "executable" | "executed" | "negotiable" | "offered" | "policy" | "rejected" | "renewed" | "resolved" | "terminated"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    publisher?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    subType?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class ContractTermSecurityLabelDto implements ContractTermSecurityLabel {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    category?: Coding[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodingDto)
    classification: Coding

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    control?: Coding[]

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    number?: number[]

  }
  export class ContractTermOfferPartyDto implements ContractTermOfferParty {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    reference: Reference[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    role: CodeableConcept

  }
  export class ContractTermOfferAnswerDto implements ContractTermOfferAnswer {
    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsNumber()
    valueDecimal?: number

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsOptional()
    @IsString()
    valueDate?: string

    @IsOptional()
    @IsString()
    valueDateTime?: string

    @IsOptional()
    @IsString()
    valueTime?: string

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @IsString()
    valueUri?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    valueCoding?: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

  }
  export class ContractTermOfferDto implements ContractTermOffer {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContractTermOfferAnswerDto)
    answer?: ContractTermOfferAnswer[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    decision?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    decisionMode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    linkId?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContractTermOfferPartyDto)
    party?: ContractTermOfferParty[]

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    securityLabelNumber?: number[]

    @IsOptional()
    @IsString()
    text?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    topic?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class ContractTermAssetContextDto implements ContractTermAssetContext {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    reference?: Reference

    @IsOptional()
    @IsString()
    text?: string

  }
  export class ContractTermAssetValuedItemDto implements ContractTermAssetValuedItem {
    @IsOptional()
    @IsString()
    effectiveTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    entityCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    entityReference?: Reference

    @IsOptional()
    @IsNumber()
    factor?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    linkId?: string[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    net?: Money

    @IsOptional()
    @IsString()
    payment?: string

    @IsOptional()
    @IsString()
    paymentDate?: string

    @IsOptional()
    @IsNumber()
    points?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    recipient?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    responsible?: Reference

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    securityLabelNumber?: number[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    unitPrice?: Money

  }
  export class ContractTermAssetDto implements ContractTermAsset {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContractTermOfferAnswerDto)
    answer?: ContractTermOfferAnswer[]

    @IsOptional()
    @IsString()
    condition?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContractTermAssetContextDto)
    context?: ContractTermAssetContext[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    linkId?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PeriodDto)
    period?: Period[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    periodType?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    relationship?: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    scope?: CodeableConcept

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    securityLabelNumber?: number[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    subtype?: CodeableConcept[]

    @IsOptional()
    @IsString()
    text?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    typeReference?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PeriodDto)
    usePeriod?: Period[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContractTermAssetValuedItemDto)
    valuedItem?: ContractTermAssetValuedItem[]

  }
  export class ContractTermActionSubjectDto implements ContractTermActionSubject {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    reference: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    role?: CodeableConcept

  }
  export class ContractTermActionDto implements ContractTermAction {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    context?: Reference

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    contextLinkId?: string[]

    @IsNotEmpty()
    @IsBoolean()
    doNotPerform: boolean

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    intent: CodeableConcept

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    linkId?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    occurrenceDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    occurrencePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    occurrenceTiming?: Timing

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    performer?: Reference

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    performerLinkId?: string[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    performerRole?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    performerType?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    reason?: CodeableReference[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    reasonLinkId?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    requester?: Reference[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    requesterLinkId?: string[]

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    securityLabelNumber?: number[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    status: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContractTermActionSubjectDto)
    subject?: ContractTermActionSubject[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class ContractTermDto implements ContractTerm {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContractTermActionDto)
    action?: ContractTermAction[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    applies?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContractTermAssetDto)
    asset?: ContractTermAsset[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContractTermDto)
    group?: ContractTerm[]

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsOptional()
    @IsString()
    issued?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ContractTermOfferDto)
    offer: ContractTermOffer

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContractTermSecurityLabelDto)
    securityLabel?: ContractTermSecurityLabel[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    subType?: CodeableConcept

    @IsOptional()
    @IsString()
    text?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    topicCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    topicReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class ContractSignerDto implements ContractSigner {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    party: Reference

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SignatureDto)
    signature: Signature[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodingDto)
    type: Coding

  }
  export class ContractFriendlyDto implements ContractFriendly {
    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    contentAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    contentReference?: Reference

  }
  export class ContractLegalDto implements ContractLegal {
    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    contentAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    contentReference?: Reference

  }
  export class ContractRuleDto implements ContractRule {
    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    contentAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    contentReference?: Reference

  }
  export class ContractDto implements Contract {
    @IsNotEmpty()
    @IsIn(["Contract"])
    resourceType: "Contract"

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    alias?: string[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    applies?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    author?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    authority?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ContractContentDefinitionDto)
    contentDefinition?: ContractContentDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    contentDerivative?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    domain?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    expirationType?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContractFriendlyDto)
    friendly?: ContractFriendly[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    instantiatesCanonical?: Reference

    @IsOptional()
    @IsString()
    instantiatesUri?: string

    @IsOptional()
    @IsString()
    issued?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContractLegalDto)
    legal?: ContractLegal[]

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    legallyBindingAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    legallyBindingReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    legalState?: CodeableConcept

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    relevantHistory?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContractRuleDto)
    rule?: ContractRule[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    scope?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContractSignerDto)
    signer?: ContractSigner[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    site?: Reference[]

    @IsNotEmpty()
    @IsIn(["entered-in-error", "cancelled", "revoked", "amended", "appended", "disputed", "executable", "executed", "negotiable", "offered", "policy", "rejected", "renewed", "resolved", "terminated"])
    status: "entered-in-error" | "cancelled" | "revoked" | "amended" | "appended" | "disputed" | "executable" | "executed" | "negotiable" | "offered" | "policy" | "rejected" | "renewed" | "resolved" | "terminated"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    subject?: Reference[]

    @IsOptional()
    @IsString()
    subtitle?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    subType?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    supportingInfo?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContractTermDto)
    term?: ContractTerm[]

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    topicCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    topicReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsString()
    version?: string

  }
  export class CoveragePaymentByDto implements CoveragePaymentBy {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    party: Reference

    @IsOptional()
    @IsString()
    responsibility?: string

  }
  export class CoverageClassDto implements CoverageClass {
    @IsOptional()
    @IsString()
    name?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => IdentifierDto)
    value: Identifier

  }
  export class CoverageCostToBeneficiaryExceptionDto implements CoverageCostToBeneficiaryException {
    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class CoverageCostToBeneficiaryDto implements CoverageCostToBeneficiary {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CoverageCostToBeneficiaryExceptionDto)
    exception?: CoverageCostToBeneficiaryException[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    network?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    term?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    unit?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    valueMoney?: Money

  }
  export class CoverageDto implements Coverage {
    @IsNotEmpty()
    @IsIn(["Coverage"])
    resourceType: "Coverage"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    beneficiary: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CoverageClassDto)
    class?: CoverageClass[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    contract?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CoverageCostToBeneficiaryDto)
    costToBeneficiary?: CoverageCostToBeneficiary[]

    @IsOptional()
    @IsString()
    dependent?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    insurancePlan?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    insurer?: Reference

    @IsNotEmpty()
    @IsIn(["other", "insurance", "self-pay"])
    kind: "other" | "insurance" | "self-pay"

    @IsOptional()
    @IsString()
    network?: string

    @IsOptional()
    @IsNumber()
    order?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CoveragePaymentByDto)
    paymentBy?: CoveragePaymentBy[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    policyHolder?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    relationship?: CodeableConcept

    @IsNotEmpty()
    @IsIn(["draft", "active", "entered-in-error", "cancelled"])
    status: "draft" | "active" | "entered-in-error" | "cancelled"

    @IsNotEmpty()
    @IsBoolean()
    subrogation: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subscriber?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    subscriberId?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class CoverageEligibilityRequestEventDto implements CoverageEligibilityRequestEvent {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @IsString()
    whenDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    whenPeriod?: Period

  }
  export class CoverageEligibilityRequestSupportingInfoDto implements CoverageEligibilityRequestSupportingInfo {
    @IsNotEmpty()
    @IsBoolean()
    appliesToAll: boolean

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    information: Reference

    @IsNotEmpty()
    @IsNumber()
    sequence: number

  }
  export class CoverageEligibilityRequestInsuranceDto implements CoverageEligibilityRequestInsurance {
    @IsOptional()
    @IsString()
    businessArrangement?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    coverage: Reference

    @IsNotEmpty()
    @IsBoolean()
    focal: boolean

  }
  export class CoverageEligibilityRequestItemDiagnosisDto implements CoverageEligibilityRequestItemDiagnosis {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    diagnosisCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    diagnosisReference?: Reference

  }
  export class CoverageEligibilityRequestItemDto implements CoverageEligibilityRequestItem {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    detail?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CoverageEligibilityRequestItemDiagnosisDto)
    diagnosis?: CoverageEligibilityRequestItemDiagnosis[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    facility?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    modifier?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrService?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    provider?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    supportingInfoSequence?: number[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    unitPrice?: Money

  }
  export class CoverageEligibilityRequestDto implements CoverageEligibilityRequest {
    @IsNotEmpty()
    @IsIn(["CoverageEligibilityRequest"])
    resourceType: "CoverageEligibilityRequest"

    @IsNotEmpty()
    @IsString()
    created: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    enterer?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CoverageEligibilityRequestEventDto)
    event?: CoverageEligibilityRequestEvent[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    facility?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CoverageEligibilityRequestInsuranceDto)
    insurance?: CoverageEligibilityRequestInsurance[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    insurer: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CoverageEligibilityRequestItemDto)
    item?: CoverageEligibilityRequestItem[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    priority?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    provider?: Reference

    @IsNotEmpty()
    @IsArray()
    @IsIn(["auth-requirements", "benefits", "discovery", "validation"], { each: true })
    purpose: ("auth-requirements" | "benefits" | "discovery" | "validation")[]

    @IsOptional()
    @IsString()
    servicedDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    servicedPeriod?: Period

    @IsNotEmpty()
    @IsIn(["draft", "active", "entered-in-error", "cancelled"])
    status: "draft" | "active" | "entered-in-error" | "cancelled"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CoverageEligibilityRequestSupportingInfoDto)
    supportingInfo?: CoverageEligibilityRequestSupportingInfo[]

  }
  export class CoverageEligibilityResponseEventDto implements CoverageEligibilityResponseEvent {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @IsString()
    whenDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    whenPeriod?: Period

  }
  export class CoverageEligibilityResponseInsuranceItemBenefitDto implements CoverageEligibilityResponseInsuranceItemBenefit {
    @IsOptional()
    @IsNumber()
    allowedUnsignedInt?: number

    @IsOptional()
    @IsString()
    allowedString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    allowedMoney?: Money

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @IsNumber()
    usedUnsignedInt?: number

    @IsOptional()
    @IsString()
    usedString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    usedMoney?: Money

  }
  export class CoverageEligibilityResponseInsuranceItemDto implements CoverageEligibilityResponseInsuranceItem {
    @IsNotEmpty()
    @IsBoolean()
    authorizationRequired: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    authorizationSupporting?: CodeableConcept[]

    @IsOptional()
    @IsString()
    authorizationUrl?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CoverageEligibilityResponseInsuranceItemBenefitDto)
    benefit?: CoverageEligibilityResponseInsuranceItemBenefit[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsBoolean()
    excluded: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    modifier?: CodeableConcept[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    network?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrService?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    provider?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    term?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    unit?: CodeableConcept

  }
  export class CoverageEligibilityResponseInsuranceDto implements CoverageEligibilityResponseInsurance {
    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    benefitPeriod?: Period

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    coverage: Reference

    @IsNotEmpty()
    @IsBoolean()
    inforce: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CoverageEligibilityResponseInsuranceItemDto)
    item?: CoverageEligibilityResponseInsuranceItem[]

  }
  export class CoverageEligibilityResponseErrorDto implements CoverageEligibilityResponseError {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    expression?: string[]

  }
  export class CoverageEligibilityResponseDto implements CoverageEligibilityResponse {
    @IsNotEmpty()
    @IsIn(["CoverageEligibilityResponse"])
    resourceType: "CoverageEligibilityResponse"

    @IsNotEmpty()
    @IsString()
    created: string

    @IsOptional()
    @IsString()
    disposition?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CoverageEligibilityResponseErrorDto)
    error?: CoverageEligibilityResponseError[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CoverageEligibilityResponseEventDto)
    event?: CoverageEligibilityResponseEvent[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    form?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CoverageEligibilityResponseInsuranceDto)
    insurance?: CoverageEligibilityResponseInsurance[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    insurer: Reference

    @IsNotEmpty()
    @IsIn(["error", "queued", "complete", "partial"])
    outcome: "error" | "queued" | "complete" | "partial"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient: Reference

    @IsOptional()
    @IsString()
    preAuthRef?: string

    @IsNotEmpty()
    @IsArray()
    @IsIn(["auth-requirements", "benefits", "discovery", "validation"], { each: true })
    purpose: ("auth-requirements" | "benefits" | "discovery" | "validation")[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    request: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    requestor?: Reference

    @IsOptional()
    @IsString()
    servicedDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    servicedPeriod?: Period

    @IsNotEmpty()
    @IsIn(["draft", "active", "entered-in-error", "cancelled"])
    status: "draft" | "active" | "entered-in-error" | "cancelled"

  }
  export class DetectedIssueEvidenceDto implements DetectedIssueEvidence {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    detail?: Reference[]

  }
  export class DetectedIssueMitigationDto implements DetectedIssueMitigation {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    action: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    author?: Reference

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

  }
  export class DetectedIssueDto implements DetectedIssue {
    @IsNotEmpty()
    @IsIn(["DetectedIssue"])
    resourceType: "DetectedIssue"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    author?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsString()
    detail?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DetectedIssueEvidenceDto)
    evidence?: DetectedIssueEvidence[]

    @IsOptional()
    @IsString()
    identifiedDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    identifiedPeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    implicated?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DetectedIssueMitigationDto)
    mitigation?: DetectedIssueMitigation[]

    @IsOptional()
    @IsString()
    reference?: string

    @IsNotEmpty()
    @IsIn(["moderate", "low", "high"])
    severity: "moderate" | "low" | "high"

    @IsNotEmpty()
    @IsIn(["entered-in-error", "preliminary", "final", "mitigated"])
    status: "entered-in-error" | "preliminary" | "final" | "mitigated"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

  }
  export class DeviceUdiCarrierDto implements DeviceUdiCarrier {
    @IsOptional()
    @IsString()
    carrierAIDC?: string

    @IsOptional()
    @IsString()
    carrierHRF?: string

    @IsNotEmpty()
    @IsString()
    deviceIdentifier: string

    @IsNotEmpty()
    @IsIn(["unknown", "barcode", "rfid", "manual", "card", "self-reported", "electronic-transmission"])
    entryType: "unknown" | "barcode" | "rfid" | "manual" | "card" | "self-reported" | "electronic-transmission"

    @IsNotEmpty()
    @IsString()
    issuer: string

    @IsOptional()
    @IsString()
    jurisdiction?: string

  }
  export class DeviceNameDto implements DeviceName {
    @IsNotEmpty()
    @IsBoolean()
    display: boolean

    @IsNotEmpty()
    @IsIn(["registered-name", "user-friendly-name", "patient-reported-name"])
    type: "registered-name" | "user-friendly-name" | "patient-reported-name"

    @IsNotEmpty()
    @IsString()
    value: string

  }
  export class DeviceVersionDto implements DeviceVersion {
    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    component?: Identifier

    @IsOptional()
    @IsString()
    installDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsNotEmpty()
    @IsString()
    value: string

  }
  export class DeviceConformsToDto implements DeviceConformsTo {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    specification: CodeableConcept

    @IsOptional()
    @IsString()
    version?: string

  }
  export class DevicePropertyDto implements DeviceProperty {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @IsString()
    valueString?: string

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

  }
  export class DeviceDto implements Device {
    @IsNotEmpty()
    @IsIn(["Device"])
    resourceType: "Device"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    availabilityStatus?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    biologicalSourceEvent?: Identifier

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DeviceConformsToDto)
    conformsTo?: DeviceConformsTo[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactPointDto)
    contact?: ContactPoint[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CountDto)
    cycle?: Count

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    definition?: CodeableReference

    @IsOptional()
    @IsString()
    displayName?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    duration?: Duration

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    endpoint?: Reference[]

    @IsOptional()
    @IsString()
    expirationDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    gateway?: CodeableReference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    location?: Reference

    @IsOptional()
    @IsString()
    lotNumber?: string

    @IsOptional()
    @IsString()
    manufactureDate?: string

    @IsOptional()
    @IsString()
    manufacturer?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    mode?: CodeableConcept

    @IsOptional()
    @IsString()
    modelNumber?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DeviceNameDto)
    name?: DeviceName[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    owner?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    parent?: Reference

    @IsOptional()
    @IsString()
    partNumber?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DevicePropertyDto)
    property?: DeviceProperty[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    safety?: CodeableConcept[]

    @IsOptional()
    @IsString()
    serialNumber?: string

    @IsNotEmpty()
    @IsIn(["active", "inactive", "entered-in-error"])
    status: "active" | "inactive" | "entered-in-error"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DeviceUdiCarrierDto)
    udiCarrier?: DeviceUdiCarrier[]

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DeviceVersionDto)
    version?: DeviceVersion[]

  }
  export class DeviceAssociationOperationDto implements DeviceAssociationOperation {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    operator?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    status: CodeableConcept

  }
  export class DeviceAssociationDto implements DeviceAssociation {
    @IsNotEmpty()
    @IsIn(["DeviceAssociation"])
    resourceType: "DeviceAssociation"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    bodyStructure?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    device: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DeviceAssociationOperationDto)
    operation?: DeviceAssociationOperation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    status: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    statusReason?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

  }
  export class DeviceDefinitionUdiDeviceIdentifierMarketDistributionDto implements DeviceDefinitionUdiDeviceIdentifierMarketDistribution {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => PeriodDto)
    marketPeriod: Period

    @IsNotEmpty()
    @IsString()
    subJurisdiction: string

  }
  export class DeviceDefinitionUdiDeviceIdentifierDto implements DeviceDefinitionUdiDeviceIdentifier {
    @IsNotEmpty()
    @IsString()
    deviceIdentifier: string

    @IsNotEmpty()
    @IsString()
    issuer: string

    @IsNotEmpty()
    @IsString()
    jurisdiction: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DeviceDefinitionUdiDeviceIdentifierMarketDistributionDto)
    marketDistribution?: DeviceDefinitionUdiDeviceIdentifierMarketDistribution[]

  }
  export class DeviceDefinitionRegulatoryIdentifierDto implements DeviceDefinitionRegulatoryIdentifier {
    @IsNotEmpty()
    @IsString()
    deviceIdentifier: string

    @IsNotEmpty()
    @IsString()
    issuer: string

    @IsNotEmpty()
    @IsString()
    jurisdiction: string

    @IsNotEmpty()
    @IsIn(["basic", "master", "license"])
    type: "basic" | "master" | "license"

  }
  export class DeviceDefinitionDeviceNameDto implements DeviceDefinitionDeviceName {
    @IsNotEmpty()
    @IsString()
    name: string

    @IsNotEmpty()
    @IsIn(["registered-name", "user-friendly-name", "patient-reported-name"])
    type: "registered-name" | "user-friendly-name" | "patient-reported-name"

  }
  export class DeviceDefinitionClassificationDto implements DeviceDefinitionClassification {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    justification?: RelatedArtifact[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class DeviceDefinitionConformsToDto implements DeviceDefinitionConformsTo {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    source?: RelatedArtifact[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    specification: CodeableConcept

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    version?: string[]

  }
  export class DeviceDefinitionHasPartDto implements DeviceDefinitionHasPart {
    @IsOptional()
    @IsNumber()
    count?: number

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    reference: Reference

  }
  export class DeviceDefinitionPackagingDistributorDto implements DeviceDefinitionPackagingDistributor {
    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    organizationReference?: Reference[]

  }
  export class DeviceDefinitionPackagingDto implements DeviceDefinitionPackaging {
    @IsOptional()
    @IsNumber()
    count?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DeviceDefinitionPackagingDistributorDto)
    distributor?: DeviceDefinitionPackagingDistributor[]

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DeviceDefinitionPackagingDto)
    packaging?: DeviceDefinitionPackaging[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DeviceDefinitionUdiDeviceIdentifierDto)
    udiDeviceIdentifier?: DeviceDefinitionUdiDeviceIdentifier[]

  }
  export class DeviceDefinitionVersionDto implements DeviceDefinitionVersion {
    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    component?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsNotEmpty()
    @IsString()
    value: string

  }
  export class DeviceDefinitionPropertyDto implements DeviceDefinitionProperty {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @IsString()
    valueString?: string

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

  }
  export class DeviceDefinitionLinkDto implements DeviceDefinitionLink {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    relatedDevice: CodeableReference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodingDto)
    relation: Coding

  }
  export class DeviceDefinitionMaterialDto implements DeviceDefinitionMaterial {
    @IsNotEmpty()
    @IsBoolean()
    allergenicIndicator: boolean

    @IsNotEmpty()
    @IsBoolean()
    alternate: boolean

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    substance: CodeableConcept

  }
  export class DeviceDefinitionGuidelineDto implements DeviceDefinitionGuideline {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    contraindication?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    indication?: CodeableConcept[]

    @IsOptional()
    @IsString()
    intendedUse?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    relatedArtifact?: RelatedArtifact[]

    @IsOptional()
    @IsString()
    usageInstruction?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    warning?: CodeableConcept[]

  }
  export class DeviceDefinitionCorrectiveActionDto implements DeviceDefinitionCorrectiveAction {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => PeriodDto)
    period: Period

    @IsNotEmpty()
    @IsBoolean()
    recall: boolean

    @IsNotEmpty()
    @IsIn(["model", "lot-numbers", "serial-numbers"])
    scope: "model" | "lot-numbers" | "serial-numbers"

  }
  export class DeviceDefinitionChargeItemDto implements DeviceDefinitionChargeItem {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    chargeItemCode: CodeableReference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => QuantityDto)
    count: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

  }
  export class DeviceDefinitionDto implements DeviceDefinition {
    @IsNotEmpty()
    @IsIn(["DeviceDefinition"])
    resourceType: "DeviceDefinition"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DeviceDefinitionChargeItemDto)
    chargeItem?: DeviceDefinitionChargeItem[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DeviceDefinitionClassificationDto)
    classification?: DeviceDefinitionClassification[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DeviceDefinitionConformsToDto)
    conformsTo?: DeviceDefinitionConformsTo[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactPointDto)
    contact?: ContactPoint[]

    @IsOptional()
    @ValidateNested()
    @Type(() => DeviceDefinitionCorrectiveActionDto)
    correctiveAction?: DeviceDefinitionCorrectiveAction

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DeviceDefinitionDeviceNameDto)
    deviceName?: DeviceDefinitionDeviceName[]

    @IsOptional()
    @ValidateNested()
    @Type(() => DeviceDefinitionGuidelineDto)
    guideline?: DeviceDefinitionGuideline

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DeviceDefinitionHasPartDto)
    hasPart?: DeviceDefinitionHasPart[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    languageCode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DeviceDefinitionLinkDto)
    link?: DeviceDefinitionLink[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    manufacturer?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DeviceDefinitionMaterialDto)
    material?: DeviceDefinitionMaterial[]

    @IsOptional()
    @IsString()
    modelNumber?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    owner?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DeviceDefinitionPackagingDto)
    packaging?: DeviceDefinitionPackaging[]

    @IsOptional()
    @IsString()
    partNumber?: string

    @IsOptional()
    @IsArray()
    @IsIn(["lot-number", "manufactured-date", "serial-number", "expiration-date", "biological-source", "software-version"], { each: true })
    productionIdentifierInUDI?: ("lot-number" | "manufactured-date" | "serial-number" | "expiration-date" | "biological-source" | "software-version")[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DeviceDefinitionPropertyDto)
    property?: DeviceDefinitionProperty[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DeviceDefinitionRegulatoryIdentifierDto)
    regulatoryIdentifier?: DeviceDefinitionRegulatoryIdentifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    safety?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ProductShelfLifeDto)
    shelfLifeStorage?: ProductShelfLife[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DeviceDefinitionUdiDeviceIdentifierDto)
    udiDeviceIdentifier?: DeviceDefinitionUdiDeviceIdentifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DeviceDefinitionVersionDto)
    version?: DeviceDefinitionVersion[]

  }
  export class DeviceDispensePerformerDto implements DeviceDispensePerformer {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    actor: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    function?: CodeableConcept

  }
  export class DeviceDispenseDto implements DeviceDispense {
    @IsNotEmpty()
    @IsIn(["DeviceDispense"])
    resourceType: "DeviceDispense"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    destination?: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    device: CodeableReference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    eventHistory?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    location?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    partOf?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DeviceDispensePerformerDto)
    performer?: DeviceDispensePerformer[]

    @IsOptional()
    @IsString()
    preparedDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    receiver?: Reference

    @IsNotEmpty()
    @IsIn(["unknown", "entered-in-error", "on-hold", "in-progress", "completed", "declined", "cancelled", "preparation", "stopped"])
    status: "unknown" | "entered-in-error" | "on-hold" | "in-progress" | "completed" | "declined" | "cancelled" | "preparation" | "stopped"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    statusReason?: CodeableReference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    supportingInformation?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsOptional()
    @IsString()
    usageInstruction?: string

    @IsOptional()
    @IsString()
    whenHandedOver?: string

  }
  export class DeviceMetricCalibrationDto implements DeviceMetricCalibration {
    @IsNotEmpty()
    @IsIn(["not-calibrated", "calibration-required", "calibrated", "unspecified"])
    state: "not-calibrated" | "calibration-required" | "calibrated" | "unspecified"

    @IsOptional()
    @IsString()
    time?: string

    @IsNotEmpty()
    @IsIn(["unspecified", "offset", "gain", "two-point"])
    type: "unspecified" | "offset" | "gain" | "two-point"

  }
  export class DeviceMetricDto implements DeviceMetric {
    @IsNotEmpty()
    @IsIn(["DeviceMetric"])
    resourceType: "DeviceMetric"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DeviceMetricCalibrationDto)
    calibration?: DeviceMetricCalibration[]

    @IsNotEmpty()
    @IsIn(["unspecified", "measurement", "setting", "calculation"])
    category: "unspecified" | "measurement" | "setting" | "calculation"

    @IsOptional()
    @IsString()
    color?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    device: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    measurementFrequency?: Quantity

    @IsNotEmpty()
    @IsIn(["entered-in-error", "on", "off", "standby"])
    operationalStatus: "entered-in-error" | "on" | "off" | "standby"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    unit?: CodeableConcept

  }
  export class DeviceRequestParameterDto implements DeviceRequestParameter {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

  }
  export class DeviceRequestDto implements DeviceRequest {
    @IsNotEmpty()
    @IsIn(["DeviceRequest"])
    resourceType: "DeviceRequest"

    @IsNotEmpty()
    @IsBoolean()
    asNeeded: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    asNeededFor?: CodeableConcept

    @IsOptional()
    @IsString()
    authoredOn?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    code: CodeableReference

    @IsNotEmpty()
    @IsBoolean()
    doNotPerform: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    groupIdentifier?: Identifier

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesCanonical?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesUri?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    insurance?: Reference[]

    @IsNotEmpty()
    @IsIn(["proposal", "plan", "directive", "order", "original-order", "reflex-order", "filler-order", "instance-order", "option"])
    intent: "proposal" | "plan" | "directive" | "order" | "original-order" | "reflex-order" | "filler-order" | "instance-order" | "option"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    occurrenceDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    occurrencePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    occurrenceTiming?: Timing

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DeviceRequestParameterDto)
    parameter?: DeviceRequestParameter[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    performer?: CodeableReference

    @IsNotEmpty()
    @IsIn(["routine", "urgent", "asap", "stat"])
    priority: "routine" | "urgent" | "asap" | "stat"

    @IsOptional()
    @IsNumber()
    quantity?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    reason?: CodeableReference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    relevantHistory?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    replaces?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    requester?: Reference

    @IsNotEmpty()
    @IsIn(["draft", "active", "unknown", "entered-in-error", "on-hold", "completed", "revoked"])
    status: "draft" | "active" | "unknown" | "entered-in-error" | "on-hold" | "completed" | "revoked"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    supportingInfo?: Reference[]

  }
  export class DeviceUsageAdherenceDto implements DeviceUsageAdherence {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    reason: CodeableConcept[]

  }
  export class DeviceUsageDto implements DeviceUsage {
    @IsNotEmpty()
    @IsIn(["DeviceUsage"])
    resourceType: "DeviceUsage"

    @IsOptional()
    @ValidateNested()
    @Type(() => DeviceUsageAdherenceDto)
    adherence?: DeviceUsageAdherence

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    bodySite?: CodeableReference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    context?: Reference

    @IsOptional()
    @IsString()
    dateAsserted?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    derivedFrom?: Reference[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    device: CodeableReference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    informationSource?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    reason?: CodeableReference[]

    @IsNotEmpty()
    @IsIn(["active", "entered-in-error", "on-hold", "completed", "not-done", "stopped", "intended"])
    status: "active" | "entered-in-error" | "on-hold" | "completed" | "not-done" | "stopped" | "intended"

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    timingTiming?: Timing

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    timingPeriod?: Period

    @IsOptional()
    @IsString()
    timingDateTime?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    usageReason?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    usageStatus?: CodeableConcept

  }
  export class DiagnosticReportSupportingInfoDto implements DiagnosticReportSupportingInfo {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    reference: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class DiagnosticReportMediaDto implements DiagnosticReportMedia {
    @IsOptional()
    @IsString()
    comment?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    link: Reference

  }
  export class DiagnosticReportDto implements DiagnosticReport {
    @IsNotEmpty()
    @IsIn(["DiagnosticReport"])
    resourceType: "DiagnosticReport"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    composition?: Reference

    @IsOptional()
    @IsString()
    conclusion?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    conclusionCode?: CodeableConcept[]

    @IsOptional()
    @IsString()
    effectiveDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsString()
    issued?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DiagnosticReportMediaDto)
    media?: DiagnosticReportMedia[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    performer?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AttachmentDto)
    presentedForm?: Attachment[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    result?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    resultsInterpreter?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    specimen?: Reference[]

    @IsNotEmpty()
    @IsIn(["unknown", "entered-in-error", "cancelled", "partial", "registered", "preliminary", "final", "amended", "corrected", "appended", "modified"])
    status: "unknown" | "entered-in-error" | "cancelled" | "partial" | "registered" | "preliminary" | "final" | "amended" | "corrected" | "appended" | "modified"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    study?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DiagnosticReportSupportingInfoDto)
    supportingInfo?: DiagnosticReportSupportingInfo[]

  }
  export class DocumentReferenceAttesterDto implements DocumentReferenceAttester {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    mode: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    party?: Reference

    @IsOptional()
    @IsString()
    time?: string

  }
  export class DocumentReferenceRelatesToDto implements DocumentReferenceRelatesTo {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    target: Reference

  }
  export class DocumentReferenceContentProfileDto implements DocumentReferenceContentProfile {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    valueCoding?: Coding

    @IsOptional()
    @IsString()
    valueUri?: string

    @IsOptional()
    @IsString()
    valueCanonical?: string

  }
  export class DocumentReferenceContentDto implements DocumentReferenceContent {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => AttachmentDto)
    attachment: Attachment

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DocumentReferenceContentProfileDto)
    profile?: DocumentReferenceContentProfile[]

  }
  export class DocumentReferenceDto implements DocumentReference {
    @IsNotEmpty()
    @IsIn(["DocumentReference"])
    resourceType: "DocumentReference"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DocumentReferenceAttesterDto)
    attester?: DocumentReferenceAttester[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    author?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    bodySite?: CodeableReference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DocumentReferenceContentDto)
    content: DocumentReferenceContent[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    context?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    custodian?: Reference

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsIn(["unknown", "entered-in-error", "cancelled", "partial", "registered", "preliminary", "final", "amended", "corrected", "appended", "deprecated"])
    docStatus: "unknown" | "entered-in-error" | "cancelled" | "partial" | "registered" | "preliminary" | "final" | "amended" | "corrected" | "appended" | "deprecated"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    event?: CodeableReference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    facilityType?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    modality?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    practiceSetting?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DocumentReferenceRelatesToDto)
    relatesTo?: DocumentReferenceRelatesTo[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    securityLabel?: CodeableConcept[]

    @IsNotEmpty()
    @IsIn(["current", "entered-in-error", "superseded"])
    status: "current" | "entered-in-error" | "superseded"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsOptional()
    @IsString()
    version?: string

  }
  export class DomainResourceDto implements DomainResource {
    @IsNotEmpty()
    @IsString()
    resourceType: string

    @IsOptional()
    @IsArray()
    contained?: FhirResource[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExtensionDto)
    extension?: Extension[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExtensionDto)
    modifierExtension?: Extension[]

    @IsOptional()
    @ValidateNested()
    @Type(() => NarrativeDto)
    text?: Narrative

  }
  export class EncounterParticipantDto implements EncounterParticipant {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    actor?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

  }
  export class EncounterReasonDto implements EncounterReason {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    use?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    value?: CodeableReference[]

  }
  export class EncounterDiagnosisDto implements EncounterDiagnosis {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    condition?: CodeableReference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    use?: CodeableConcept[]

  }
  export class EncounterAdmissionDto implements EncounterAdmission {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    admitSource?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    destination?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    dischargeDisposition?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    origin?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    preAdmissionIdentifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    reAdmission?: CodeableConcept

  }
  export class EncounterLocationDto implements EncounterLocation {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    form?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    location: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsNotEmpty()
    @IsIn(["active", "completed", "planned", "reserved"])
    status: "active" | "completed" | "planned" | "reserved"

  }
  export class EncounterDto implements Encounter {
    @IsNotEmpty()
    @IsIn(["Encounter"])
    resourceType: "Encounter"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    account?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    actualPeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => EncounterAdmissionDto)
    admission?: EncounterAdmission

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    appointment?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    careTeam?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    class?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EncounterDiagnosisDto)
    diagnosis?: EncounterDiagnosis[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    dietPreference?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    episodeOfCare?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    length?: Duration

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EncounterLocationDto)
    location?: EncounterLocation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EncounterParticipantDto)
    participant?: EncounterParticipant[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    partOf?: Reference

    @IsOptional()
    @IsString()
    plannedEndDate?: string

    @IsOptional()
    @IsString()
    plannedStartDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    priority?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EncounterReasonDto)
    reason?: EncounterReason[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    serviceProvider?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    serviceType?: CodeableReference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    specialArrangement?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    specialCourtesy?: CodeableConcept[]

    @IsNotEmpty()
    @IsIn(["unknown", "entered-in-error", "on-hold", "in-progress", "completed", "cancelled", "planned", "discharged", "discontinued"])
    status: "unknown" | "entered-in-error" | "on-hold" | "in-progress" | "completed" | "cancelled" | "planned" | "discharged" | "discontinued"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    subjectStatus?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => VirtualServiceDetailDto)
    virtualService?: VirtualServiceDetail[]

  }
  export class EncounterHistoryLocationDto implements EncounterHistoryLocation {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    form?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    location: Reference

  }
  export class EncounterHistoryDto implements EncounterHistory {
    @IsNotEmpty()
    @IsIn(["EncounterHistory"])
    resourceType: "EncounterHistory"

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    actualPeriod?: Period

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    class: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    length?: Duration

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EncounterHistoryLocationDto)
    location?: EncounterHistoryLocation[]

    @IsOptional()
    @IsString()
    plannedEndDate?: string

    @IsOptional()
    @IsString()
    plannedStartDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    serviceType?: CodeableReference[]

    @IsNotEmpty()
    @IsIn(["unknown", "entered-in-error", "on-hold", "in-progress", "completed", "cancelled", "planned", "discharged", "discontinued"])
    status: "unknown" | "entered-in-error" | "on-hold" | "in-progress" | "completed" | "cancelled" | "planned" | "discharged" | "discontinued"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    subjectStatus?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

  }
  export class EndpointPayloadDto implements EndpointPayload {
    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    mimeType?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

  }
  export class EndpointDto implements Endpoint {
    @IsNotEmpty()
    @IsIn(["Endpoint"])
    resourceType: "Endpoint"

    @IsNotEmpty()
    @IsString()
    address: string

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    connectionType: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactPointDto)
    contact?: ContactPoint[]

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    environmentType?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    header?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    managingOrganization?: Reference

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EndpointPayloadDto)
    payload?: EndpointPayload[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsNotEmpty()
    @IsIn(["error", "active", "entered-in-error", "suspended", "off"])
    status: "error" | "active" | "entered-in-error" | "suspended" | "off"

  }
  export class EnrollmentRequestDto implements EnrollmentRequest {
    @IsNotEmpty()
    @IsIn(["EnrollmentRequest"])
    resourceType: "EnrollmentRequest"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    candidate?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    coverage?: Reference

    @IsOptional()
    @IsString()
    created?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    insurer?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    provider?: Reference

    @IsNotEmpty()
    @IsIn(["draft", "active", "entered-in-error", "cancelled"])
    status: "draft" | "active" | "entered-in-error" | "cancelled"

  }
  export class EnrollmentResponseDto implements EnrollmentResponse {
    @IsNotEmpty()
    @IsIn(["EnrollmentResponse"])
    resourceType: "EnrollmentResponse"

    @IsOptional()
    @IsString()
    created?: string

    @IsOptional()
    @IsString()
    disposition?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    organization?: Reference

    @IsNotEmpty()
    @IsIn(["error", "queued", "complete", "partial"])
    outcome: "error" | "queued" | "complete" | "partial"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    request?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    requestProvider?: Reference

    @IsNotEmpty()
    @IsIn(["draft", "active", "entered-in-error", "cancelled"])
    status: "draft" | "active" | "entered-in-error" | "cancelled"

  }
  export class EpisodeOfCareStatusHistoryDto implements EpisodeOfCareStatusHistory {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => PeriodDto)
    period: Period

    @IsNotEmpty()
    @IsIn(["active", "entered-in-error", "cancelled", "waitlist", "planned", "onhold", "finished"])
    status: "active" | "entered-in-error" | "cancelled" | "waitlist" | "planned" | "onhold" | "finished"

  }
  export class EpisodeOfCareReasonDto implements EpisodeOfCareReason {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    use?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    value?: CodeableReference[]

  }
  export class EpisodeOfCareDiagnosisDto implements EpisodeOfCareDiagnosis {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    condition?: CodeableReference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    use?: CodeableConcept

  }
  export class EpisodeOfCareDto implements EpisodeOfCare {
    @IsNotEmpty()
    @IsIn(["EpisodeOfCare"])
    resourceType: "EpisodeOfCare"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    account?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    careManager?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    careTeam?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EpisodeOfCareDiagnosisDto)
    diagnosis?: EpisodeOfCareDiagnosis[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    managingOrganization?: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EpisodeOfCareReasonDto)
    reason?: EpisodeOfCareReason[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    referralRequest?: Reference[]

    @IsNotEmpty()
    @IsIn(["active", "entered-in-error", "cancelled", "waitlist", "planned", "onhold", "finished"])
    status: "active" | "entered-in-error" | "cancelled" | "waitlist" | "planned" | "onhold" | "finished"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EpisodeOfCareStatusHistoryDto)
    statusHistory?: EpisodeOfCareStatusHistory[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

  }
  export class EventDefinitionDto implements EventDefinition {
    @IsNotEmpty()
    @IsIn(["EventDefinition"])
    resourceType: "EventDefinition"

    @IsOptional()
    @IsString()
    approvalDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    author?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    copyrightLabel?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    editor?: ContactDetail[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    endorser?: ContactDetail[]

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    lastReviewDate?: string

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    relatedArtifact?: RelatedArtifact[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    reviewer?: ContactDetail[]

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    subjectCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subjectReference?: Reference

    @IsOptional()
    @IsString()
    subtitle?: string

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    topic?: CodeableConcept[]

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TriggerDefinitionDto)
    trigger: TriggerDefinition[]

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsString()
    usage?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @IsString()
    versionAlgorithmString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    versionAlgorithmCoding?: Coding

  }
  export class EvidenceVariableDefinitionDto implements EvidenceVariableDefinition {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    directnessMatch?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    intended?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    observed?: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    variableRole: CodeableConcept

  }
  export class EvidenceStatisticSampleSizeDto implements EvidenceStatisticSampleSize {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsNumber()
    knownDataCount?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsNumber()
    numberOfParticipants?: number

    @IsOptional()
    @IsNumber()
    numberOfStudies?: number

  }
  export class EvidenceStatisticAttributeEstimateDto implements EvidenceStatisticAttributeEstimate {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EvidenceStatisticAttributeEstimateDto)
    attributeEstimate?: EvidenceStatisticAttributeEstimate[]

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsNumber()
    level?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    range?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class EvidenceStatisticModelCharacteristicVariableDto implements EvidenceStatisticModelCharacteristicVariable {
    @IsNotEmpty()
    @IsIn(["continuous", "dichotomous", "ordinal", "polychotomous"])
    handling: "continuous" | "dichotomous" | "ordinal" | "polychotomous"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    valueCategory?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => QuantityDto)
    valueQuantity?: Quantity[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RangeDto)
    valueRange?: Range[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    variableDefinition: Reference

  }
  export class EvidenceStatisticModelCharacteristicDto implements EvidenceStatisticModelCharacteristic {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EvidenceStatisticAttributeEstimateDto)
    attributeEstimate?: EvidenceStatisticAttributeEstimate[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    value?: Quantity

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EvidenceStatisticModelCharacteristicVariableDto)
    variable?: EvidenceStatisticModelCharacteristicVariable[]

  }
  export class EvidenceStatisticDto implements EvidenceStatistic {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EvidenceStatisticAttributeEstimateDto)
    attributeEstimate?: EvidenceStatisticAttributeEstimate[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EvidenceStatisticModelCharacteristicDto)
    modelCharacteristic?: EvidenceStatisticModelCharacteristic[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsNumber()
    numberAffected?: number

    @IsOptional()
    @IsNumber()
    numberOfEvents?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => EvidenceStatisticSampleSizeDto)
    sampleSize?: EvidenceStatisticSampleSize

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    statisticType?: CodeableConcept

  }
  export class EvidenceCertaintyDto implements EvidenceCertainty {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    rater?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    rating?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EvidenceCertaintyDto)
    subcomponent?: EvidenceCertainty[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class EvidenceDto implements Evidence {
    @IsNotEmpty()
    @IsIn(["Evidence"])
    resourceType: "Evidence"

    @IsOptional()
    @IsString()
    approvalDate?: string

    @IsOptional()
    @IsString()
    assertion?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    author?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EvidenceCertaintyDto)
    certainty?: EvidenceCertainty[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    citeAsReference?: Reference

    @IsOptional()
    @IsString()
    citeAsMarkdown?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    copyrightLabel?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    editor?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    endorser?: ContactDetail[]

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsString()
    lastReviewDate?: string

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    relatedArtifact?: RelatedArtifact[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    reviewer?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EvidenceStatisticDto)
    statistic?: EvidenceStatistic[]

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    studyDesign?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    synthesisType?: CodeableConcept

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EvidenceVariableDefinitionDto)
    variableDefinition: EvidenceVariableDefinition[]

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @IsString()
    versionAlgorithmString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    versionAlgorithmCoding?: Coding

  }
  export class EvidenceReportSubjectCharacteristicDto implements EvidenceReportSubjectCharacteristic {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    exclude: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

  }
  export class EvidenceReportSubjectDto implements EvidenceReportSubject {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EvidenceReportSubjectCharacteristicDto)
    characteristic?: EvidenceReportSubjectCharacteristic[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

  }
  export class EvidenceReportRelatesToTargetDto implements EvidenceReportRelatesToTarget {
    @IsOptional()
    @IsString()
    display?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    resource?: Reference

    @IsOptional()
    @IsString()
    url?: string

  }
  export class EvidenceReportRelatesToDto implements EvidenceReportRelatesTo {
    @IsNotEmpty()
    @IsIn(["amends", "appends", "replaces", "transforms", "replacedWith", "amendedWith", "appendedWith", "transformedWith"])
    code: "amends" | "appends" | "replaces" | "transforms" | "replacedWith" | "amendedWith" | "appendedWith" | "transformedWith"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => EvidenceReportRelatesToTargetDto)
    target: EvidenceReportRelatesToTarget

  }
  export class EvidenceReportSectionDto implements EvidenceReportSection {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    author?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    emptyReason?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    entryClassifier?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => QuantityDto)
    entryQuantity?: Quantity[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    entryReference?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    focus?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    focusReference?: Reference

    @IsNotEmpty()
    @IsIn(["working", "snapshot", "changes"])
    mode: "working" | "snapshot" | "changes"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    orderedBy?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EvidenceReportSectionDto)
    section?: EvidenceReportSection[]

    @IsOptional()
    @ValidateNested()
    @Type(() => NarrativeDto)
    text?: Narrative

    @IsOptional()
    @IsString()
    title?: string

  }
  export class EvidenceReportDto implements EvidenceReport {
    @IsNotEmpty()
    @IsIn(["EvidenceReport"])
    resourceType: "EvidenceReport"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    author?: ContactDetail[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    citeAsReference?: Reference

    @IsOptional()
    @IsString()
    citeAsMarkdown?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    editor?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    endorser?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    relatedArtifact?: RelatedArtifact[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    relatedIdentifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EvidenceReportRelatesToDto)
    relatesTo?: EvidenceReportRelatesTo[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    reviewer?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EvidenceReportSectionDto)
    section?: EvidenceReportSection[]

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => EvidenceReportSubjectDto)
    subject: EvidenceReportSubject

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

  }
  export class EvidenceVariableCharacteristicDefinitionByTypeAndValueDto implements EvidenceVariableCharacteristicDefinitionByTypeAndValue {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    device?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    method?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    offset?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

    @IsOptional()
    @IsString()
    valueId?: string

  }
  export class EvidenceVariableCharacteristicDefinitionByCombinationDto implements EvidenceVariableCharacteristicDefinitionByCombination {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EvidenceVariableCharacteristicDto)
    characteristic: EvidenceVariableCharacteristic[]

    @IsNotEmpty()
    @IsIn(["all-of", "any-of", "at-least", "at-most", "statistical", "net-effect", "dataset"])
    code: "all-of" | "any-of" | "at-least" | "at-most" | "statistical" | "net-effect" | "dataset"

    @IsOptional()
    @IsNumber()
    threshold?: number

  }
  export class EvidenceVariableCharacteristicTimeFromEventDto implements EvidenceVariableCharacteristicTimeFromEvent {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    eventCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    eventReference?: Reference

    @IsOptional()
    @IsString()
    eventDateTime?: string

    @IsOptional()
    @IsString()
    eventId?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    range?: Range

  }
  export class EvidenceVariableCharacteristicDto implements EvidenceVariableCharacteristic {
    @IsOptional()
    @ValidateNested()
    @Type(() => EvidenceVariableCharacteristicDefinitionByCombinationDto)
    definitionByCombination?: EvidenceVariableCharacteristicDefinitionByCombination

    @IsOptional()
    @ValidateNested()
    @Type(() => EvidenceVariableCharacteristicDefinitionByTypeAndValueDto)
    definitionByTypeAndValue?: EvidenceVariableCharacteristicDefinitionByTypeAndValue

    @IsOptional()
    @IsString()
    definitionCanonical?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    definitionCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    definitionExpression?: Expression

    @IsOptional()
    @IsString()
    definitionId?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    definitionReference?: Reference

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    durationQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    durationRange?: Range

    @IsNotEmpty()
    @IsBoolean()
    exclude: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    instancesQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    instancesRange?: Range

    @IsOptional()
    @IsString()
    linkId?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EvidenceVariableCharacteristicTimeFromEventDto)
    timeFromEvent?: EvidenceVariableCharacteristicTimeFromEvent[]

  }
  export class EvidenceVariableCategoryDto implements EvidenceVariableCategory {
    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

  }
  export class EvidenceVariableDto implements EvidenceVariable {
    @IsNotEmpty()
    @IsIn(["EvidenceVariable"])
    resourceType: "EvidenceVariable"

    @IsNotEmpty()
    @IsBoolean()
    actual: boolean

    @IsOptional()
    @IsString()
    approvalDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    author?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EvidenceVariableCategoryDto)
    category?: EvidenceVariableCategory[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EvidenceVariableCharacteristicDto)
    characteristic?: EvidenceVariableCharacteristic[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    copyrightLabel?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    editor?: ContactDetail[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    endorser?: ContactDetail[]

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsNotEmpty()
    @IsIn(["continuous", "dichotomous", "ordinal", "polychotomous"])
    handling: "continuous" | "dichotomous" | "ordinal" | "polychotomous"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsString()
    lastReviewDate?: string

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    relatedArtifact?: RelatedArtifact[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    reviewer?: ContactDetail[]

    @IsOptional()
    @IsString()
    shortTitle?: string

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @IsString()
    versionAlgorithmString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    versionAlgorithmCoding?: Coding

  }
  export class ExampleScenarioActorDto implements ExampleScenarioActor {
    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsString()
    key: string

    @IsNotEmpty()
    @IsString()
    title: string

    @IsNotEmpty()
    @IsIn(["person", "system"])
    type: "person" | "system"

  }
  export class ExampleScenarioInstanceVersionDto implements ExampleScenarioInstanceVersion {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    content?: Reference

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsString()
    key: string

    @IsNotEmpty()
    @IsString()
    title: string

  }
  export class ExampleScenarioInstanceContainedInstanceDto implements ExampleScenarioInstanceContainedInstance {
    @IsNotEmpty()
    @IsString()
    instanceReference: string

    @IsOptional()
    @IsString()
    versionReference?: string

  }
  export class ExampleScenarioInstanceDto implements ExampleScenarioInstance {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExampleScenarioInstanceContainedInstanceDto)
    containedInstance?: ExampleScenarioInstanceContainedInstance[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    content?: Reference

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsString()
    key: string

    @IsOptional()
    @IsString()
    structureProfileCanonical?: string

    @IsOptional()
    @IsString()
    structureProfileUri?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodingDto)
    structureType: Coding

    @IsOptional()
    @IsString()
    structureVersion?: string

    @IsNotEmpty()
    @IsString()
    title: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExampleScenarioInstanceVersionDto)
    version?: ExampleScenarioInstanceVersion[]

  }
  export class ExampleScenarioProcessStepOperationDto implements ExampleScenarioProcessStepOperation {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    initiator?: string

    @IsNotEmpty()
    @IsBoolean()
    initiatorActive: boolean

    @IsOptional()
    @IsString()
    receiver?: string

    @IsNotEmpty()
    @IsBoolean()
    receiverActive: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => ExampleScenarioInstanceContainedInstanceDto)
    request?: ExampleScenarioInstanceContainedInstance

    @IsOptional()
    @ValidateNested()
    @Type(() => ExampleScenarioInstanceContainedInstanceDto)
    response?: ExampleScenarioInstanceContainedInstance

    @IsNotEmpty()
    @IsString()
    title: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    type?: Coding

  }
  export class ExampleScenarioProcessStepAlternativeDto implements ExampleScenarioProcessStepAlternative {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExampleScenarioProcessStepDto)
    step?: ExampleScenarioProcessStep[]

    @IsNotEmpty()
    @IsString()
    title: string

  }
  export class ExampleScenarioProcessStepDto implements ExampleScenarioProcessStep {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExampleScenarioProcessStepAlternativeDto)
    alternative?: ExampleScenarioProcessStepAlternative[]

    @IsOptional()
    @IsString()
    number?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ExampleScenarioProcessStepOperationDto)
    operation?: ExampleScenarioProcessStepOperation

    @IsNotEmpty()
    @IsBoolean()
    pause: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => ExampleScenarioProcessDto)
    process?: ExampleScenarioProcess

    @IsOptional()
    @IsString()
    workflow?: string

  }
  export class ExampleScenarioProcessDto implements ExampleScenarioProcess {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    postConditions?: string

    @IsOptional()
    @IsString()
    preConditions?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExampleScenarioProcessStepDto)
    step?: ExampleScenarioProcessStep[]

    @IsNotEmpty()
    @IsString()
    title: string

  }
  export class ExampleScenarioDto implements ExampleScenario {
    @IsNotEmpty()
    @IsIn(["ExampleScenario"])
    resourceType: "ExampleScenario"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExampleScenarioActorDto)
    actor?: ExampleScenarioActor[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    copyrightLabel?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExampleScenarioInstanceDto)
    instance?: ExampleScenarioInstance[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExampleScenarioProcessDto)
    process?: ExampleScenarioProcess[]

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @IsString()
    versionAlgorithmString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    versionAlgorithmCoding?: Coding

  }
  export class ExplanationOfBenefitRelatedDto implements ExplanationOfBenefitRelated {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    claim?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    reference?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    relationship?: CodeableConcept

  }
  export class ExplanationOfBenefitEventDto implements ExplanationOfBenefitEvent {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @IsString()
    whenDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    whenPeriod?: Period

  }
  export class ExplanationOfBenefitPayeeDto implements ExplanationOfBenefitPayee {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    party?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class ExplanationOfBenefitCareTeamDto implements ExplanationOfBenefitCareTeam {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    provider: Reference

    @IsNotEmpty()
    @IsBoolean()
    responsible: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    role?: CodeableConcept

    @IsNotEmpty()
    @IsNumber()
    sequence: number

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    specialty?: CodeableConcept

  }
  export class ExplanationOfBenefitSupportingInfoDto implements ExplanationOfBenefitSupportingInfo {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    reason?: Coding

    @IsNotEmpty()
    @IsNumber()
    sequence: number

    @IsOptional()
    @IsString()
    timingDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    timingPeriod?: Period

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    valueIdentifier?: Identifier

  }
  export class ExplanationOfBenefitDiagnosisDto implements ExplanationOfBenefitDiagnosis {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    diagnosisCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    diagnosisReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    onAdmission?: CodeableConcept

    @IsNotEmpty()
    @IsNumber()
    sequence: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

  }
  export class ExplanationOfBenefitProcedureDto implements ExplanationOfBenefitProcedure {
    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    procedureCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    procedureReference?: Reference

    @IsNotEmpty()
    @IsNumber()
    sequence: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    udi?: Reference[]

  }
  export class ExplanationOfBenefitInsuranceDto implements ExplanationOfBenefitInsurance {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    coverage: Reference

    @IsNotEmpty()
    @IsBoolean()
    focal: boolean

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    preAuthRef?: string[]

  }
  export class ExplanationOfBenefitAccidentDto implements ExplanationOfBenefitAccident {
    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    locationAddress?: Address

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    locationReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class ExplanationOfBenefitItemBodySiteDto implements ExplanationOfBenefitItemBodySite {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    site: CodeableReference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    subSite?: CodeableConcept[]

  }
  export class ExplanationOfBenefitItemReviewOutcomeDto implements ExplanationOfBenefitItemReviewOutcome {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    decision?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    preAuthPeriod?: Period

    @IsOptional()
    @IsString()
    preAuthRef?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    reason?: CodeableConcept[]

  }
  export class ExplanationOfBenefitItemAdjudicationDto implements ExplanationOfBenefitItemAdjudication {
    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    amount?: Money

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    reason?: CodeableConcept

  }
  export class ExplanationOfBenefitItemDetailSubDetailDto implements ExplanationOfBenefitItemDetailSubDetail {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitItemAdjudicationDto)
    adjudication?: ExplanationOfBenefitItemAdjudication[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept

    @IsOptional()
    @IsNumber()
    factor?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    modifier?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    net?: Money

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    noteNumber?: number[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    patientPaid?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrService?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrServiceEnd?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    programCode?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    revenue?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ExplanationOfBenefitItemReviewOutcomeDto)
    reviewOutcome?: ExplanationOfBenefitItemReviewOutcome

    @IsNotEmpty()
    @IsNumber()
    sequence: number

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    tax?: Money

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    traceNumber?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    udi?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    unitPrice?: Money

  }
  export class ExplanationOfBenefitItemDetailDto implements ExplanationOfBenefitItemDetail {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitItemAdjudicationDto)
    adjudication?: ExplanationOfBenefitItemAdjudication[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept

    @IsOptional()
    @IsNumber()
    factor?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    modifier?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    net?: Money

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    noteNumber?: number[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    patientPaid?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrService?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrServiceEnd?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    programCode?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    revenue?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ExplanationOfBenefitItemReviewOutcomeDto)
    reviewOutcome?: ExplanationOfBenefitItemReviewOutcome

    @IsNotEmpty()
    @IsNumber()
    sequence: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitItemDetailSubDetailDto)
    subDetail?: ExplanationOfBenefitItemDetailSubDetail[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    tax?: Money

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    traceNumber?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    udi?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    unitPrice?: Money

  }
  export class ExplanationOfBenefitItemDto implements ExplanationOfBenefitItem {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitItemAdjudicationDto)
    adjudication?: ExplanationOfBenefitItemAdjudication[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitItemBodySiteDto)
    bodySite?: ExplanationOfBenefitItemBodySite[]

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    careTeamSequence?: number[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitItemDetailDto)
    detail?: ExplanationOfBenefitItemDetail[]

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    diagnosisSequence?: number[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    encounter?: Reference[]

    @IsOptional()
    @IsNumber()
    factor?: number

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    informationSequence?: number[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    locationCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    locationAddress?: Address

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    locationReference?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    modifier?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    net?: Money

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    noteNumber?: number[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    patientPaid?: Money

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    procedureSequence?: number[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrService?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrServiceEnd?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    programCode?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    request?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    revenue?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ExplanationOfBenefitItemReviewOutcomeDto)
    reviewOutcome?: ExplanationOfBenefitItemReviewOutcome

    @IsNotEmpty()
    @IsNumber()
    sequence: number

    @IsOptional()
    @IsString()
    servicedDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    servicedPeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    tax?: Money

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    traceNumber?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    udi?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    unitPrice?: Money

  }
  export class ExplanationOfBenefitAddItemBodySiteDto implements ExplanationOfBenefitAddItemBodySite {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    site: CodeableReference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    subSite?: CodeableConcept[]

  }
  export class ExplanationOfBenefitAddItemDetailSubDetailDto implements ExplanationOfBenefitAddItemDetailSubDetail {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitItemAdjudicationDto)
    adjudication?: ExplanationOfBenefitItemAdjudication[]

    @IsOptional()
    @IsNumber()
    factor?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    modifier?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    net?: Money

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    noteNumber?: number[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    patientPaid?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrService?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrServiceEnd?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    revenue?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ExplanationOfBenefitItemReviewOutcomeDto)
    reviewOutcome?: ExplanationOfBenefitItemReviewOutcome

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    tax?: Money

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    traceNumber?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    unitPrice?: Money

  }
  export class ExplanationOfBenefitAddItemDetailDto implements ExplanationOfBenefitAddItemDetail {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitItemAdjudicationDto)
    adjudication?: ExplanationOfBenefitItemAdjudication[]

    @IsOptional()
    @IsNumber()
    factor?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    modifier?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    net?: Money

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    noteNumber?: number[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    patientPaid?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrService?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrServiceEnd?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    revenue?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ExplanationOfBenefitItemReviewOutcomeDto)
    reviewOutcome?: ExplanationOfBenefitItemReviewOutcome

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitAddItemDetailSubDetailDto)
    subDetail?: ExplanationOfBenefitAddItemDetailSubDetail[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    tax?: Money

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    traceNumber?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    unitPrice?: Money

  }
  export class ExplanationOfBenefitAddItemDto implements ExplanationOfBenefitAddItem {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitItemAdjudicationDto)
    adjudication?: ExplanationOfBenefitItemAdjudication[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitAddItemBodySiteDto)
    bodySite?: ExplanationOfBenefitAddItemBodySite[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitAddItemDetailDto)
    detail?: ExplanationOfBenefitAddItemDetail[]

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    detailSequence?: number[]

    @IsOptional()
    @IsNumber()
    factor?: number

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    itemSequence?: number[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    locationCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    locationAddress?: Address

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    locationReference?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    modifier?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    net?: Money

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    noteNumber?: number[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    patientPaid?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrService?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrServiceEnd?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    programCode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    provider?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    request?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    revenue?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ExplanationOfBenefitItemReviewOutcomeDto)
    reviewOutcome?: ExplanationOfBenefitItemReviewOutcome

    @IsOptional()
    @IsString()
    servicedDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    servicedPeriod?: Period

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    subDetailSequence?: number[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    tax?: Money

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    traceNumber?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    unitPrice?: Money

  }
  export class ExplanationOfBenefitTotalDto implements ExplanationOfBenefitTotal {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => MoneyDto)
    amount: Money

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category: CodeableConcept

  }
  export class ExplanationOfBenefitPaymentDto implements ExplanationOfBenefitPayment {
    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    adjustment?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    adjustmentReason?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    amount?: Money

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class ExplanationOfBenefitProcessNoteDto implements ExplanationOfBenefitProcessNote {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    language?: CodeableConcept

    @IsOptional()
    @IsNumber()
    number?: number

    @IsOptional()
    @IsString()
    text?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class ExplanationOfBenefitBenefitBalanceFinancialDto implements ExplanationOfBenefitBenefitBalanceFinancial {
    @IsOptional()
    @IsNumber()
    allowedUnsignedInt?: number

    @IsOptional()
    @IsString()
    allowedString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    allowedMoney?: Money

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @IsNumber()
    usedUnsignedInt?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    usedMoney?: Money

  }
  export class ExplanationOfBenefitBenefitBalanceDto implements ExplanationOfBenefitBenefitBalance {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category: CodeableConcept

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsBoolean()
    excluded: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitBenefitBalanceFinancialDto)
    financial?: ExplanationOfBenefitBenefitBalanceFinancial[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    network?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    term?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    unit?: CodeableConcept

  }
  export class ExplanationOfBenefitDto implements ExplanationOfBenefit {
    @IsNotEmpty()
    @IsIn(["ExplanationOfBenefit"])
    resourceType: "ExplanationOfBenefit"

    @IsOptional()
    @ValidateNested()
    @Type(() => ExplanationOfBenefitAccidentDto)
    accident?: ExplanationOfBenefitAccident

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitAddItemDto)
    addItem?: ExplanationOfBenefitAddItem[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitItemAdjudicationDto)
    adjudication?: ExplanationOfBenefitItemAdjudication[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitBenefitBalanceDto)
    benefitBalance?: ExplanationOfBenefitBenefitBalance[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    benefitPeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    billablePeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitCareTeamDto)
    careTeam?: ExplanationOfBenefitCareTeam[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    claim?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    claimResponse?: Reference

    @IsNotEmpty()
    @IsString()
    created: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    decision?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitDiagnosisDto)
    diagnosis?: ExplanationOfBenefitDiagnosis[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    diagnosisRelatedGroup?: CodeableConcept

    @IsOptional()
    @IsString()
    disposition?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    encounter?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    enterer?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitEventDto)
    event?: ExplanationOfBenefitEvent[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    facility?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    form?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    formCode?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    fundsReserve?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    fundsReserveRequested?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitInsuranceDto)
    insurance?: ExplanationOfBenefitInsurance[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    insurer?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitItemDto)
    item?: ExplanationOfBenefitItem[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    originalPrescription?: Reference

    @IsNotEmpty()
    @IsIn(["error", "queued", "complete", "partial"])
    outcome: "error" | "queued" | "complete" | "partial"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    patientPaid?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => ExplanationOfBenefitPayeeDto)
    payee?: ExplanationOfBenefitPayee

    @IsOptional()
    @ValidateNested()
    @Type(() => ExplanationOfBenefitPaymentDto)
    payment?: ExplanationOfBenefitPayment

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    preAuthRef?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PeriodDto)
    preAuthRefPeriod?: Period[]

    @IsOptional()
    @IsNumber()
    precedence?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    prescription?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    priority?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitProcedureDto)
    procedure?: ExplanationOfBenefitProcedure[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitProcessNoteDto)
    processNote?: ExplanationOfBenefitProcessNote[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    provider?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    referral?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitRelatedDto)
    related?: ExplanationOfBenefitRelated[]

    @IsNotEmpty()
    @IsIn(["draft", "active", "entered-in-error", "cancelled"])
    status: "draft" | "active" | "entered-in-error" | "cancelled"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    subType?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitSupportingInfoDto)
    supportingInfo?: ExplanationOfBenefitSupportingInfo[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitTotalDto)
    total?: ExplanationOfBenefitTotal[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    traceNumber?: Identifier[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsNotEmpty()
    @IsIn(["claim", "preauthorization", "predetermination"])
    use: "claim" | "preauthorization" | "predetermination"

  }
  export class FamilyMemberHistoryParticipantDto implements FamilyMemberHistoryParticipant {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    actor: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    function?: CodeableConcept

  }
  export class FamilyMemberHistoryConditionDto implements FamilyMemberHistoryCondition {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    contributedToDeath: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    onsetAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    onsetRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    onsetPeriod?: Period

    @IsOptional()
    @IsString()
    onsetString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    outcome?: CodeableConcept

  }
  export class FamilyMemberHistoryProcedureDto implements FamilyMemberHistoryProcedure {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    contributedToDeath: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    outcome?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    performedAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    performedRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    performedPeriod?: Period

    @IsOptional()
    @IsString()
    performedString?: string

    @IsOptional()
    @IsString()
    performedDateTime?: string

  }
  export class FamilyMemberHistoryDto implements FamilyMemberHistory {
    @IsNotEmpty()
    @IsIn(["FamilyMemberHistory"])
    resourceType: "FamilyMemberHistory"

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    ageAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    ageRange?: Range

    @IsOptional()
    @IsString()
    ageString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    bornPeriod?: Period

    @IsOptional()
    @IsString()
    bornDate?: string

    @IsOptional()
    @IsString()
    bornString?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => FamilyMemberHistoryConditionDto)
    condition?: FamilyMemberHistoryCondition[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    dataAbsentReason?: CodeableConcept

    @IsOptional()
    @IsString()
    date?: string

    @IsNotEmpty()
    @IsBoolean()
    deceasedBoolean: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    deceasedAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    deceasedRange?: Range

    @IsOptional()
    @IsString()
    deceasedDate?: string

    @IsOptional()
    @IsString()
    deceasedString?: string

    @IsNotEmpty()
    @IsBoolean()
    estimatedAge: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesCanonical?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesUri?: string[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => FamilyMemberHistoryParticipantDto)
    participant?: FamilyMemberHistoryParticipant[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => FamilyMemberHistoryProcedureDto)
    procedure?: FamilyMemberHistoryProcedure[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    reason?: CodeableReference[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    relationship: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    sex?: CodeableConcept

    @IsNotEmpty()
    @IsIn(["entered-in-error", "completed", "partial", "health-unknown"])
    status: "entered-in-error" | "completed" | "partial" | "health-unknown"

  }
  export class FlagDto implements Flag {
    @IsNotEmpty()
    @IsIn(["Flag"])
    resourceType: "Flag"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    author?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsNotEmpty()
    @IsIn(["active", "inactive", "entered-in-error"])
    status: "active" | "inactive" | "entered-in-error"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

  }
  export class FormularyItemDto implements FormularyItem {
    @IsNotEmpty()
    @IsIn(["FormularyItem"])
    resourceType: "FormularyItem"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsNotEmpty()
    @IsIn(["active", "inactive", "entered-in-error"])
    status: "active" | "inactive" | "entered-in-error"

  }
  export class GenomicStudyAnalysisInputDto implements GenomicStudyAnalysisInput {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    file?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    generatedByIdentifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    generatedByReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class GenomicStudyAnalysisOutputDto implements GenomicStudyAnalysisOutput {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    file?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class GenomicStudyAnalysisPerformerDto implements GenomicStudyAnalysisPerformer {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    actor?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    role?: CodeableConcept

  }
  export class GenomicStudyAnalysisDeviceDto implements GenomicStudyAnalysisDevice {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    device?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    function?: CodeableConcept

  }
  export class GenomicStudyAnalysisDto implements GenomicStudyAnalysis {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    changeType?: CodeableConcept[]

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => GenomicStudyAnalysisDeviceDto)
    device?: GenomicStudyAnalysisDevice[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    focus?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    genomeBuild?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => GenomicStudyAnalysisInputDto)
    input?: GenomicStudyAnalysisInput[]

    @IsOptional()
    @IsString()
    instantiatesCanonical?: string

    @IsOptional()
    @IsString()
    instantiatesUri?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    methodType?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => GenomicStudyAnalysisOutputDto)
    output?: GenomicStudyAnalysisOutput[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => GenomicStudyAnalysisPerformerDto)
    performer?: GenomicStudyAnalysisPerformer[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    protocolPerformed?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    regionsCalled?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    regionsStudied?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    specimen?: Reference[]

    @IsOptional()
    @IsString()
    title?: string

  }
  export class GenomicStudyDto implements GenomicStudy {
    @IsNotEmpty()
    @IsIn(["GenomicStudy"])
    resourceType: "GenomicStudy"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => GenomicStudyAnalysisDto)
    analysis?: GenomicStudyAnalysis[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsString()
    instantiatesCanonical?: string

    @IsOptional()
    @IsString()
    instantiatesUri?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    interpreter?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    reason?: CodeableReference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    referrer?: Reference

    @IsOptional()
    @IsString()
    startDate?: string

    @IsNotEmpty()
    @IsIn(["unknown", "entered-in-error", "cancelled", "registered", "available"])
    status: "unknown" | "entered-in-error" | "cancelled" | "registered" | "available"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

  }
  export class GoalTargetDto implements GoalTarget {
    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    detailQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    detailRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    detailCodeableConcept?: CodeableConcept

    @IsOptional()
    @IsString()
    detailString?: string

    @IsNotEmpty()
    @IsBoolean()
    detailBoolean: boolean

    @IsOptional()
    @IsNumber()
    detailInteger?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    detailRatio?: Ratio

    @IsOptional()
    @IsString()
    dueDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    dueDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    measure?: CodeableConcept

  }
  export class GoalDto implements Goal {
    @IsNotEmpty()
    @IsIn(["Goal"])
    resourceType: "Goal"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    achievementStatus?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    addresses?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsNotEmpty()
    @IsBoolean()
    continuous: boolean

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    description: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsNotEmpty()
    @IsIn(["active", "entered-in-error", "on-hold", "completed", "accepted", "proposed", "cancelled", "planned", "rejected"])
    lifecycleStatus: "active" | "entered-in-error" | "on-hold" | "completed" | "accepted" | "proposed" | "cancelled" | "planned" | "rejected"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    outcome?: CodeableReference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    priority?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    source?: Reference

    @IsOptional()
    @IsString()
    startDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    startCodeableConcept?: CodeableConcept

    @IsOptional()
    @IsString()
    statusDate?: string

    @IsOptional()
    @IsString()
    statusReason?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => GoalTargetDto)
    target?: GoalTarget[]

  }
  export class GraphDefinitionNodeDto implements GraphDefinitionNode {
    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsString()
    nodeId: string

    @IsOptional()
    @IsString()
    profile?: string

    @IsNotEmpty()
    @IsString()
    type: string

  }
  export class GraphDefinitionLinkCompartmentDto implements GraphDefinitionLinkCompartment {
    @IsNotEmpty()
    @IsIn(["Patient", "Encounter", "RelatedPerson", "Practitioner", "Device", "EpisodeOfCare"])
    code: "Patient" | "Encounter" | "RelatedPerson" | "Practitioner" | "Device" | "EpisodeOfCare"

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    expression?: string

    @IsNotEmpty()
    @IsIn(["identical", "matching", "different", "custom"])
    rule: "identical" | "matching" | "different" | "custom"

    @IsNotEmpty()
    @IsIn(["where", "requires"])
    use: "where" | "requires"

  }
  export class GraphDefinitionLinkDto implements GraphDefinitionLink {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => GraphDefinitionLinkCompartmentDto)
    compartment?: GraphDefinitionLinkCompartment[]

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    max?: string

    @IsOptional()
    @IsNumber()
    min?: number

    @IsOptional()
    @IsString()
    params?: string

    @IsOptional()
    @IsString()
    path?: string

    @IsOptional()
    @IsString()
    sliceName?: string

    @IsNotEmpty()
    @IsString()
    sourceId: string

    @IsNotEmpty()
    @IsString()
    targetId: string

  }
  export class GraphDefinitionDto implements GraphDefinition {
    @IsNotEmpty()
    @IsIn(["GraphDefinition"])
    resourceType: "GraphDefinition"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    copyrightLabel?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => GraphDefinitionLinkDto)
    link?: GraphDefinitionLink[]

    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => GraphDefinitionNodeDto)
    node?: GraphDefinitionNode[]

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @IsString()
    start?: string

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @IsString()
    versionAlgorithmString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    versionAlgorithmCoding?: Coding

  }
  export class GroupCharacteristicDto implements GroupCharacteristic {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    exclude: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

  }
  export class GroupMemberDto implements GroupMember {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    entity: Reference

    @IsNotEmpty()
    @IsBoolean()
    inactive: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

  }
  export class GroupDto implements Group {
    @IsNotEmpty()
    @IsIn(["Group"])
    resourceType: "Group"

    @IsNotEmpty()
    @IsBoolean()
    active: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => GroupCharacteristicDto)
    characteristic?: GroupCharacteristic[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    managingEntity?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => GroupMemberDto)
    member?: GroupMember[]

    @IsNotEmpty()
    @IsIn(["definitional", "enumerated"])
    membership: "definitional" | "enumerated"

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsNumber()
    quantity?: number

    @IsNotEmpty()
    @IsIn(["careteam", "device", "healthcareservice", "location", "organization", "practitioner", "relatedperson", "person", "animal", "specimen"])
    type: "careteam" | "device" | "healthcareservice" | "location" | "organization" | "practitioner" | "relatedperson" | "person" | "animal" | "specimen"

  }
  export class GuidanceResponseDto implements GuidanceResponse {
    @IsNotEmpty()
    @IsIn(["GuidanceResponse"])
    resourceType: "GuidanceResponse"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DataRequirementDto)
    dataRequirement?: DataRequirement[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    evaluationMessage?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsString()
    moduleUri?: string

    @IsOptional()
    @IsString()
    moduleCanonical?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    moduleCodeableConcept?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    occurrenceDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    outputParameters?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    performer?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    reason?: CodeableReference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    requestIdentifier?: Identifier

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    result?: Reference[]

    @IsNotEmpty()
    @IsIn(["entered-in-error", "in-progress", "success", "data-requested", "data-required", "failure"])
    status: "entered-in-error" | "in-progress" | "success" | "data-requested" | "data-required" | "failure"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

  }
  export class HealthcareServiceEligibilityDto implements HealthcareServiceEligibility {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsString()
    comment?: string

  }
  export class HealthcareServiceDto implements HealthcareService {
    @IsNotEmpty()
    @IsIn(["HealthcareService"])
    resourceType: "HealthcareService"

    @IsNotEmpty()
    @IsBoolean()
    active: boolean

    @IsNotEmpty()
    @IsBoolean()
    appointmentRequired: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AvailabilityDto)
    availability?: Availability[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    characteristic?: CodeableConcept[]

    @IsOptional()
    @IsString()
    comment?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    communication?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExtendedContactDetailDto)
    contact?: ExtendedContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    coverageArea?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => HealthcareServiceEligibilityDto)
    eligibility?: HealthcareServiceEligibility[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    endpoint?: Reference[]

    @IsOptional()
    @IsString()
    extraDetails?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    location?: Reference[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    offeredIn?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    photo?: Attachment

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    program?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    providedBy?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    referralMethod?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    serviceProvisionCode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    specialty?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

  }
  export class ImagingSelectionPerformerDto implements ImagingSelectionPerformer {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    actor?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    function?: CodeableConcept

  }
  export class ImagingSelectionInstanceImageRegion2DDto implements ImagingSelectionInstanceImageRegion2D {
    @IsNotEmpty()
    @IsArray()
    @IsNumber({}, { each: true })
    coordinate: number[]

    @IsNotEmpty()
    @IsIn(["point", "polyline", "interpolated", "circle", "ellipse"])
    regionType: "point" | "polyline" | "interpolated" | "circle" | "ellipse"

  }
  export class ImagingSelectionInstanceImageRegion3DDto implements ImagingSelectionInstanceImageRegion3D {
    @IsNotEmpty()
    @IsArray()
    @IsNumber({}, { each: true })
    coordinate: number[]

    @IsNotEmpty()
    @IsIn(["point", "polyline", "ellipse", "multipoint", "polygon", "ellipsoid"])
    regionType: "point" | "polyline" | "ellipse" | "multipoint" | "polygon" | "ellipsoid"

  }
  export class ImagingSelectionInstanceDto implements ImagingSelectionInstance {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImagingSelectionInstanceImageRegion2DDto)
    imageRegion2D?: ImagingSelectionInstanceImageRegion2D[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImagingSelectionInstanceImageRegion3DDto)
    imageRegion3D?: ImagingSelectionInstanceImageRegion3D[]

    @IsOptional()
    @IsNumber()
    number?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    sopClass?: Coding

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    subset?: string[]

    @IsNotEmpty()
    @IsString()
    uid: string

  }
  export class ImagingSelectionDto implements ImagingSelection {
    @IsNotEmpty()
    @IsIn(["ImagingSelection"])
    resourceType: "ImagingSelection"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    bodySite?: CodeableReference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    derivedFrom?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    endpoint?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    focus?: Reference[]

    @IsOptional()
    @IsString()
    frameOfReferenceUid?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImagingSelectionInstanceDto)
    instance?: ImagingSelectionInstance[]

    @IsOptional()
    @IsString()
    issued?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImagingSelectionPerformerDto)
    performer?: ImagingSelectionPerformer[]

    @IsOptional()
    @IsNumber()
    seriesNumber?: number

    @IsOptional()
    @IsString()
    seriesUid?: string

    @IsNotEmpty()
    @IsIn(["unknown", "entered-in-error", "available"])
    status: "unknown" | "entered-in-error" | "available"

    @IsOptional()
    @IsString()
    studyUid?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

  }
  export class ImagingStudySeriesPerformerDto implements ImagingStudySeriesPerformer {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    actor: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    function?: CodeableConcept

  }
  export class ImagingStudySeriesInstanceDto implements ImagingStudySeriesInstance {
    @IsOptional()
    @IsNumber()
    number?: number

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodingDto)
    sopClass: Coding

    @IsOptional()
    @IsString()
    title?: string

    @IsNotEmpty()
    @IsString()
    uid: string

  }
  export class ImagingStudySeriesDto implements ImagingStudySeries {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    bodySite?: CodeableReference

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    endpoint?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImagingStudySeriesInstanceDto)
    instance?: ImagingStudySeriesInstance[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    laterality?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    modality: CodeableConcept

    @IsOptional()
    @IsNumber()
    number?: number

    @IsOptional()
    @IsNumber()
    numberOfInstances?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImagingStudySeriesPerformerDto)
    performer?: ImagingStudySeriesPerformer[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    specimen?: Reference[]

    @IsOptional()
    @IsString()
    started?: string

    @IsNotEmpty()
    @IsString()
    uid: string

  }
  export class ImagingStudyDto implements ImagingStudy {
    @IsNotEmpty()
    @IsIn(["ImagingStudy"])
    resourceType: "ImagingStudy"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    endpoint?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    location?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    modality?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsNumber()
    numberOfInstances?: number

    @IsOptional()
    @IsNumber()
    numberOfSeries?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    partOf?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    procedure?: CodeableReference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    reason?: CodeableReference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    referrer?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImagingStudySeriesDto)
    series?: ImagingStudySeries[]

    @IsOptional()
    @IsString()
    started?: string

    @IsNotEmpty()
    @IsIn(["unknown", "entered-in-error", "cancelled", "registered", "available"])
    status: "unknown" | "entered-in-error" | "cancelled" | "registered" | "available"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

  }
  export class ImmunizationPerformerDto implements ImmunizationPerformer {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    actor: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    function?: CodeableConcept

  }
  export class ImmunizationProgramEligibilityDto implements ImmunizationProgramEligibility {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    program: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    programStatus: CodeableConcept

  }
  export class ImmunizationReactionDto implements ImmunizationReaction {
    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    manifestation?: CodeableReference

    @IsNotEmpty()
    @IsBoolean()
    reported: boolean

  }
  export class ImmunizationProtocolAppliedDto implements ImmunizationProtocolApplied {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    authority?: Reference

    @IsNotEmpty()
    @IsString()
    doseNumber: string

    @IsOptional()
    @IsString()
    series?: string

    @IsOptional()
    @IsString()
    seriesDoses?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    targetDisease?: CodeableConcept[]

  }
  export class ImmunizationDto implements Immunization {
    @IsNotEmpty()
    @IsIn(["Immunization"])
    resourceType: "Immunization"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    administeredProduct?: CodeableReference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    doseQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsString()
    expirationDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    fundingSource?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    informationSource?: CodeableReference

    @IsNotEmpty()
    @IsBoolean()
    isSubpotent: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    location?: Reference

    @IsOptional()
    @IsString()
    lotNumber?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    manufacturer?: CodeableReference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    occurrenceDateTime?: string

    @IsOptional()
    @IsString()
    occurrenceString?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImmunizationPerformerDto)
    performer?: ImmunizationPerformer[]

    @IsNotEmpty()
    @IsBoolean()
    primarySource: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImmunizationProgramEligibilityDto)
    programEligibility?: ImmunizationProgramEligibility[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImmunizationProtocolAppliedDto)
    protocolApplied?: ImmunizationProtocolApplied[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImmunizationReactionDto)
    reaction?: ImmunizationReaction[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    reason?: CodeableReference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    route?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    site?: CodeableConcept

    @IsNotEmpty()
    @IsIn(["entered-in-error", "completed", "not-done"])
    status: "entered-in-error" | "completed" | "not-done"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    statusReason?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    subpotentReason?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    supportingInformation?: Reference[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    vaccineCode: CodeableConcept

  }
  export class ImmunizationEvaluationDto implements ImmunizationEvaluation {
    @IsNotEmpty()
    @IsIn(["ImmunizationEvaluation"])
    resourceType: "ImmunizationEvaluation"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    authority?: Reference

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    doseNumber?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    doseStatus: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    doseStatusReason?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    immunizationEvent: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient: Reference

    @IsOptional()
    @IsString()
    series?: string

    @IsOptional()
    @IsString()
    seriesDoses?: string

    @IsNotEmpty()
    @IsIn(["entered-in-error", "completed"])
    status: "entered-in-error" | "completed"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    targetDisease: CodeableConcept

  }
  export class ImmunizationRecommendationRecommendationDateCriterionDto implements ImmunizationRecommendationRecommendationDateCriterion {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsNotEmpty()
    @IsString()
    value: string

  }
  export class ImmunizationRecommendationRecommendationDto implements ImmunizationRecommendationRecommendation {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    contraindicatedVaccineCode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImmunizationRecommendationRecommendationDateCriterionDto)
    dateCriterion?: ImmunizationRecommendationRecommendationDateCriterion[]

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    doseNumber?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    forecastReason?: CodeableConcept[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    forecastStatus: CodeableConcept

    @IsOptional()
    @IsString()
    series?: string

    @IsOptional()
    @IsString()
    seriesDoses?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    supportingImmunization?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    supportingPatientInformation?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    targetDisease?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    vaccineCode?: CodeableConcept[]

  }
  export class ImmunizationRecommendationDto implements ImmunizationRecommendation {
    @IsNotEmpty()
    @IsIn(["ImmunizationRecommendation"])
    resourceType: "ImmunizationRecommendation"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    authority?: Reference

    @IsNotEmpty()
    @IsString()
    date: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient: Reference

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImmunizationRecommendationRecommendationDto)
    recommendation: ImmunizationRecommendationRecommendation[]

  }
  export class ImplementationGuideDependsOnDto implements ImplementationGuideDependsOn {
    @IsOptional()
    @IsString()
    packageId?: string

    @IsOptional()
    @IsString()
    reason?: string

    @IsNotEmpty()
    @IsString()
    uri: string

    @IsOptional()
    @IsString()
    version?: string

  }
  export class ImplementationGuideGlobalDto implements ImplementationGuideGlobal {
    @IsNotEmpty()
    @IsString()
    profile: string

    @IsNotEmpty()
    @IsString()
    type: string

  }
  export class ImplementationGuideDefinitionGroupingDto implements ImplementationGuideDefinitionGrouping {
    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsString()
    name: string

  }
  export class ImplementationGuideDefinitionResourceDto implements ImplementationGuideDefinitionResource {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    fhirVersion?: string[]

    @IsOptional()
    @IsString()
    groupingId?: string

    @IsNotEmpty()
    @IsBoolean()
    isExample: boolean

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    profile?: string[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    reference: Reference

  }
  export class ImplementationGuideDefinitionPageDto implements ImplementationGuideDefinitionPage {
    @IsNotEmpty()
    @IsIn(["generated", "html", "markdown", "xml"])
    generation: "generated" | "html" | "markdown" | "xml"

    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImplementationGuideDefinitionPageDto)
    page?: ImplementationGuideDefinitionPage[]

    @IsOptional()
    @IsString()
    sourceUrl?: string

    @IsOptional()
    @IsString()
    sourceString?: string

    @IsOptional()
    @IsString()
    sourceMarkdown?: string

    @IsNotEmpty()
    @IsString()
    title: string

  }
  export class ImplementationGuideDefinitionParameterDto implements ImplementationGuideDefinitionParameter {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodingDto)
    code: Coding

    @IsNotEmpty()
    @IsString()
    value: string

  }
  export class ImplementationGuideDefinitionTemplateDto implements ImplementationGuideDefinitionTemplate {
    @IsNotEmpty()
    @IsString()
    code: string

    @IsOptional()
    @IsString()
    scope?: string

    @IsNotEmpty()
    @IsString()
    source: string

  }
  export class ImplementationGuideDefinitionDto implements ImplementationGuideDefinition {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImplementationGuideDefinitionGroupingDto)
    grouping?: ImplementationGuideDefinitionGrouping[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ImplementationGuideDefinitionPageDto)
    page?: ImplementationGuideDefinitionPage

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImplementationGuideDefinitionParameterDto)
    parameter?: ImplementationGuideDefinitionParameter[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImplementationGuideDefinitionResourceDto)
    resource?: ImplementationGuideDefinitionResource[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImplementationGuideDefinitionTemplateDto)
    template?: ImplementationGuideDefinitionTemplate[]

  }
  export class ImplementationGuideManifestResourceDto implements ImplementationGuideManifestResource {
    @IsNotEmpty()
    @IsBoolean()
    isExample: boolean

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    profile?: string[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    reference: Reference

    @IsOptional()
    @IsString()
    relativePath?: string

  }
  export class ImplementationGuideManifestPageDto implements ImplementationGuideManifestPage {
    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    anchor?: string[]

    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @IsString()
    title?: string

  }
  export class ImplementationGuideManifestDto implements ImplementationGuideManifest {
    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    image?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    other?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImplementationGuideManifestPageDto)
    page?: ImplementationGuideManifestPage[]

    @IsOptional()
    @IsString()
    rendering?: string

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImplementationGuideManifestResourceDto)
    resource: ImplementationGuideManifestResource[]

  }
  export class ImplementationGuideDto implements ImplementationGuide {
    @IsNotEmpty()
    @IsIn(["ImplementationGuide"])
    resourceType: "ImplementationGuide"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    copyrightLabel?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ImplementationGuideDefinitionDto)
    definition?: ImplementationGuideDefinition

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImplementationGuideDependsOnDto)
    dependsOn?: ImplementationGuideDependsOn[]

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsNotEmpty()
    @IsArray()
    @IsString({ each: true })
    fhirVersion: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImplementationGuideGlobalDto)
    global?: ImplementationGuideGlobal[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    license?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ImplementationGuideManifestDto)
    manifest?: ImplementationGuideManifest

    @IsNotEmpty()
    @IsString()
    name: string

    @IsNotEmpty()
    @IsString()
    packageId: string

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @IsString()
    title?: string

    @IsNotEmpty()
    @IsString()
    url: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @IsString()
    versionAlgorithmString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    versionAlgorithmCoding?: Coding

  }
  export class IngredientManufacturerDto implements IngredientManufacturer {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    manufacturer: Reference

    @IsNotEmpty()
    @IsIn(["actual", "allowed", "possible"])
    role: "actual" | "allowed" | "possible"

  }
  export class IngredientSubstanceStrengthReferenceStrengthDto implements IngredientSubstanceStrengthReferenceStrength {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    country?: CodeableConcept[]

    @IsOptional()
    @IsString()
    measurementPoint?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    strengthRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioRangeDto)
    strengthRatioRange?: RatioRange

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    strengthQuantity?: Quantity

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    substance: CodeableReference

  }
  export class IngredientSubstanceStrengthDto implements IngredientSubstanceStrength {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    basis?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    concentrationRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioRangeDto)
    concentrationRatioRange?: RatioRange

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    concentrationCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    concentrationQuantity?: Quantity

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    country?: CodeableConcept[]

    @IsOptional()
    @IsString()
    measurementPoint?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    presentationRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioRangeDto)
    presentationRatioRange?: RatioRange

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    presentationCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    presentationQuantity?: Quantity

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IngredientSubstanceStrengthReferenceStrengthDto)
    referenceStrength?: IngredientSubstanceStrengthReferenceStrength[]

    @IsOptional()
    @IsString()
    textConcentration?: string

    @IsOptional()
    @IsString()
    textPresentation?: string

  }
  export class IngredientSubstanceDto implements IngredientSubstance {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    code: CodeableReference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IngredientSubstanceStrengthDto)
    strength?: IngredientSubstanceStrength[]

  }
  export class IngredientDto implements Ingredient {
    @IsNotEmpty()
    @IsIn(["Ingredient"])
    resourceType: "Ingredient"

    @IsNotEmpty()
    @IsBoolean()
    allergenicIndicator: boolean

    @IsOptional()
    @IsString()
    comment?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    for?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    function?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    group?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IngredientManufacturerDto)
    manufacturer?: IngredientManufacturer[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    role: CodeableConcept

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => IngredientSubstanceDto)
    substance: IngredientSubstance

  }
  export class InsurancePlanCoverageBenefitLimitDto implements InsurancePlanCoverageBenefitLimit {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    value?: Quantity

  }
  export class InsurancePlanCoverageBenefitDto implements InsurancePlanCoverageBenefit {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => InsurancePlanCoverageBenefitLimitDto)
    limit?: InsurancePlanCoverageBenefitLimit[]

    @IsOptional()
    @IsString()
    requirement?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class InsurancePlanCoverageDto implements InsurancePlanCoverage {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => InsurancePlanCoverageBenefitDto)
    benefit: InsurancePlanCoverageBenefit[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    network?: Reference[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class InsurancePlanPlanGeneralCostDto implements InsurancePlanPlanGeneralCost {
    @IsOptional()
    @IsString()
    comment?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    cost?: Money

    @IsOptional()
    @IsNumber()
    groupSize?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class InsurancePlanPlanSpecificCostBenefitCostDto implements InsurancePlanPlanSpecificCostBenefitCost {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    applicability?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    qualifiers?: CodeableConcept[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    value?: Quantity

  }
  export class InsurancePlanPlanSpecificCostBenefitDto implements InsurancePlanPlanSpecificCostBenefit {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => InsurancePlanPlanSpecificCostBenefitCostDto)
    cost?: InsurancePlanPlanSpecificCostBenefitCost[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class InsurancePlanPlanSpecificCostDto implements InsurancePlanPlanSpecificCost {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => InsurancePlanPlanSpecificCostBenefitDto)
    benefit?: InsurancePlanPlanSpecificCostBenefit[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category: CodeableConcept

  }
  export class InsurancePlanPlanDto implements InsurancePlanPlan {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    coverageArea?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => InsurancePlanPlanGeneralCostDto)
    generalCost?: InsurancePlanPlanGeneralCost[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    network?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => InsurancePlanPlanSpecificCostDto)
    specificCost?: InsurancePlanPlanSpecificCost[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class InsurancePlanDto implements InsurancePlan {
    @IsNotEmpty()
    @IsIn(["InsurancePlan"])
    resourceType: "InsurancePlan"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    administeredBy?: Reference

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    alias?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExtendedContactDetailDto)
    contact?: ExtendedContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => InsurancePlanCoverageDto)
    coverage?: InsurancePlanCoverage[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    coverageArea?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    endpoint?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    network?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    ownedBy?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => InsurancePlanPlanDto)
    plan?: InsurancePlanPlan[]

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

  }
  export class InventoryItemNameDto implements InventoryItemName {
    @IsNotEmpty()
    @IsString()
    language: string

    @IsNotEmpty()
    @IsString()
    name: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodingDto)
    nameType: Coding

  }
  export class InventoryItemResponsibleOrganizationDto implements InventoryItemResponsibleOrganization {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    organization: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    role: CodeableConcept

  }
  export class InventoryItemDescriptionDto implements InventoryItemDescription {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    language?: string

  }
  export class InventoryItemAssociationDto implements InventoryItemAssociation {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    associationType: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => RatioDto)
    quantity: Ratio

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    relatedItem: Reference

  }
  export class InventoryItemCharacteristicDto implements InventoryItemCharacteristic {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    characteristicType: CodeableConcept

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsOptional()
    @IsNumber()
    valueDecimal?: number

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsString()
    valueUrl?: string

    @IsOptional()
    @IsString()
    valueDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    valueRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => AnnotationDto)
    valueAnnotation?: Annotation

    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    valueAddress?: Address

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    valueDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

  }
  export class InventoryItemInstanceDto implements InventoryItemInstance {
    @IsOptional()
    @IsString()
    expiry?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    location?: Reference

    @IsOptional()
    @IsString()
    lotNumber?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

  }
  export class InventoryItemDto implements InventoryItem {
    @IsNotEmpty()
    @IsIn(["InventoryItem"])
    resourceType: "InventoryItem"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => InventoryItemAssociationDto)
    association?: InventoryItemAssociation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    baseUnit?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => InventoryItemCharacteristicDto)
    characteristic?: InventoryItemCharacteristic[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => InventoryItemDescriptionDto)
    description?: InventoryItemDescription

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => InventoryItemInstanceDto)
    instance?: InventoryItemInstance

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    inventoryStatus?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => InventoryItemNameDto)
    name?: InventoryItemName[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    netContent?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    productReference?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => InventoryItemResponsibleOrganizationDto)
    responsibleOrganization?: InventoryItemResponsibleOrganization[]

    @IsNotEmpty()
    @IsIn(["active", "unknown", "inactive", "entered-in-error"])
    status: "active" | "unknown" | "inactive" | "entered-in-error"

  }
  export class InventoryReportInventoryListingItemDto implements InventoryReportInventoryListingItem {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    item: CodeableReference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity: Quantity

  }
  export class InventoryReportInventoryListingDto implements InventoryReportInventoryListing {
    @IsOptional()
    @IsString()
    countingDateTime?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => InventoryReportInventoryListingItemDto)
    item?: InventoryReportInventoryListingItem[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    itemStatus?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    location?: Reference

  }
  export class InventoryReportDto implements InventoryReport {
    @IsNotEmpty()
    @IsIn(["InventoryReport"])
    resourceType: "InventoryReport"

    @IsNotEmpty()
    @IsIn(["snapshot", "difference"])
    countType: "snapshot" | "difference"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => InventoryReportInventoryListingDto)
    inventoryListing?: InventoryReportInventoryListing[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    operationType?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    operationTypeReason?: CodeableConcept

    @IsNotEmpty()
    @IsString()
    reportedDateTime: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    reporter?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    reportingPeriod?: Period

    @IsNotEmpty()
    @IsIn(["draft", "active", "entered-in-error", "requested"])
    status: "draft" | "active" | "entered-in-error" | "requested"

  }
  export class InvoiceParticipantDto implements InvoiceParticipant {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    actor: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    role?: CodeableConcept

  }
  export class InvoiceLineItemDto implements InvoiceLineItem {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    chargeItemReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    chargeItemCodeableConcept?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MonetaryComponentDto)
    priceComponent?: MonetaryComponent[]

    @IsOptional()
    @IsNumber()
    sequence?: number

    @IsOptional()
    @IsString()
    servicedDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    servicedPeriod?: Period

  }
  export class InvoiceDto implements Invoice {
    @IsNotEmpty()
    @IsIn(["Invoice"])
    resourceType: "Invoice"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    account?: Reference

    @IsOptional()
    @IsString()
    cancelledReason?: string

    @IsOptional()
    @IsString()
    creation?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    issuer?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => InvoiceLineItemDto)
    lineItem?: InvoiceLineItem[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => InvoiceParticipantDto)
    participant?: InvoiceParticipant[]

    @IsOptional()
    @IsString()
    paymentTerms?: string

    @IsOptional()
    @IsString()
    periodDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    periodPeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    recipient?: Reference

    @IsNotEmpty()
    @IsIn(["draft", "entered-in-error", "cancelled", "issued", "balanced"])
    status: "draft" | "entered-in-error" | "cancelled" | "issued" | "balanced"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    totalGross?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    totalNet?: Money

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MonetaryComponentDto)
    totalPriceComponent?: MonetaryComponent[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class LibraryDto implements Library {
    @IsNotEmpty()
    @IsIn(["Library"])
    resourceType: "Library"

    @IsOptional()
    @IsString()
    approvalDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    author?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AttachmentDto)
    content?: Attachment[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    copyrightLabel?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DataRequirementDto)
    dataRequirement?: DataRequirement[]

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    editor?: ContactDetail[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    endorser?: ContactDetail[]

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    lastReviewDate?: string

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ParameterDefinitionDto)
    parameter?: ParameterDefinition[]

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    relatedArtifact?: RelatedArtifact[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    reviewer?: ContactDetail[]

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    subjectCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subjectReference?: Reference

    @IsOptional()
    @IsString()
    subtitle?: string

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    topic?: CodeableConcept[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsString()
    usage?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @IsString()
    versionAlgorithmString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    versionAlgorithmCoding?: Coding

  }
  export class LinkageItemDto implements LinkageItem {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    resource: Reference

    @IsNotEmpty()
    @IsIn(["source", "alternate", "historical"])
    type: "source" | "alternate" | "historical"

  }
  export class LinkageDto implements Linkage {
    @IsNotEmpty()
    @IsIn(["Linkage"])
    resourceType: "Linkage"

    @IsNotEmpty()
    @IsBoolean()
    active: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    author?: Reference

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => LinkageItemDto)
    item: LinkageItem[]

  }
  export class ListEntryDto implements ListEntry {
    @IsOptional()
    @IsString()
    date?: string

    @IsNotEmpty()
    @IsBoolean()
    deleted: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    flag?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    item: Reference

  }
  export class ListDto implements List {
    @IsNotEmpty()
    @IsIn(["List"])
    resourceType: "List"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    emptyReason?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ListEntryDto)
    entry?: ListEntry[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsNotEmpty()
    @IsIn(["working", "snapshot", "changes"])
    mode: "working" | "snapshot" | "changes"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    orderedBy?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    source?: Reference

    @IsNotEmpty()
    @IsIn(["current", "retired", "entered-in-error"])
    status: "current" | "retired" | "entered-in-error"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    subject?: Reference[]

    @IsOptional()
    @IsString()
    title?: string

  }
  export class LocationPositionDto implements LocationPosition {
    @IsOptional()
    @IsNumber()
    altitude?: number

    @IsNotEmpty()
    @IsNumber()
    latitude: number

    @IsNotEmpty()
    @IsNumber()
    longitude: number

  }
  export class LocationDto implements Location {
    @IsNotEmpty()
    @IsIn(["Location"])
    resourceType: "Location"

    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    address?: Address

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    alias?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    characteristic?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExtendedContactDetailDto)
    contact?: ExtendedContactDetail[]

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    endpoint?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    form?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AvailabilityDto)
    hoursOfOperation?: Availability[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    managingOrganization?: Reference

    @IsNotEmpty()
    @IsIn(["instance", "kind"])
    mode: "instance" | "kind"

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    operationalStatus?: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    partOf?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => LocationPositionDto)
    position?: LocationPosition

    @IsNotEmpty()
    @IsIn(["active", "inactive", "suspended"])
    status: "active" | "inactive" | "suspended"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => VirtualServiceDetailDto)
    virtualService?: VirtualServiceDetail[]

  }
  export class ManufacturedItemDefinitionPropertyDto implements ManufacturedItemDefinitionProperty {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @IsString()
    valueDate?: string

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsString()
    valueMarkdown?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

  }
  export class ManufacturedItemDefinitionComponentConstituentDto implements ManufacturedItemDefinitionComponentConstituent {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => QuantityDto)
    amount?: Quantity[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    function?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    hasIngredient?: CodeableReference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    location?: CodeableConcept[]

  }
  export class ManufacturedItemDefinitionComponentDto implements ManufacturedItemDefinitionComponent {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => QuantityDto)
    amount?: Quantity[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ManufacturedItemDefinitionComponentDto)
    component?: ManufacturedItemDefinitionComponent[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ManufacturedItemDefinitionComponentConstituentDto)
    constituent?: ManufacturedItemDefinitionComponentConstituent[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    function?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ManufacturedItemDefinitionPropertyDto)
    property?: ManufacturedItemDefinitionProperty[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class ManufacturedItemDefinitionDto implements ManufacturedItemDefinition {
    @IsNotEmpty()
    @IsIn(["ManufacturedItemDefinition"])
    resourceType: "ManufacturedItemDefinition"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ManufacturedItemDefinitionComponentDto)
    component?: ManufacturedItemDefinitionComponent[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    ingredient?: CodeableConcept[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    manufacturedDoseForm: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    manufacturer?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MarketingStatusDto)
    marketingStatus?: MarketingStatus[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ManufacturedItemDefinitionPropertyDto)
    property?: ManufacturedItemDefinitionProperty[]

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    unitOfPresentation?: CodeableConcept

  }
  export class MeasureTermDto implements MeasureTerm {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsString()
    definition?: string

  }
  export class MeasureGroupPopulationDto implements MeasureGroupPopulation {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    aggregateMethod?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    criteria?: Expression

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    groupDefinition?: Reference

    @IsOptional()
    @IsString()
    inputPopulationId?: string

    @IsOptional()
    @IsString()
    linkId?: string

  }
  export class MeasureGroupStratifierComponentDto implements MeasureGroupStratifierComponent {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    criteria?: Expression

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    groupDefinition?: Reference

    @IsOptional()
    @IsString()
    linkId?: string

  }
  export class MeasureGroupStratifierDto implements MeasureGroupStratifier {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MeasureGroupStratifierComponentDto)
    component?: MeasureGroupStratifierComponent[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    criteria?: Expression

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    groupDefinition?: Reference

    @IsOptional()
    @IsString()
    linkId?: string

  }
  export class MeasureGroupDto implements MeasureGroup {
    @IsOptional()
    @IsString()
    basis?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    improvementNotation?: CodeableConcept

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    library?: string[]

    @IsOptional()
    @IsString()
    linkId?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MeasureGroupPopulationDto)
    population?: MeasureGroupPopulation[]

    @IsOptional()
    @IsString()
    rateAggregation?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    scoring?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    scoringUnit?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MeasureGroupStratifierDto)
    stratifier?: MeasureGroupStratifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    subjectCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subjectReference?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

  }
  export class MeasureSupplementalDataDto implements MeasureSupplementalData {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ExpressionDto)
    criteria: Expression

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    linkId?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    usage?: CodeableConcept[]

  }
  export class MeasureDto implements Measure {
    @IsNotEmpty()
    @IsIn(["Measure"])
    resourceType: "Measure"

    @IsOptional()
    @IsString()
    approvalDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    author?: ContactDetail[]

    @IsOptional()
    @IsString()
    basis?: string

    @IsOptional()
    @IsString()
    clinicalRecommendationStatement?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    compositeScoring?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    copyrightLabel?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    disclaimer?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    editor?: ContactDetail[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    endorser?: ContactDetail[]

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MeasureGroupDto)
    group?: MeasureGroup[]

    @IsOptional()
    @IsString()
    guidance?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    improvementNotation?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    lastReviewDate?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    library?: string[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @IsString()
    rateAggregation?: string

    @IsOptional()
    @IsString()
    rationale?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    relatedArtifact?: RelatedArtifact[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    reviewer?: ContactDetail[]

    @IsOptional()
    @IsString()
    riskAdjustment?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    scoring?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    scoringUnit?: CodeableConcept

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    subjectCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subjectReference?: Reference

    @IsOptional()
    @IsString()
    subtitle?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MeasureSupplementalDataDto)
    supplementalData?: MeasureSupplementalData[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MeasureTermDto)
    term?: MeasureTerm[]

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    topic?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsString()
    usage?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @IsString()
    versionAlgorithmString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    versionAlgorithmCoding?: Coding

  }
  export class MeasureReportGroupPopulationDto implements MeasureReportGroupPopulation {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsNumber()
    count?: number

    @IsOptional()
    @IsString()
    linkId?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    subjectReport?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subjectResults?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subjects?: Reference

  }
  export class MeasureReportGroupStratifierStratumComponentDto implements MeasureReportGroupStratifierStratumComponent {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsOptional()
    @IsString()
    linkId?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

  }
  export class MeasureReportGroupStratifierStratumPopulationDto implements MeasureReportGroupStratifierStratumPopulation {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsNumber()
    count?: number

    @IsOptional()
    @IsString()
    linkId?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    subjectReport?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subjectResults?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subjects?: Reference

  }
  export class MeasureReportGroupStratifierStratumDto implements MeasureReportGroupStratifierStratum {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MeasureReportGroupStratifierStratumComponentDto)
    component?: MeasureReportGroupStratifierStratumComponent[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    measureScoreQuantity?: Quantity

    @IsOptional()
    @IsString()
    measureScoreDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    measureScoreCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    measureScorePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    measureScoreRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    measureScoreDuration?: Duration

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MeasureReportGroupStratifierStratumPopulationDto)
    population?: MeasureReportGroupStratifierStratumPopulation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

  }
  export class MeasureReportGroupStratifierDto implements MeasureReportGroupStratifier {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsString()
    linkId?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MeasureReportGroupStratifierStratumDto)
    stratum?: MeasureReportGroupStratifierStratum[]

  }
  export class MeasureReportGroupDto implements MeasureReportGroup {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsString()
    linkId?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    measureScoreQuantity?: Quantity

    @IsOptional()
    @IsString()
    measureScoreDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    measureScoreCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    measureScorePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    measureScoreRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    measureScoreDuration?: Duration

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MeasureReportGroupPopulationDto)
    population?: MeasureReportGroupPopulation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MeasureReportGroupStratifierDto)
    stratifier?: MeasureReportGroupStratifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

  }
  export class MeasureReportDto implements MeasureReport {
    @IsNotEmpty()
    @IsIn(["MeasureReport"])
    resourceType: "MeasureReport"

    @IsNotEmpty()
    @IsIn(["snapshot", "incremental"])
    dataUpdateType: "snapshot" | "incremental"

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    evaluatedResource?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MeasureReportGroupDto)
    group?: MeasureReportGroup[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    improvementNotation?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    inputParameters?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    location?: Reference

    @IsOptional()
    @IsString()
    measure?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => PeriodDto)
    period: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    reporter?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    reportingVendor?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    scoring?: CodeableConcept

    @IsNotEmpty()
    @IsIn(["error", "pending", "complete"])
    status: "error" | "pending" | "complete"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    supplementalData?: Reference[]

    @IsNotEmpty()
    @IsIn(["individual", "subject-list", "summary", "data-exchange"])
    type: "individual" | "subject-list" | "summary" | "data-exchange"

  }
  export class MedicationIngredientDto implements MedicationIngredient {
    @IsNotEmpty()
    @IsBoolean()
    isActive: boolean

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    item: CodeableReference

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    strengthRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    strengthCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    strengthQuantity?: Quantity

  }
  export class MedicationBatchDto implements MedicationBatch {
    @IsOptional()
    @IsString()
    expirationDate?: string

    @IsOptional()
    @IsString()
    lotNumber?: string

  }
  export class MedicationDto implements Medication {
    @IsNotEmpty()
    @IsIn(["Medication"])
    resourceType: "Medication"

    @IsOptional()
    @ValidateNested()
    @Type(() => MedicationBatchDto)
    batch?: MedicationBatch

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    definition?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    doseForm?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationIngredientDto)
    ingredient?: MedicationIngredient[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    marketingAuthorizationHolder?: Reference

    @IsNotEmpty()
    @IsIn(["active", "inactive", "entered-in-error"])
    status: "active" | "inactive" | "entered-in-error"

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    totalVolume?: Quantity

  }
  export class MedicationAdministrationPerformerDto implements MedicationAdministrationPerformer {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    actor: CodeableReference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    function?: CodeableConcept

  }
  export class MedicationAdministrationDosageDto implements MedicationAdministrationDosage {
    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    dose?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    method?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    rateRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    rateQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    route?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    site?: CodeableConcept

    @IsOptional()
    @IsString()
    text?: string

  }
  export class MedicationAdministrationDto implements MedicationAdministration {
    @IsNotEmpty()
    @IsIn(["MedicationAdministration"])
    resourceType: "MedicationAdministration"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    device?: CodeableReference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MedicationAdministrationDosageDto)
    dosage?: MedicationAdministrationDosage

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    eventHistory?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsNotEmpty()
    @IsBoolean()
    isSubPotent: boolean

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    medication: CodeableReference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    occurenceDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    occurencePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    occurenceTiming?: Timing

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    partOf?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationAdministrationPerformerDto)
    performer?: MedicationAdministrationPerformer[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    reason?: CodeableReference[]

    @IsOptional()
    @IsString()
    recorded?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    request?: Reference

    @IsNotEmpty()
    @IsIn(["unknown", "entered-in-error", "on-hold", "in-progress", "completed", "not-done", "stopped"])
    status: "unknown" | "entered-in-error" | "on-hold" | "in-progress" | "completed" | "not-done" | "stopped"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    statusReason?: CodeableConcept[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    subPotentReason?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    supportingInformation?: Reference[]

  }
  export class MedicationDispensePerformerDto implements MedicationDispensePerformer {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    actor: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    function?: CodeableConcept

  }
  export class MedicationDispenseSubstitutionDto implements MedicationDispenseSubstitution {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    reason?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    responsibleParty?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    wasSubstituted: boolean

  }
  export class MedicationDispenseDto implements MedicationDispense {
    @IsNotEmpty()
    @IsIn(["MedicationDispense"])
    resourceType: "MedicationDispense"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    authorizingPrescription?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    daysSupply?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    destination?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DosageDto)
    dosageInstruction?: Dosage[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    eventHistory?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    location?: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    medication: CodeableReference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    notPerformedReason?: CodeableReference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    partOf?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationDispensePerformerDto)
    performer?: MedicationDispensePerformer[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    receiver?: Reference[]

    @IsOptional()
    @IsString()
    recorded?: string

    @IsOptional()
    @IsString()
    renderedDosageInstruction?: string

    @IsNotEmpty()
    @IsIn(["unknown", "entered-in-error", "on-hold", "in-progress", "completed", "declined", "cancelled", "preparation", "stopped"])
    status: "unknown" | "entered-in-error" | "on-hold" | "in-progress" | "completed" | "declined" | "cancelled" | "preparation" | "stopped"

    @IsOptional()
    @IsString()
    statusChanged?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => MedicationDispenseSubstitutionDto)
    substitution?: MedicationDispenseSubstitution

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    supportingInformation?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsOptional()
    @IsString()
    whenHandedOver?: string

    @IsOptional()
    @IsString()
    whenPrepared?: string

  }
  export class MedicationKnowledgeRelatedMedicationKnowledgeDto implements MedicationKnowledgeRelatedMedicationKnowledge {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    reference: Reference[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class MedicationKnowledgeMonographDto implements MedicationKnowledgeMonograph {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    source?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class MedicationKnowledgeCostDto implements MedicationKnowledgeCost {
    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    costMoney?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    costCodeableConcept?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PeriodDto)
    effectiveDate?: Period[]

    @IsOptional()
    @IsString()
    source?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class MedicationKnowledgeMonitoringProgramDto implements MedicationKnowledgeMonitoringProgram {
    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class MedicationKnowledgeIndicationGuidelineDosingGuidelineDosageDto implements MedicationKnowledgeIndicationGuidelineDosingGuidelineDosage {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DosageDto)
    dosage: Dosage[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class MedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicDto implements MedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

  }
  export class MedicationKnowledgeIndicationGuidelineDosingGuidelineDto implements MedicationKnowledgeIndicationGuidelineDosingGuideline {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    administrationTreatment?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationKnowledgeIndicationGuidelineDosingGuidelineDosageDto)
    dosage?: MedicationKnowledgeIndicationGuidelineDosingGuidelineDosage[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristicDto)
    patientCharacteristic?: MedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    treatmentIntent?: CodeableConcept

  }
  export class MedicationKnowledgeIndicationGuidelineDto implements MedicationKnowledgeIndicationGuideline {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationKnowledgeIndicationGuidelineDosingGuidelineDto)
    dosingGuideline?: MedicationKnowledgeIndicationGuidelineDosingGuideline[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    indication?: CodeableReference[]

  }
  export class MedicationKnowledgeMedicineClassificationDto implements MedicationKnowledgeMedicineClassification {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    classification?: CodeableConcept[]

    @IsOptional()
    @IsString()
    sourceString?: string

    @IsOptional()
    @IsString()
    sourceUri?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class MedicationKnowledgePackagingDto implements MedicationKnowledgePackaging {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationKnowledgeCostDto)
    cost?: MedicationKnowledgeCost[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    packagedProduct?: Reference

  }
  export class MedicationKnowledgeStorageGuidelineEnvironmentalSettingDto implements MedicationKnowledgeStorageGuidelineEnvironmentalSetting {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

  }
  export class MedicationKnowledgeStorageGuidelineDto implements MedicationKnowledgeStorageGuideline {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationKnowledgeStorageGuidelineEnvironmentalSettingDto)
    environmentalSetting?: MedicationKnowledgeStorageGuidelineEnvironmentalSetting[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    reference?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    stabilityDuration?: Duration

  }
  export class MedicationKnowledgeRegulatorySubstitutionDto implements MedicationKnowledgeRegulatorySubstitution {
    @IsNotEmpty()
    @IsBoolean()
    allowed: boolean

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class MedicationKnowledgeRegulatoryMaxDispenseDto implements MedicationKnowledgeRegulatoryMaxDispense {
    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    period?: Duration

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity: Quantity

  }
  export class MedicationKnowledgeRegulatoryDto implements MedicationKnowledgeRegulatory {
    @IsOptional()
    @ValidateNested()
    @Type(() => MedicationKnowledgeRegulatoryMaxDispenseDto)
    maxDispense?: MedicationKnowledgeRegulatoryMaxDispense

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    regulatoryAuthority: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    schedule?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationKnowledgeRegulatorySubstitutionDto)
    substitution?: MedicationKnowledgeRegulatorySubstitution[]

  }
  export class MedicationKnowledgeDefinitionalIngredientDto implements MedicationKnowledgeDefinitionalIngredient {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    item: CodeableReference

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    strengthRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    strengthCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    strengthQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class MedicationKnowledgeDefinitionalDrugCharacteristicDto implements MedicationKnowledgeDefinitionalDrugCharacteristic {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @IsString()
    valueBase64Binary?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

  }
  export class MedicationKnowledgeDefinitionalDto implements MedicationKnowledgeDefinitional {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    definition?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    doseForm?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationKnowledgeDefinitionalDrugCharacteristicDto)
    drugCharacteristic?: MedicationKnowledgeDefinitionalDrugCharacteristic[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationKnowledgeDefinitionalIngredientDto)
    ingredient?: MedicationKnowledgeDefinitionalIngredient[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    intendedRoute?: CodeableConcept[]

  }
  export class MedicationKnowledgeDto implements MedicationKnowledge {
    @IsNotEmpty()
    @IsIn(["MedicationKnowledge"])
    resourceType: "MedicationKnowledge"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    associatedMedication?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    author?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    clinicalUseIssue?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationKnowledgeCostDto)
    cost?: MedicationKnowledgeCost[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MedicationKnowledgeDefinitionalDto)
    definitional?: MedicationKnowledgeDefinitional

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationKnowledgeIndicationGuidelineDto)
    indicationGuideline?: MedicationKnowledgeIndicationGuideline[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    intendedJurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationKnowledgeMedicineClassificationDto)
    medicineClassification?: MedicationKnowledgeMedicineClassification[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationKnowledgeMonitoringProgramDto)
    monitoringProgram?: MedicationKnowledgeMonitoringProgram[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationKnowledgeMonographDto)
    monograph?: MedicationKnowledgeMonograph[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    name?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationKnowledgePackagingDto)
    packaging?: MedicationKnowledgePackaging[]

    @IsOptional()
    @IsString()
    preparationInstruction?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    productType?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationKnowledgeRegulatoryDto)
    regulatory?: MedicationKnowledgeRegulatory[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationKnowledgeRelatedMedicationKnowledgeDto)
    relatedMedicationKnowledge?: MedicationKnowledgeRelatedMedicationKnowledge[]

    @IsNotEmpty()
    @IsIn(["active", "inactive", "entered-in-error"])
    status: "active" | "inactive" | "entered-in-error"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationKnowledgeStorageGuidelineDto)
    storageGuideline?: MedicationKnowledgeStorageGuideline[]

  }
  export class MedicationRequestDispenseRequestInitialFillDto implements MedicationRequestDispenseRequestInitialFill {
    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    duration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

  }
  export class MedicationRequestDispenseRequestDto implements MedicationRequestDispenseRequest {
    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    dispenseInterval?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    dispenser?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    dispenserInstruction?: Annotation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    doseAdministrationAid?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    expectedSupplyDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => MedicationRequestDispenseRequestInitialFillDto)
    initialFill?: MedicationRequestDispenseRequestInitialFill

    @IsOptional()
    @IsNumber()
    numberOfRepeatsAllowed?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    validityPeriod?: Period

  }
  export class MedicationRequestSubstitutionDto implements MedicationRequestSubstitution {
    @IsNotEmpty()
    @IsBoolean()
    allowedBoolean: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    allowedCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    reason?: CodeableConcept

  }
  export class MedicationRequestDto implements MedicationRequest {
    @IsNotEmpty()
    @IsIn(["MedicationRequest"])
    resourceType: "MedicationRequest"

    @IsOptional()
    @IsString()
    authoredOn?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    courseOfTherapyType?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    device?: CodeableReference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MedicationRequestDispenseRequestDto)
    dispenseRequest?: MedicationRequestDispenseRequest

    @IsNotEmpty()
    @IsBoolean()
    doNotPerform: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DosageDto)
    dosageInstruction?: Dosage[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectiveDosePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    eventHistory?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    groupIdentifier?: Identifier

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    informationSource?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    insurance?: Reference[]

    @IsNotEmpty()
    @IsIn(["proposal", "plan", "order", "original-order", "reflex-order", "filler-order", "instance-order", "option"])
    intent: "proposal" | "plan" | "order" | "original-order" | "reflex-order" | "filler-order" | "instance-order" | "option"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    medication: CodeableReference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    performer?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    performerType?: CodeableConcept

    @IsNotEmpty()
    @IsIn(["routine", "urgent", "asap", "stat"])
    priority: "routine" | "urgent" | "asap" | "stat"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    priorPrescription?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    reason?: CodeableReference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    recorder?: Reference

    @IsOptional()
    @IsString()
    renderedDosageInstruction?: string

    @IsNotEmpty()
    @IsBoolean()
    reported: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    requester?: Reference

    @IsNotEmpty()
    @IsIn(["draft", "active", "unknown", "entered-in-error", "on-hold", "completed", "cancelled", "stopped", "ended"])
    status: "draft" | "active" | "unknown" | "entered-in-error" | "on-hold" | "completed" | "cancelled" | "stopped" | "ended"

    @IsOptional()
    @IsString()
    statusChanged?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    statusReason?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => MedicationRequestSubstitutionDto)
    substitution?: MedicationRequestSubstitution

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    supportingInformation?: Reference[]

  }
  export class MedicationStatementAdherenceDto implements MedicationStatementAdherence {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    reason?: CodeableConcept

  }
  export class MedicationStatementDto implements MedicationStatement {
    @IsNotEmpty()
    @IsIn(["MedicationStatement"])
    resourceType: "MedicationStatement"

    @IsOptional()
    @ValidateNested()
    @Type(() => MedicationStatementAdherenceDto)
    adherence?: MedicationStatementAdherence

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsOptional()
    @IsString()
    dateAsserted?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    derivedFrom?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DosageDto)
    dosage?: Dosage[]

    @IsOptional()
    @IsString()
    effectiveDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    effectiveTiming?: Timing

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    informationSource?: Reference[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    medication: CodeableReference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    partOf?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    reason?: CodeableReference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    relatedClinicalInformation?: Reference[]

    @IsOptional()
    @IsString()
    renderedDosageInstruction?: string

    @IsNotEmpty()
    @IsIn(["draft", "entered-in-error", "recorded"])
    status: "draft" | "entered-in-error" | "recorded"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

  }
  export class MedicinalProductDefinitionContactDto implements MedicinalProductDefinitionContact {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    contact: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class MedicinalProductDefinitionNamePartDto implements MedicinalProductDefinitionNamePart {
    @IsNotEmpty()
    @IsString()
    part: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class MedicinalProductDefinitionNameUsageDto implements MedicinalProductDefinitionNameUsage {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    country: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    language: CodeableConcept

  }
  export class MedicinalProductDefinitionNameDto implements MedicinalProductDefinitionName {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicinalProductDefinitionNamePartDto)
    part?: MedicinalProductDefinitionNamePart[]

    @IsNotEmpty()
    @IsString()
    productName: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicinalProductDefinitionNameUsageDto)
    usage?: MedicinalProductDefinitionNameUsage[]

  }
  export class MedicinalProductDefinitionCrossReferenceDto implements MedicinalProductDefinitionCrossReference {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    product: CodeableReference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class MedicinalProductDefinitionOperationDto implements MedicinalProductDefinitionOperation {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    confidentialityIndicator?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectiveDate?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    organization?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    type?: CodeableReference

  }
  export class MedicinalProductDefinitionCharacteristicDto implements MedicinalProductDefinitionCharacteristic {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @IsString()
    valueMarkdown?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsOptional()
    @IsString()
    valueDate?: string

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

  }
  export class MedicinalProductDefinitionDto implements MedicinalProductDefinition {
    @IsNotEmpty()
    @IsIn(["MedicinalProductDefinition"])
    resourceType: "MedicinalProductDefinition"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    additionalMonitoringIndicator?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    attachedDocument?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicinalProductDefinitionCharacteristicDto)
    characteristic?: MedicinalProductDefinitionCharacteristic[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    classification?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    clinicalTrial?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    code?: Coding[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    combinedPharmaceuticalDoseForm?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    comprisedOf?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicinalProductDefinitionContactDto)
    contact?: MedicinalProductDefinitionContact[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicinalProductDefinitionCrossReferenceDto)
    crossReference?: MedicinalProductDefinitionCrossReference[]

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    domain?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    impurity?: CodeableReference[]

    @IsOptional()
    @IsString()
    indication?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    ingredient?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    legalStatusOfSupply?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MarketingStatusDto)
    marketingStatus?: MarketingStatus[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    masterFile?: Reference[]

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicinalProductDefinitionNameDto)
    name: MedicinalProductDefinitionName[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicinalProductDefinitionOperationDto)
    operation?: MedicinalProductDefinitionOperation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    packagedMedicinalProduct?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    pediatricUseIndicator?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    route?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    specialMeasures?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    status?: CodeableConcept

    @IsOptional()
    @IsString()
    statusDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsOptional()
    @IsString()
    version?: string

  }
  export class MessageDefinitionFocusDto implements MessageDefinitionFocus {
    @IsNotEmpty()
    @IsString()
    code: string

    @IsOptional()
    @IsString()
    max?: string

    @IsNotEmpty()
    @IsNumber()
    min: number

    @IsOptional()
    @IsString()
    profile?: string

  }
  export class MessageDefinitionAllowedResponseDto implements MessageDefinitionAllowedResponse {
    @IsNotEmpty()
    @IsString()
    message: string

    @IsOptional()
    @IsString()
    situation?: string

  }
  export class MessageDefinitionDto implements MessageDefinition {
    @IsNotEmpty()
    @IsIn(["MessageDefinition"])
    resourceType: "MessageDefinition"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MessageDefinitionAllowedResponseDto)
    allowedResponse?: MessageDefinitionAllowedResponse[]

    @IsOptional()
    @IsString()
    base?: string

    @IsNotEmpty()
    @IsIn(["consequence", "currency", "notification"])
    category: "consequence" | "currency" | "notification"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    copyrightLabel?: string

    @IsNotEmpty()
    @IsString()
    date: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    eventCoding?: Coding

    @IsOptional()
    @IsString()
    eventUri?: string

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MessageDefinitionFocusDto)
    focus?: MessageDefinitionFocus[]

    @IsOptional()
    @IsString()
    graph?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    parent?: string[]

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    replaces?: string[]

    @IsNotEmpty()
    @IsIn(["always", "on-error", "never", "on-success"])
    responseRequired: "always" | "on-error" | "never" | "on-success"

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @IsString()
    versionAlgorithmString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    versionAlgorithmCoding?: Coding

  }
  export class MessageHeaderDestinationDto implements MessageHeaderDestination {
    @IsOptional()
    @IsString()
    endpointUrl?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    endpointReference?: Reference

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    receiver?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    target?: Reference

  }
  export class MessageHeaderSourceDto implements MessageHeaderSource {
    @IsOptional()
    @ValidateNested()
    @Type(() => ContactPointDto)
    contact?: ContactPoint

    @IsOptional()
    @IsString()
    endpointUrl?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    endpointReference?: Reference

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsString()
    software?: string

    @IsOptional()
    @IsString()
    version?: string

  }
  export class MessageHeaderResponseDto implements MessageHeaderResponse {
    @IsNotEmpty()
    @IsIn(["ok", "transient-error", "fatal-error"])
    code: "ok" | "transient-error" | "fatal-error"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    details?: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier: Identifier

  }
  export class MessageHeaderDto implements MessageHeader {
    @IsNotEmpty()
    @IsIn(["MessageHeader"])
    resourceType: "MessageHeader"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    author?: Reference

    @IsOptional()
    @IsString()
    definition?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MessageHeaderDestinationDto)
    destination?: MessageHeaderDestination[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    eventCoding?: Coding

    @IsOptional()
    @IsString()
    eventCanonical?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    focus?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    reason?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => MessageHeaderResponseDto)
    response?: MessageHeaderResponse

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    responsible?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    sender?: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => MessageHeaderSourceDto)
    source: MessageHeaderSource

  }
  export class MetadataResourceDto implements MetadataResource {
    @IsNotEmpty()
    @IsString()
    resourceType: string

    @IsOptional()
    @IsString()
    approvalDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    author?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    editor?: ContactDetail[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    endorser?: ContactDetail[]

    @IsOptional()
    @IsString()
    lastReviewDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    relatedArtifact?: RelatedArtifact[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    reviewer?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    topic?: CodeableConcept[]

  }
  export class MolecularSequenceRelativeStartingSequenceDto implements MolecularSequenceRelativeStartingSequence {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    chromosome?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    genomeAssembly?: CodeableConcept

    @IsNotEmpty()
    @IsIn(["sense", "antisense"])
    orientation: "sense" | "antisense"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    sequenceCodeableConcept?: CodeableConcept

    @IsOptional()
    @IsString()
    sequenceString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    sequenceReference?: Reference

    @IsNotEmpty()
    @IsIn(["watson", "crick"])
    strand: "watson" | "crick"

    @IsOptional()
    @IsNumber()
    windowEnd?: number

    @IsOptional()
    @IsNumber()
    windowStart?: number

  }
  export class MolecularSequenceRelativeEditDto implements MolecularSequenceRelativeEdit {
    @IsOptional()
    @IsNumber()
    end?: number

    @IsOptional()
    @IsString()
    replacedSequence?: string

    @IsOptional()
    @IsString()
    replacementSequence?: string

    @IsOptional()
    @IsNumber()
    start?: number

  }
  export class MolecularSequenceRelativeDto implements MolecularSequenceRelative {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    coordinateSystem: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MolecularSequenceRelativeEditDto)
    edit?: MolecularSequenceRelativeEdit[]

    @IsOptional()
    @IsNumber()
    ordinalPosition?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    sequenceRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => MolecularSequenceRelativeStartingSequenceDto)
    startingSequence?: MolecularSequenceRelativeStartingSequence

  }
  export class MolecularSequenceDto implements MolecularSequence {
    @IsNotEmpty()
    @IsIn(["MolecularSequence"])
    resourceType: "MolecularSequence"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    device?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    focus?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AttachmentDto)
    formatted?: Attachment[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsString()
    literal?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    performer?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MolecularSequenceRelativeDto)
    relative?: MolecularSequenceRelative[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    specimen?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

    @IsNotEmpty()
    @IsIn(["aa", "dna", "rna"])
    type: "aa" | "dna" | "rna"

  }
  export class NamingSystemUniqueIdDto implements NamingSystemUniqueId {
    @IsNotEmpty()
    @IsBoolean()
    authoritative: boolean

    @IsOptional()
    @IsString()
    comment?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsNotEmpty()
    @IsBoolean()
    preferred: boolean

    @IsNotEmpty()
    @IsIn(["other", "uri", "oid", "uuid", "iri-stem", "v2csmnemonic"])
    type: "other" | "uri" | "oid" | "uuid" | "iri-stem" | "v2csmnemonic"

    @IsNotEmpty()
    @IsString()
    value: string

  }
  export class NamingSystemDto implements NamingSystem {
    @IsNotEmpty()
    @IsIn(["NamingSystem"])
    resourceType: "NamingSystem"

    @IsOptional()
    @IsString()
    approvalDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    author?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    copyrightLabel?: string

    @IsNotEmpty()
    @IsString()
    date: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    editor?: ContactDetail[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    endorser?: ContactDetail[]

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsNotEmpty()
    @IsIn(["codesystem", "identifier", "root"])
    kind: "codesystem" | "identifier" | "root"

    @IsOptional()
    @IsString()
    lastReviewDate?: string

    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    relatedArtifact?: RelatedArtifact[]

    @IsOptional()
    @IsString()
    responsible?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    reviewer?: ContactDetail[]

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    topic?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => NamingSystemUniqueIdDto)
    uniqueId: NamingSystemUniqueId[]

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsString()
    usage?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @IsString()
    versionAlgorithmString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    versionAlgorithmCoding?: Coding

  }
  export class NutritionIntakeConsumedItemDto implements NutritionIntakeConsumedItem {
    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    amount?: Quantity

    @IsNotEmpty()
    @IsBoolean()
    notConsumed: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    notConsumedReason?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    nutritionProduct: CodeableReference

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    rate?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    schedule?: Timing

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class NutritionIntakeIngredientLabelDto implements NutritionIntakeIngredientLabel {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => QuantityDto)
    amount: Quantity

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    nutrient: CodeableReference

  }
  export class NutritionIntakePerformerDto implements NutritionIntakePerformer {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    actor: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    function?: CodeableConcept

  }
  export class NutritionIntakeDto implements NutritionIntake {
    @IsNotEmpty()
    @IsIn(["NutritionIntake"])
    resourceType: "NutritionIntake"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => NutritionIntakeConsumedItemDto)
    consumedItem: NutritionIntakeConsumedItem[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    derivedFrom?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => NutritionIntakeIngredientLabelDto)
    ingredientLabel?: NutritionIntakeIngredientLabel[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesCanonical?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesUri?: string[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    location?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    occurrenceDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    occurrencePeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    partOf?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => NutritionIntakePerformerDto)
    performer?: NutritionIntakePerformer[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    reason?: CodeableReference[]

    @IsOptional()
    @IsString()
    recorded?: string

    @IsNotEmpty()
    @IsBoolean()
    reportedBoolean: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    reportedReference?: Reference

    @IsNotEmpty()
    @IsIn(["unknown", "entered-in-error", "on-hold", "in-progress", "completed", "preparation", "not-done", "stopped"])
    status: "unknown" | "entered-in-error" | "on-hold" | "in-progress" | "completed" | "preparation" | "not-done" | "stopped"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    statusReason?: CodeableConcept[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

  }
  export class NutritionOrderOralDietScheduleDto implements NutritionOrderOralDietSchedule {
    @IsNotEmpty()
    @IsBoolean()
    asNeeded: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    asNeededFor?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TimingDto)
    timing?: Timing[]

  }
  export class NutritionOrderOralDietNutrientDto implements NutritionOrderOralDietNutrient {
    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    amount?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    modifier?: CodeableConcept

  }
  export class NutritionOrderOralDietTextureDto implements NutritionOrderOralDietTexture {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    foodType?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    modifier?: CodeableConcept

  }
  export class NutritionOrderOralDietDto implements NutritionOrderOralDiet {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    fluidConsistencyType?: CodeableConcept[]

    @IsOptional()
    @IsString()
    instruction?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => NutritionOrderOralDietNutrientDto)
    nutrient?: NutritionOrderOralDietNutrient[]

    @IsOptional()
    @ValidateNested()
    @Type(() => NutritionOrderOralDietScheduleDto)
    schedule?: NutritionOrderOralDietSchedule

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => NutritionOrderOralDietTextureDto)
    texture?: NutritionOrderOralDietTexture[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

  }
  export class NutritionOrderSupplementScheduleDto implements NutritionOrderSupplementSchedule {
    @IsNotEmpty()
    @IsBoolean()
    asNeeded: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    asNeededFor?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TimingDto)
    timing?: Timing[]

  }
  export class NutritionOrderSupplementDto implements NutritionOrderSupplement {
    @IsOptional()
    @IsString()
    instruction?: string

    @IsOptional()
    @IsString()
    productName?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => NutritionOrderSupplementScheduleDto)
    schedule?: NutritionOrderSupplementSchedule

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    type?: CodeableReference

  }
  export class NutritionOrderEnteralFormulaAdditiveDto implements NutritionOrderEnteralFormulaAdditive {
    @IsOptional()
    @IsString()
    productName?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    type?: CodeableReference

  }
  export class NutritionOrderEnteralFormulaAdministrationScheduleDto implements NutritionOrderEnteralFormulaAdministrationSchedule {
    @IsNotEmpty()
    @IsBoolean()
    asNeeded: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    asNeededFor?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TimingDto)
    timing?: Timing[]

  }
  export class NutritionOrderEnteralFormulaAdministrationDto implements NutritionOrderEnteralFormulaAdministration {
    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    rateQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    rateRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => NutritionOrderEnteralFormulaAdministrationScheduleDto)
    schedule?: NutritionOrderEnteralFormulaAdministrationSchedule

  }
  export class NutritionOrderEnteralFormulaDto implements NutritionOrderEnteralFormula {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => NutritionOrderEnteralFormulaAdditiveDto)
    additive?: NutritionOrderEnteralFormulaAdditive[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => NutritionOrderEnteralFormulaAdministrationDto)
    administration?: NutritionOrderEnteralFormulaAdministration[]

    @IsOptional()
    @IsString()
    administrationInstruction?: string

    @IsOptional()
    @IsString()
    baseFormulaProductName?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    baseFormulaType?: CodeableReference

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    caloricDensity?: Quantity

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    deliveryDevice?: CodeableReference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    maxVolumeToDeliver?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    routeOfAdministration?: CodeableConcept

  }
  export class NutritionOrderDto implements NutritionOrder {
    @IsNotEmpty()
    @IsIn(["NutritionOrder"])
    resourceType: "NutritionOrder"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    allergyIntolerance?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsNotEmpty()
    @IsString()
    dateTime: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => NutritionOrderEnteralFormulaDto)
    enteralFormula?: NutritionOrderEnteralFormula

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    excludeFoodModifier?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    foodPreferenceModifier?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    groupIdentifier?: Identifier

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiates?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesCanonical?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesUri?: string[]

    @IsNotEmpty()
    @IsIn(["proposal", "plan", "directive", "order", "original-order", "reflex-order", "filler-order", "instance-order", "option"])
    intent: "proposal" | "plan" | "directive" | "order" | "original-order" | "reflex-order" | "filler-order" | "instance-order" | "option"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => NutritionOrderOralDietDto)
    oralDiet?: NutritionOrderOralDiet

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    orderer?: Reference

    @IsNotEmpty()
    @IsBoolean()
    outsideFoodAllowed: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    performer?: CodeableReference[]

    @IsNotEmpty()
    @IsIn(["routine", "urgent", "asap", "stat"])
    priority: "routine" | "urgent" | "asap" | "stat"

    @IsNotEmpty()
    @IsIn(["draft", "active", "unknown", "entered-in-error", "on-hold", "completed", "revoked"])
    status: "draft" | "active" | "unknown" | "entered-in-error" | "on-hold" | "completed" | "revoked"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => NutritionOrderSupplementDto)
    supplement?: NutritionOrderSupplement[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    supportingInformation?: Reference[]

  }
  export class NutritionProductNutrientDto implements NutritionProductNutrient {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RatioDto)
    amount?: Ratio[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    item?: CodeableReference

  }
  export class NutritionProductIngredientDto implements NutritionProductIngredient {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RatioDto)
    amount?: Ratio[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    item: CodeableReference

  }
  export class NutritionProductCharacteristicDto implements NutritionProductCharacteristic {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @IsString()
    valueBase64Binary?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

  }
  export class NutritionProductInstanceDto implements NutritionProductInstance {
    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    biologicalSourceEvent?: Identifier

    @IsOptional()
    @IsString()
    expiry?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsString()
    lotNumber?: string

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @IsString()
    useBy?: string

  }
  export class NutritionProductDto implements NutritionProduct {
    @IsNotEmpty()
    @IsIn(["NutritionProduct"])
    resourceType: "NutritionProduct"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => NutritionProductCharacteristicDto)
    characteristic?: NutritionProductCharacteristic[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => NutritionProductIngredientDto)
    ingredient?: NutritionProductIngredient[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => NutritionProductInstanceDto)
    instance?: NutritionProductInstance[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    knownAllergen?: CodeableReference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    manufacturer?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => NutritionProductNutrientDto)
    nutrient?: NutritionProductNutrient[]

    @IsNotEmpty()
    @IsIn(["active", "inactive", "entered-in-error"])
    status: "active" | "inactive" | "entered-in-error"

  }
  export class ObservationTriggeredByDto implements ObservationTriggeredBy {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    observation: Reference

    @IsOptional()
    @IsString()
    reason?: string

    @IsNotEmpty()
    @IsIn(["reflex", "repeat", "re-run"])
    type: "reflex" | "repeat" | "re-run"

  }
  export class ObservationReferenceRangeDto implements ObservationReferenceRange {
    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    age?: Range

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    appliesTo?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    high?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    low?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    normalValue?: CodeableConcept

    @IsOptional()
    @IsString()
    text?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class ObservationComponentDto implements ObservationComponent {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    dataAbsentReason?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    interpretation?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ObservationReferenceRangeDto)
    referenceRange?: ObservationReferenceRange[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @IsString()
    valueString?: string

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    valueRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => SampledDataDto)
    valueSampledData?: SampledData

    @IsOptional()
    @IsString()
    valueTime?: string

    @IsOptional()
    @IsString()
    valueDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    valuePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

  }
  export class ObservationDto implements Observation {
    @IsNotEmpty()
    @IsIn(["Observation"])
    resourceType: "Observation"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    bodySite?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    bodyStructure?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ObservationComponentDto)
    component?: ObservationComponent[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    dataAbsentReason?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    derivedFrom?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    device?: Reference

    @IsOptional()
    @IsString()
    effectiveDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    effectiveTiming?: Timing

    @IsOptional()
    @IsString()
    effectiveInstant?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    focus?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    hasMember?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsString()
    instantiatesCanonical?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    instantiatesReference?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    interpretation?: CodeableConcept[]

    @IsOptional()
    @IsString()
    issued?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    method?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    partOf?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    performer?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ObservationReferenceRangeDto)
    referenceRange?: ObservationReferenceRange[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    specimen?: Reference

    @IsNotEmpty()
    @IsIn(["unknown", "entered-in-error", "cancelled", "registered", "preliminary", "final", "amended", "corrected"])
    status: "unknown" | "entered-in-error" | "cancelled" | "registered" | "preliminary" | "final" | "amended" | "corrected"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ObservationTriggeredByDto)
    triggeredBy?: ObservationTriggeredBy[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @IsString()
    valueString?: string

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    valueRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => SampledDataDto)
    valueSampledData?: SampledData

    @IsOptional()
    @IsString()
    valueTime?: string

    @IsOptional()
    @IsString()
    valueDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    valuePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

  }
  export class ObservationDefinitionQualifiedValueDto implements ObservationDefinitionQualifiedValue {
    @IsOptional()
    @IsString()
    abnormalCodedValueSet?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    age?: Range

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    appliesTo?: CodeableConcept[]

    @IsOptional()
    @IsString()
    condition?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    context?: CodeableConcept

    @IsOptional()
    @IsString()
    criticalCodedValueSet?: string

    @IsNotEmpty()
    @IsIn(["other", "unknown", "male", "female"])
    gender: "other" | "unknown" | "male" | "female"

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    gestationalAge?: Range

    @IsOptional()
    @IsString()
    normalCodedValueSet?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    range?: Range

    @IsNotEmpty()
    @IsIn(["critical", "reference", "absolute"])
    rangeCategory: "critical" | "reference" | "absolute"

    @IsOptional()
    @IsString()
    validCodedValueSet?: string

  }
  export class ObservationDefinitionComponentDto implements ObservationDefinitionComponent {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsOptional()
    @IsArray()
    @IsIn(["string", "boolean", "integer", "dateTime", "Quantity", "CodeableConcept", "Range", "Ratio", "SampledData", "time", "Period"], { each: true })
    permittedDataType?: ("string" | "boolean" | "integer" | "dateTime" | "Quantity" | "CodeableConcept" | "Range" | "Ratio" | "SampledData" | "time" | "Period")[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    permittedUnit?: Coding[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ObservationDefinitionQualifiedValueDto)
    qualifiedValue?: ObservationDefinitionQualifiedValue[]

  }
  export class ObservationDefinitionDto implements ObservationDefinition {
    @IsNotEmpty()
    @IsIn(["ObservationDefinition"])
    resourceType: "ObservationDefinition"

    @IsOptional()
    @IsString()
    approvalDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    bodySite?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ObservationDefinitionComponentDto)
    component?: ObservationDefinitionComponent[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    copyrightLabel?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    derivedFromCanonical?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    derivedFromUri?: string[]

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    device?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    hasMember?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    lastReviewDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    method?: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    multipleResultsAllowed: boolean

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    performerType?: CodeableConcept

    @IsOptional()
    @IsArray()
    @IsIn(["string", "boolean", "integer", "dateTime", "Quantity", "CodeableConcept", "Range", "Ratio", "SampledData", "time", "Period"], { each: true })
    permittedDataType?: ("string" | "boolean" | "integer" | "dateTime" | "Quantity" | "CodeableConcept" | "Range" | "Ratio" | "SampledData" | "time" | "Period")[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    permittedUnit?: Coding[]

    @IsOptional()
    @IsString()
    preferredReportName?: string

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ObservationDefinitionQualifiedValueDto)
    qualifiedValue?: ObservationDefinitionQualifiedValue[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    specimen?: Reference[]

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    subject?: CodeableConcept[]

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @IsString()
    versionAlgorithmString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    versionAlgorithmCoding?: Coding

  }
  export class OperationDefinitionParameterBindingDto implements OperationDefinitionParameterBinding {
    @IsNotEmpty()
    @IsIn(["required", "extensible", "preferred", "example"])
    strength: "required" | "extensible" | "preferred" | "example"

    @IsNotEmpty()
    @IsString()
    valueSet: string

  }
  export class OperationDefinitionParameterReferencedFromDto implements OperationDefinitionParameterReferencedFrom {
    @IsNotEmpty()
    @IsString()
    source: string

    @IsOptional()
    @IsString()
    sourceId?: string

  }
  export class OperationDefinitionParameterDto implements OperationDefinitionParameter {
    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    allowedType?: string[]

    @IsOptional()
    @ValidateNested()
    @Type(() => OperationDefinitionParameterBindingDto)
    binding?: OperationDefinitionParameterBinding

    @IsOptional()
    @IsString()
    documentation?: string

    @IsNotEmpty()
    @IsString()
    max: string

    @IsNotEmpty()
    @IsNumber()
    min: number

    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => OperationDefinitionParameterDto)
    part?: OperationDefinitionParameter[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => OperationDefinitionParameterReferencedFromDto)
    referencedFrom?: OperationDefinitionParameterReferencedFrom[]

    @IsOptional()
    @IsArray()
    @IsIn(["type", "system", "instance"], { each: true })
    scope?: ("type" | "system" | "instance")[]

    @IsNotEmpty()
    @IsIn(["string", "number", "date", "token", "reference", "composite", "quantity", "uri", "special"])
    searchType: "string" | "number" | "date" | "token" | "reference" | "composite" | "quantity" | "uri" | "special"

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    targetProfile?: string[]

    @IsOptional()
    @IsString()
    type?: string

    @IsNotEmpty()
    @IsIn(["in", "out"])
    use: "in" | "out"

  }
  export class OperationDefinitionOverloadDto implements OperationDefinitionOverload {
    @IsOptional()
    @IsString()
    comment?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    parameterName?: string[]

  }
  export class OperationDefinitionDto implements OperationDefinition {
    @IsNotEmpty()
    @IsIn(["OperationDefinition"])
    resourceType: "OperationDefinition"

    @IsNotEmpty()
    @IsBoolean()
    affectsState: boolean

    @IsOptional()
    @IsString()
    base?: string

    @IsNotEmpty()
    @IsString()
    code: string

    @IsOptional()
    @IsString()
    comment?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    copyrightLabel?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsString()
    inputProfile?: string

    @IsNotEmpty()
    @IsBoolean()
    instance: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsNotEmpty()
    @IsIn(["operation", "query"])
    kind: "operation" | "query"

    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @IsString()
    outputProfile?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => OperationDefinitionOverloadDto)
    overload?: OperationDefinitionOverload[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => OperationDefinitionParameterDto)
    parameter?: OperationDefinitionParameter[]

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    resource?: string[]

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsNotEmpty()
    @IsBoolean()
    system: boolean

    @IsOptional()
    @IsString()
    title?: string

    @IsNotEmpty()
    @IsBoolean()
    type: boolean

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @IsString()
    versionAlgorithmString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    versionAlgorithmCoding?: Coding

  }
  export class OperationOutcomeIssueDto implements OperationOutcomeIssue {
    @IsNotEmpty()
    @IsString()
    code: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    details?: CodeableConcept

    @IsOptional()
    @IsString()
    diagnostics?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    expression?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    location?: string[]

    @IsNotEmpty()
    @IsIn(["error", "warning", "success", "fatal", "information"])
    severity: "error" | "warning" | "success" | "fatal" | "information"

  }
  export class OperationOutcomeDto implements OperationOutcome {
    @IsNotEmpty()
    @IsIn(["OperationOutcome"])
    resourceType: "OperationOutcome"

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => OperationOutcomeIssueDto)
    issue: OperationOutcomeIssue[]

  }
  export class OrganizationQualificationDto implements OrganizationQualification {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    issuer?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

  }
  export class OrganizationDto implements Organization {
    @IsNotEmpty()
    @IsIn(["Organization"])
    resourceType: "Organization"

    @IsNotEmpty()
    @IsBoolean()
    active: boolean

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    alias?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExtendedContactDetailDto)
    contact?: ExtendedContactDetail[]

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    endpoint?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    partOf?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => OrganizationQualificationDto)
    qualification?: OrganizationQualification[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

  }
  export class OrganizationAffiliationDto implements OrganizationAffiliation {
    @IsNotEmpty()
    @IsIn(["OrganizationAffiliation"])
    resourceType: "OrganizationAffiliation"

    @IsNotEmpty()
    @IsBoolean()
    active: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExtendedContactDetailDto)
    contact?: ExtendedContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    endpoint?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    healthcareService?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    location?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    network?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    organization?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    participatingOrganization?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    specialty?: CodeableConcept[]

  }
  export class PackagedProductDefinitionLegalStatusOfSupplyDto implements PackagedProductDefinitionLegalStatusOfSupply {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept

  }
  export class PackagedProductDefinitionPackagingPropertyDto implements PackagedProductDefinitionPackagingProperty {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @IsString()
    valueDate?: string

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

  }
  export class PackagedProductDefinitionPackagingContainedItemDto implements PackagedProductDefinitionPackagingContainedItem {
    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    amount?: Quantity

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    item: CodeableReference

  }
  export class PackagedProductDefinitionPackagingDto implements PackagedProductDefinitionPackaging {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    alternateMaterial?: CodeableConcept[]

    @IsNotEmpty()
    @IsBoolean()
    componentPart: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PackagedProductDefinitionPackagingContainedItemDto)
    containedItem?: PackagedProductDefinitionPackagingContainedItem[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    manufacturer?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    material?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PackagedProductDefinitionPackagingDto)
    packaging?: PackagedProductDefinitionPackaging[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PackagedProductDefinitionPackagingPropertyDto)
    property?: PackagedProductDefinitionPackagingProperty[]

    @IsOptional()
    @IsNumber()
    quantity?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ProductShelfLifeDto)
    shelfLifeStorage?: ProductShelfLife[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class PackagedProductDefinitionDto implements PackagedProductDefinition {
    @IsNotEmpty()
    @IsIn(["PackagedProductDefinition"])
    resourceType: "PackagedProductDefinition"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    attachedDocument?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PackagedProductDefinitionPackagingPropertyDto)
    characteristic?: PackagedProductDefinitionPackagingProperty[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => QuantityDto)
    containedItemQuantity?: Quantity[]

    @IsNotEmpty()
    @IsBoolean()
    copackagedIndicator: boolean

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PackagedProductDefinitionLegalStatusOfSupplyDto)
    legalStatusOfSupply?: PackagedProductDefinitionLegalStatusOfSupply[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    manufacturer?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MarketingStatusDto)
    marketingStatus?: MarketingStatus[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    packageFor?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PackagedProductDefinitionPackagingDto)
    packaging?: PackagedProductDefinitionPackaging

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    status?: CodeableConcept

    @IsOptional()
    @IsString()
    statusDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class ParametersParameterDto implements ParametersParameter {
    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ParametersParameterDto)
    part?: ParametersParameter[]

    @IsNotEmpty()
    resource: Account | ActivityDefinition | ActorDefinition | AdministrableProductDefinition | AdverseEvent | AllergyIntolerance | Appointment | AppointmentResponse | ArtifactAssessment | AuditEvent | Basic | Binary | BiologicallyDerivedProduct | BiologicallyDerivedProductDispense | BodyStructure | Bundle<FhirResource> | CapabilityStatement | CarePlan | CareTeam | ChargeItem | ChargeItemDefinition | Citation | Claim | ClaimResponse | ClinicalImpression | ClinicalUseDefinition | CodeSystem | Communication | CommunicationRequest | CompartmentDefinition | Composition | ConceptMap | Condition | ConditionDefinition | Consent | Contract | Coverage | CoverageEligibilityRequest | CoverageEligibilityResponse | DetectedIssue | Device | DeviceAssociation | DeviceDefinition | DeviceDispense | DeviceMetric | DeviceRequest | DeviceUsage | DiagnosticReport | DocumentReference | Encounter | EncounterHistory | Endpoint | EnrollmentRequest | EnrollmentResponse | EpisodeOfCare | EventDefinition | Evidence | EvidenceReport | EvidenceVariable | ExampleScenario | ExplanationOfBenefit | FamilyMemberHistory | Flag | FormularyItem | GenomicStudy | Goal | GraphDefinition | Group | GuidanceResponse | HealthcareService | ImagingSelection | ImagingStudy | Immunization | ImmunizationEvaluation | ImmunizationRecommendation | ImplementationGuide | Ingredient | InsurancePlan | InventoryItem | InventoryReport | Invoice | Library | Linkage | List | Location | ManufacturedItemDefinition | Measure | MeasureReport | Medication | MedicationAdministration | MedicationDispense | MedicationKnowledge | MedicationRequest | MedicationStatement | MedicinalProductDefinition | MessageDefinition | MessageHeader | MolecularSequence | NamingSystem | NutritionIntake | NutritionOrder | NutritionProduct | Observation | ObservationDefinition | OperationDefinition | OperationOutcome | Organization | OrganizationAffiliation | PackagedProductDefinition | Parameters | Patient | PaymentNotice | PaymentReconciliation | Permission | Person | PlanDefinition | Practitioner | PractitionerRole | Procedure | Provenance | Questionnaire | QuestionnaireResponse | RegulatedAuthorization | RelatedPerson | RequestOrchestration | Requirements | ResearchStudy | ResearchSubject | RiskAssessment | Schedule | SearchParameter | ServiceRequest | Slot | Specimen | SpecimenDefinition | StructureDefinition | StructureMap | Subscription | SubscriptionStatus | SubscriptionTopic | Substance | SubstanceDefinition | SubstanceNucleicAcid | SubstancePolymer | SubstanceProtein | SubstanceReferenceInformation | SubstanceSourceMaterial | SupplyDelivery | SupplyRequest | Task | TerminologyCapabilities | TestPlan | TestReport | TestScript | Transport | ValueSet | VerificationResult | VisionPrescription

    @IsOptional()
    @IsString()
    valueBase64Binary?: string

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsString()
    valueCanonical?: string

    @IsOptional()
    @IsString()
    valueCode?: string

    @IsOptional()
    @IsString()
    valueDate?: string

    @IsOptional()
    @IsString()
    valueDateTime?: string

    @IsOptional()
    @IsNumber()
    valueDecimal?: number

    @IsOptional()
    @IsString()
    valueId?: string

    @IsOptional()
    @IsString()
    valueInstant?: string

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsOptional()
    @IsString()
    valueInteger64?: string

    @IsOptional()
    @IsString()
    valueMarkdown?: string

    @IsOptional()
    @IsString()
    valueOid?: string

    @IsOptional()
    @IsNumber()
    valuePositiveInt?: number

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @IsString()
    valueTime?: string

    @IsOptional()
    @IsNumber()
    valueUnsignedInt?: number

    @IsOptional()
    @IsString()
    valueUri?: string

    @IsOptional()
    @IsString()
    valueUrl?: string

    @IsOptional()
    @IsString()
    valueUuid?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    valueAddress?: Address

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    valueAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => AnnotationDto)
    valueAnnotation?: Annotation

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    valueCodeableReference?: CodeableReference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    valueCoding?: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactPointDto)
    valueContactPoint?: ContactPoint

    @IsOptional()
    @ValidateNested()
    @Type(() => CountDto)
    valueCount?: Count

    @IsOptional()
    @ValidateNested()
    @Type(() => DistanceDto)
    valueDistance?: Distance

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    valueDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => HumanNameDto)
    valueHumanName?: HumanName

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    valueIdentifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    valueMoney?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    valuePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    valueRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioRangeDto)
    valueRatioRange?: RatioRange

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => SampledDataDto)
    valueSampledData?: SampledData

    @IsOptional()
    @ValidateNested()
    @Type(() => SignatureDto)
    valueSignature?: Signature

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    valueTiming?: Timing

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactDetailDto)
    valueContactDetail?: ContactDetail

    @IsOptional()
    @ValidateNested()
    @Type(() => DataRequirementDto)
    valueDataRequirement?: DataRequirement

    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    valueExpression?: Expression

    @IsOptional()
    @ValidateNested()
    @Type(() => ParameterDefinitionDto)
    valueParameterDefinition?: ParameterDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => RelatedArtifactDto)
    valueRelatedArtifact?: RelatedArtifact

    @IsOptional()
    @ValidateNested()
    @Type(() => TriggerDefinitionDto)
    valueTriggerDefinition?: TriggerDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => UsageContextDto)
    valueUsageContext?: UsageContext

    @IsOptional()
    @ValidateNested()
    @Type(() => AvailabilityDto)
    valueAvailability?: Availability

    @IsOptional()
    @ValidateNested()
    @Type(() => ExtendedContactDetailDto)
    valueExtendedContactDetail?: ExtendedContactDetail

    @IsOptional()
    @ValidateNested()
    @Type(() => DosageDto)
    valueDosage?: Dosage

    @IsOptional()
    @ValidateNested()
    @Type(() => MetaDto)
    valueMeta?: Meta

  }
  export class ParametersDto implements Parameters {
    @IsNotEmpty()
    @IsIn(["Parameters"])
    resourceType: "Parameters"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ParametersParameterDto)
    parameter?: ParametersParameter[]

  }
  export class PatientContactDto implements PatientContact {
    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    address?: Address

    @IsNotEmpty()
    @IsIn(["other", "unknown", "male", "female"])
    gender: "other" | "unknown" | "male" | "female"

    @IsOptional()
    @ValidateNested()
    @Type(() => HumanNameDto)
    name?: HumanName

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    organization?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    relationship?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactPointDto)
    telecom?: ContactPoint[]

  }
  export class PatientCommunicationDto implements PatientCommunication {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    language: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    preferred: boolean

  }
  export class PatientLinkDto implements PatientLink {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    other: Reference

    @IsNotEmpty()
    @IsIn(["replaces", "replaced-by", "refer", "seealso"])
    type: "replaces" | "replaced-by" | "refer" | "seealso"

  }
  export class PatientDto implements Patient {
    @IsNotEmpty()
    @IsIn(["Patient"])
    resourceType: "Patient"

    @IsNotEmpty()
    @IsBoolean()
    active: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AddressDto)
    address?: Address[]

    @IsOptional()
    @IsString()
    birthDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PatientCommunicationDto)
    communication?: PatientCommunication[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PatientContactDto)
    contact?: PatientContact[]

    @IsNotEmpty()
    @IsBoolean()
    deceasedBoolean: boolean

    @IsOptional()
    @IsString()
    deceasedDateTime?: string

    @IsNotEmpty()
    @IsIn(["other", "unknown", "male", "female"])
    gender: "other" | "unknown" | "male" | "female"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    generalPractitioner?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PatientLinkDto)
    link?: PatientLink[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    managingOrganization?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    maritalStatus?: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    multipleBirthBoolean: boolean

    @IsOptional()
    @IsNumber()
    multipleBirthInteger?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => HumanNameDto)
    name?: HumanName[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AttachmentDto)
    photo?: Attachment[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactPointDto)
    telecom?: ContactPoint[]

  }
  export class PaymentNoticeDto implements PaymentNotice {
    @IsNotEmpty()
    @IsIn(["PaymentNotice"])
    resourceType: "PaymentNotice"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => MoneyDto)
    amount: Money

    @IsNotEmpty()
    @IsString()
    created: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    payee?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    payment?: Reference

    @IsOptional()
    @IsString()
    paymentDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    paymentStatus?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    recipient: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    reporter?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    request?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    response?: Reference

    @IsNotEmpty()
    @IsIn(["draft", "active", "entered-in-error", "cancelled"])
    status: "draft" | "active" | "entered-in-error" | "cancelled"

  }
  export class PaymentReconciliationAllocationDto implements PaymentReconciliationAllocation {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    account?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    amount?: Money

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    payee?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    predecessor?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    response?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    responsible?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    submitter?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    target?: Reference

    @IsOptional()
    @IsString()
    targetItemString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    targetItemIdentifier?: Identifier

    @IsOptional()
    @IsNumber()
    targetItemPositiveInt?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class PaymentReconciliationProcessNoteDto implements PaymentReconciliationProcessNote {
    @IsOptional()
    @IsString()
    text?: string

    @IsNotEmpty()
    @IsIn(["display", "print", "printoper"])
    type: "display" | "print" | "printoper"

  }
  export class PaymentReconciliationDto implements PaymentReconciliation {
    @IsNotEmpty()
    @IsIn(["PaymentReconciliation"])
    resourceType: "PaymentReconciliation"

    @IsOptional()
    @IsString()
    accountNumber?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PaymentReconciliationAllocationDto)
    allocation?: PaymentReconciliationAllocation[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => MoneyDto)
    amount: Money

    @IsOptional()
    @IsString()
    authorization?: string

    @IsOptional()
    @IsString()
    cardBrand?: string

    @IsNotEmpty()
    @IsString()
    created: string

    @IsNotEmpty()
    @IsString()
    date: string

    @IsOptional()
    @IsString()
    disposition?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    enterer?: Reference

    @IsOptional()
    @IsString()
    expirationDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    formCode?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    issuerType?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    kind?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    location?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    method?: CodeableConcept

    @IsNotEmpty()
    @IsIn(["error", "queued", "complete", "partial"])
    outcome: "error" | "queued" | "complete" | "partial"

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    paymentIdentifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    paymentIssuer?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PaymentReconciliationProcessNoteDto)
    processNote?: PaymentReconciliationProcessNote[]

    @IsOptional()
    @IsString()
    processor?: string

    @IsOptional()
    @IsString()
    referenceNumber?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    request?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    requestor?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    returnedAmount?: Money

    @IsNotEmpty()
    @IsIn(["draft", "active", "entered-in-error", "cancelled"])
    status: "draft" | "active" | "entered-in-error" | "cancelled"

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    tenderedAmount?: Money

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class PermissionJustificationDto implements PermissionJustification {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    basis?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    evidence?: Reference[]

  }
  export class PermissionRuleDataResourceDto implements PermissionRuleDataResource {
    @IsNotEmpty()
    @IsIn(["instance", "related", "dependents", "authoredby"])
    meaning: "instance" | "related" | "dependents" | "authoredby"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    reference: Reference

  }
  export class PermissionRuleDataDto implements PermissionRuleData {
    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    expression?: Expression

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PeriodDto)
    period?: Period[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PermissionRuleDataResourceDto)
    resource?: PermissionRuleDataResource[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    security?: Coding[]

  }
  export class PermissionRuleActivityDto implements PermissionRuleActivity {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    action?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    actor?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    purpose?: CodeableConcept[]

  }
  export class PermissionRuleDto implements PermissionRule {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PermissionRuleActivityDto)
    activity?: PermissionRuleActivity[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PermissionRuleDataDto)
    data?: PermissionRuleData[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    limit?: CodeableConcept[]

    @IsNotEmpty()
    @IsIn(["deny", "permit"])
    type: "deny" | "permit"

  }
  export class PermissionDto implements Permission {
    @IsNotEmpty()
    @IsIn(["Permission"])
    resourceType: "Permission"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    asserter?: Reference

    @IsNotEmpty()
    @IsIn(["deny-overrides", "permit-overrides", "ordered-deny-overrides", "ordered-permit-overrides", "deny-unless-permit", "permit-unless-deny"])
    combining: "deny-overrides" | "permit-overrides" | "ordered-deny-overrides" | "ordered-permit-overrides" | "deny-unless-permit" | "permit-unless-deny"

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    date?: string[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PermissionJustificationDto)
    justification?: PermissionJustification

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PermissionRuleDto)
    rule?: PermissionRule[]

    @IsNotEmpty()
    @IsIn(["draft", "active", "entered-in-error", "rejected"])
    status: "draft" | "active" | "entered-in-error" | "rejected"

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    validity?: Period

  }
  export class PersonCommunicationDto implements PersonCommunication {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    language: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    preferred: boolean

  }
  export class PersonLinkDto implements PersonLink {
    @IsNotEmpty()
    @IsIn(["level1", "level2", "level3", "level4"])
    assurance: "level1" | "level2" | "level3" | "level4"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    target: Reference

  }
  export class PersonDto implements Person {
    @IsNotEmpty()
    @IsIn(["Person"])
    resourceType: "Person"

    @IsNotEmpty()
    @IsBoolean()
    active: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AddressDto)
    address?: Address[]

    @IsOptional()
    @IsString()
    birthDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PersonCommunicationDto)
    communication?: PersonCommunication[]

    @IsNotEmpty()
    @IsBoolean()
    deceasedBoolean: boolean

    @IsOptional()
    @IsString()
    deceasedDateTime?: string

    @IsNotEmpty()
    @IsIn(["other", "unknown", "male", "female"])
    gender: "other" | "unknown" | "male" | "female"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PersonLinkDto)
    link?: PersonLink[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    managingOrganization?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    maritalStatus?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => HumanNameDto)
    name?: HumanName[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AttachmentDto)
    photo?: Attachment[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactPointDto)
    telecom?: ContactPoint[]

  }
  export class PlanDefinitionGoalTargetDto implements PlanDefinitionGoalTarget {
    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    detailQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    detailRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    detailCodeableConcept?: CodeableConcept

    @IsOptional()
    @IsString()
    detailString?: string

    @IsNotEmpty()
    @IsBoolean()
    detailBoolean: boolean

    @IsOptional()
    @IsNumber()
    detailInteger?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    detailRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    due?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    measure?: CodeableConcept

  }
  export class PlanDefinitionGoalDto implements PlanDefinitionGoal {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    addresses?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    description: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    documentation?: RelatedArtifact[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    priority?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    start?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PlanDefinitionGoalTargetDto)
    target?: PlanDefinitionGoalTarget[]

  }
  export class PlanDefinitionActorOptionDto implements PlanDefinitionActorOption {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    role?: CodeableConcept

    @IsNotEmpty()
    @IsIn(["careteam", "device", "group", "healthcareservice", "location", "organization", "patient", "practitioner", "practitionerrole", "relatedperson"])
    type: "careteam" | "device" | "group" | "healthcareservice" | "location" | "organization" | "patient" | "practitioner" | "practitionerrole" | "relatedperson"

    @IsOptional()
    @IsString()
    typeCanonical?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    typeReference?: Reference

  }
  export class PlanDefinitionActorDto implements PlanDefinitionActor {
    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PlanDefinitionActorOptionDto)
    option: PlanDefinitionActorOption[]

    @IsOptional()
    @IsString()
    title?: string

  }
  export class PlanDefinitionActionConditionDto implements PlanDefinitionActionCondition {
    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    expression?: Expression

    @IsNotEmpty()
    @IsIn(["applicability", "start", "stop"])
    kind: "applicability" | "start" | "stop"

  }
  export class PlanDefinitionActionInputDto implements PlanDefinitionActionInput {
    @IsOptional()
    @IsString()
    relatedData?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => DataRequirementDto)
    requirement?: DataRequirement

    @IsOptional()
    @IsString()
    title?: string

  }
  export class PlanDefinitionActionOutputDto implements PlanDefinitionActionOutput {
    @IsOptional()
    @IsString()
    relatedData?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => DataRequirementDto)
    requirement?: DataRequirement

    @IsOptional()
    @IsString()
    title?: string

  }
  export class PlanDefinitionActionRelatedActionDto implements PlanDefinitionActionRelatedAction {
    @IsNotEmpty()
    @IsIn(["before", "before-start", "before-end", "concurrent", "concurrent-with-start", "concurrent-with-end", "after", "after-start", "after-end"])
    endRelationship: "before" | "before-start" | "before-end" | "concurrent" | "concurrent-with-start" | "concurrent-with-end" | "after" | "after-start" | "after-end"

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    offsetDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    offsetRange?: Range

    @IsNotEmpty()
    @IsIn(["before", "before-start", "before-end", "concurrent", "concurrent-with-start", "concurrent-with-end", "after", "after-start", "after-end"])
    relationship: "before" | "before-start" | "before-end" | "concurrent" | "concurrent-with-start" | "concurrent-with-end" | "after" | "after-start" | "after-end"

    @IsNotEmpty()
    @IsString()
    targetId: string

  }
  export class PlanDefinitionActionParticipantDto implements PlanDefinitionActionParticipant {
    @IsOptional()
    @IsString()
    actorId?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    function?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    role?: CodeableConcept

    @IsNotEmpty()
    @IsIn(["careteam", "device", "group", "healthcareservice", "location", "organization", "patient", "practitioner", "practitionerrole", "relatedperson"])
    type: "careteam" | "device" | "group" | "healthcareservice" | "location" | "organization" | "patient" | "practitioner" | "practitionerrole" | "relatedperson"

    @IsOptional()
    @IsString()
    typeCanonical?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    typeReference?: Reference

  }
  export class PlanDefinitionActionDynamicValueDto implements PlanDefinitionActionDynamicValue {
    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    expression?: Expression

    @IsOptional()
    @IsString()
    path?: string

  }
  export class PlanDefinitionActionDto implements PlanDefinitionAction {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PlanDefinitionActionDto)
    action?: PlanDefinitionAction[]

    @IsNotEmpty()
    @IsIn(["single", "multiple"])
    cardinalityBehavior: "single" | "multiple"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PlanDefinitionActionConditionDto)
    condition?: PlanDefinitionActionCondition[]

    @IsOptional()
    @IsString()
    definitionCanonical?: string

    @IsOptional()
    @IsString()
    definitionUri?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    documentation?: RelatedArtifact[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PlanDefinitionActionDynamicValueDto)
    dynamicValue?: PlanDefinitionActionDynamicValue[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    goalId?: string[]

    @IsNotEmpty()
    @IsIn(["visual-group", "logical-group", "sentence-group"])
    groupingBehavior: "visual-group" | "logical-group" | "sentence-group"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PlanDefinitionActionInputDto)
    input?: PlanDefinitionActionInput[]

    @IsOptional()
    @IsString()
    linkId?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    location?: CodeableReference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PlanDefinitionActionOutputDto)
    output?: PlanDefinitionActionOutput[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PlanDefinitionActionParticipantDto)
    participant?: PlanDefinitionActionParticipant[]

    @IsNotEmpty()
    @IsIn(["yes", "no"])
    precheckBehavior: "yes" | "no"

    @IsOptional()
    @IsString()
    prefix?: string

    @IsNotEmpty()
    @IsIn(["routine", "urgent", "asap", "stat"])
    priority: "routine" | "urgent" | "asap" | "stat"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    reason?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PlanDefinitionActionRelatedActionDto)
    relatedAction?: PlanDefinitionActionRelatedAction[]

    @IsNotEmpty()
    @IsIn(["must", "could", "must-unless-documented"])
    requiredBehavior: "must" | "could" | "must-unless-documented"

    @IsNotEmpty()
    @IsIn(["any", "all", "all-or-none", "exactly-one", "at-most-one", "one-or-more"])
    selectionBehavior: "any" | "all" | "all-or-none" | "exactly-one" | "at-most-one" | "one-or-more"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    subjectCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subjectReference?: Reference

    @IsOptional()
    @IsString()
    subjectCanonical?: string

    @IsOptional()
    @IsString()
    textEquivalent?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    timingAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    timingDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    timingRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    timingTiming?: Timing

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsString()
    transform?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TriggerDefinitionDto)
    trigger?: TriggerDefinition[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class PlanDefinitionDto implements PlanDefinition {
    @IsNotEmpty()
    @IsIn(["PlanDefinition"])
    resourceType: "PlanDefinition"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PlanDefinitionActionDto)
    action?: PlanDefinitionAction[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PlanDefinitionActorDto)
    actor?: PlanDefinitionActor[]

    @IsOptional()
    @IsString()
    approvalDate?: string

    @IsNotEmpty()
    @IsBoolean()
    asNeededBoolean: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    asNeededCodeableConcept?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    author?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    copyrightLabel?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    editor?: ContactDetail[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    endorser?: ContactDetail[]

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PlanDefinitionGoalDto)
    goal?: PlanDefinitionGoal[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    lastReviewDate?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    library?: string[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    relatedArtifact?: RelatedArtifact[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    reviewer?: ContactDetail[]

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    subjectCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subjectReference?: Reference

    @IsOptional()
    @IsString()
    subjectCanonical?: string

    @IsOptional()
    @IsString()
    subtitle?: string

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    topic?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsString()
    usage?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @IsString()
    versionAlgorithmString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    versionAlgorithmCoding?: Coding

  }
  export class PractitionerQualificationDto implements PractitionerQualification {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    issuer?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

  }
  export class PractitionerCommunicationDto implements PractitionerCommunication {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    language: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    preferred: boolean

  }
  export class PractitionerDto implements Practitioner {
    @IsNotEmpty()
    @IsIn(["Practitioner"])
    resourceType: "Practitioner"

    @IsNotEmpty()
    @IsBoolean()
    active: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AddressDto)
    address?: Address[]

    @IsOptional()
    @IsString()
    birthDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PractitionerCommunicationDto)
    communication?: PractitionerCommunication[]

    @IsNotEmpty()
    @IsBoolean()
    deceasedBoolean: boolean

    @IsOptional()
    @IsString()
    deceasedDateTime?: string

    @IsNotEmpty()
    @IsIn(["other", "unknown", "male", "female"])
    gender: "other" | "unknown" | "male" | "female"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => HumanNameDto)
    name?: HumanName[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AttachmentDto)
    photo?: Attachment[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PractitionerQualificationDto)
    qualification?: PractitionerQualification[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactPointDto)
    telecom?: ContactPoint[]

  }
  export class PractitionerRoleDto implements PractitionerRole {
    @IsNotEmpty()
    @IsIn(["PractitionerRole"])
    resourceType: "PractitionerRole"

    @IsNotEmpty()
    @IsBoolean()
    active: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AvailabilityDto)
    availability?: Availability[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    characteristic?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    communication?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExtendedContactDetailDto)
    contact?: ExtendedContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    endpoint?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    healthcareService?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    location?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    organization?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    practitioner?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    specialty?: CodeableConcept[]

  }
  export class ProcedurePerformerDto implements ProcedurePerformer {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    actor: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    function?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    onBehalfOf?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

  }
  export class ProcedureFocalDeviceDto implements ProcedureFocalDevice {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    action?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    manipulated: Reference

  }
  export class ProcedureDto implements Procedure {
    @IsNotEmpty()
    @IsIn(["Procedure"])
    resourceType: "Procedure"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    bodySite?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    complication?: CodeableReference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ProcedureFocalDeviceDto)
    focalDevice?: ProcedureFocalDevice[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    focus?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    followUp?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesCanonical?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesUri?: string[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    location?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    occurrenceDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    occurrencePeriod?: Period

    @IsOptional()
    @IsString()
    occurrenceString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    occurrenceAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    occurrenceRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    occurrenceTiming?: Timing

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    outcome?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    partOf?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ProcedurePerformerDto)
    performer?: ProcedurePerformer[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    reason?: CodeableReference[]

    @IsOptional()
    @IsString()
    recorded?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    recorder?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    report?: Reference[]

    @IsNotEmpty()
    @IsBoolean()
    reportedBoolean: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    reportedReference?: Reference

    @IsNotEmpty()
    @IsIn(["unknown", "entered-in-error", "on-hold", "in-progress", "completed", "preparation", "not-done", "stopped"])
    status: "unknown" | "entered-in-error" | "on-hold" | "in-progress" | "completed" | "preparation" | "not-done" | "stopped"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    statusReason?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    supportingInfo?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    used?: CodeableReference[]

  }
  export class ProvenanceAgentDto implements ProvenanceAgent {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    onBehalfOf?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    role?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    who: Reference

  }
  export class ProvenanceEntityDto implements ProvenanceEntity {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ProvenanceAgentDto)
    agent?: ProvenanceAgent[]

    @IsNotEmpty()
    @IsIn(["source", "revision", "quotation", "instantiates", "removal"])
    role: "source" | "revision" | "quotation" | "instantiates" | "removal"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    what: Reference

  }
  export class ProvenanceDto implements Provenance {
    @IsNotEmpty()
    @IsIn(["Provenance"])
    resourceType: "Provenance"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    activity?: CodeableConcept

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ProvenanceAgentDto)
    agent: ProvenanceAgent[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    authorization?: CodeableReference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ProvenanceEntityDto)
    entity?: ProvenanceEntity[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    location?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    occurredPeriod?: Period

    @IsOptional()
    @IsString()
    occurredDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient?: Reference

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    policy?: string[]

    @IsOptional()
    @IsString()
    recorded?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SignatureDto)
    signature?: Signature[]

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    target: Reference[]

  }
  export class QuestionnaireItemEnableWhenDto implements QuestionnaireItemEnableWhen {
    @IsNotEmpty()
    @IsBoolean()
    answerBoolean: boolean

    @IsOptional()
    @IsNumber()
    answerDecimal?: number

    @IsOptional()
    @IsNumber()
    answerInteger?: number

    @IsOptional()
    @IsString()
    answerDate?: string

    @IsOptional()
    @IsString()
    answerDateTime?: string

    @IsOptional()
    @IsString()
    answerTime?: string

    @IsOptional()
    @IsString()
    answerString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    answerCoding?: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    answerQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    answerReference?: Reference

    @IsNotEmpty()
    @IsIn(["exists", "<", "<=", ">=", ">", "=", "!="])
    operator: "exists" | "<" | "<=" | ">=" | ">" | "=" | "!="

    @IsNotEmpty()
    @IsString()
    question: string

  }
  export class QuestionnaireItemAnswerOptionDto implements QuestionnaireItemAnswerOption {
    @IsNotEmpty()
    @IsBoolean()
    initialSelected: boolean

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsOptional()
    @IsString()
    valueDate?: string

    @IsOptional()
    @IsString()
    valueTime?: string

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    valueCoding?: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

  }
  export class QuestionnaireItemInitialDto implements QuestionnaireItemInitial {
    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsNumber()
    valueDecimal?: number

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsOptional()
    @IsString()
    valueDate?: string

    @IsOptional()
    @IsString()
    valueDateTime?: string

    @IsOptional()
    @IsString()
    valueTime?: string

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @IsString()
    valueUri?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    valueCoding?: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

  }
  export class QuestionnaireItemDto implements QuestionnaireItem {
    @IsNotEmpty()
    @IsIn(["optionsOnly", "optionsOrType", "optionsOrString"])
    answerConstraint: "optionsOnly" | "optionsOrType" | "optionsOrString"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => QuestionnaireItemAnswerOptionDto)
    answerOption?: QuestionnaireItemAnswerOption[]

    @IsOptional()
    @IsString()
    answerValueSet?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    code?: Coding[]

    @IsOptional()
    @IsString()
    definition?: string

    @IsNotEmpty()
    @IsIn(["hidden", "protected"])
    disabledDisplay: "hidden" | "protected"

    @IsNotEmpty()
    @IsIn(["any", "all"])
    enableBehavior: "any" | "all"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => QuestionnaireItemEnableWhenDto)
    enableWhen?: QuestionnaireItemEnableWhen[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => QuestionnaireItemInitialDto)
    initial?: QuestionnaireItemInitial[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => QuestionnaireItemDto)
    item?: QuestionnaireItem[]

    @IsNotEmpty()
    @IsString()
    linkId: string

    @IsOptional()
    @IsNumber()
    maxLength?: number

    @IsOptional()
    @IsString()
    prefix?: string

    @IsNotEmpty()
    @IsBoolean()
    readOnly: boolean

    @IsNotEmpty()
    @IsBoolean()
    repeats: boolean

    @IsNotEmpty()
    @IsBoolean()
    required: boolean

    @IsOptional()
    @IsString()
    text?: string

    @IsNotEmpty()
    @IsIn(["string", "boolean", "url", "group", "date", "reference", "quantity", "integer", "dateTime", "decimal", "time", "display", "question", "text", "coding", "attachment"])
    type: "string" | "boolean" | "url" | "group" | "date" | "reference" | "quantity" | "integer" | "dateTime" | "decimal" | "time" | "display" | "question" | "text" | "coding" | "attachment"

  }
  export class QuestionnaireDto implements Questionnaire {
    @IsNotEmpty()
    @IsIn(["Questionnaire"])
    resourceType: "Questionnaire"

    @IsOptional()
    @IsString()
    approvalDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    code?: Coding[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    copyrightLabel?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    derivedFrom?: string[]

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => QuestionnaireItemDto)
    item?: QuestionnaireItem[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    lastReviewDate?: string

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    subjectType?: string[]

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @IsString()
    versionAlgorithmString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    versionAlgorithmCoding?: Coding

  }
  export class QuestionnaireResponseItemAnswerDto implements QuestionnaireResponseItemAnswer {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => QuestionnaireResponseItemDto)
    item?: QuestionnaireResponseItem[]

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsNumber()
    valueDecimal?: number

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsOptional()
    @IsString()
    valueDate?: string

    @IsOptional()
    @IsString()
    valueDateTime?: string

    @IsOptional()
    @IsString()
    valueTime?: string

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @IsString()
    valueUri?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    valueCoding?: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

  }
  export class QuestionnaireResponseItemDto implements QuestionnaireResponseItem {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => QuestionnaireResponseItemAnswerDto)
    answer?: QuestionnaireResponseItemAnswer[]

    @IsOptional()
    @IsString()
    definition?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => QuestionnaireResponseItemDto)
    item?: QuestionnaireResponseItem[]

    @IsNotEmpty()
    @IsString()
    linkId: string

    @IsOptional()
    @IsString()
    text?: string

  }
  export class QuestionnaireResponseDto implements QuestionnaireResponse {
    @IsNotEmpty()
    @IsIn(["QuestionnaireResponse"])
    resourceType: "QuestionnaireResponse"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    author?: Reference

    @IsOptional()
    @IsString()
    authored?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => QuestionnaireResponseItemDto)
    item?: QuestionnaireResponseItem[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    partOf?: Reference[]

    @IsNotEmpty()
    @IsString()
    questionnaire: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    source?: Reference

    @IsNotEmpty()
    @IsIn(["entered-in-error", "in-progress", "completed", "stopped", "amended"])
    status: "entered-in-error" | "in-progress" | "completed" | "stopped" | "amended"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

  }
  export class RegulatedAuthorizationCaseDto implements RegulatedAuthorizationCase {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RegulatedAuthorizationCaseDto)
    application?: RegulatedAuthorizationCase[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    datePeriod?: Period

    @IsOptional()
    @IsString()
    dateDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    status?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class RegulatedAuthorizationDto implements RegulatedAuthorization {
    @IsNotEmpty()
    @IsIn(["RegulatedAuthorization"])
    resourceType: "RegulatedAuthorization"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    attachedDocument?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    basis?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => RegulatedAuthorizationCaseDto)
    case?: RegulatedAuthorizationCase

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    holder?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    indication?: CodeableReference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    intendedUse?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    region?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    regulator?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    status?: CodeableConcept

    @IsOptional()
    @IsString()
    statusDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    subject?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    validityPeriod?: Period

  }
  export class RelatedPersonCommunicationDto implements RelatedPersonCommunication {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    language: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    preferred: boolean

  }
  export class RelatedPersonDto implements RelatedPerson {
    @IsNotEmpty()
    @IsIn(["RelatedPerson"])
    resourceType: "RelatedPerson"

    @IsNotEmpty()
    @IsBoolean()
    active: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AddressDto)
    address?: Address[]

    @IsOptional()
    @IsString()
    birthDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedPersonCommunicationDto)
    communication?: RelatedPersonCommunication[]

    @IsNotEmpty()
    @IsIn(["other", "unknown", "male", "female"])
    gender: "other" | "unknown" | "male" | "female"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => HumanNameDto)
    name?: HumanName[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AttachmentDto)
    photo?: Attachment[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    relationship?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactPointDto)
    telecom?: ContactPoint[]

  }
  export class RequestOrchestrationActionConditionDto implements RequestOrchestrationActionCondition {
    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    expression?: Expression

    @IsNotEmpty()
    @IsIn(["applicability", "start", "stop"])
    kind: "applicability" | "start" | "stop"

  }
  export class RequestOrchestrationActionInputDto implements RequestOrchestrationActionInput {
    @IsOptional()
    @IsString()
    relatedData?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => DataRequirementDto)
    requirement?: DataRequirement

    @IsOptional()
    @IsString()
    title?: string

  }
  export class RequestOrchestrationActionOutputDto implements RequestOrchestrationActionOutput {
    @IsOptional()
    @IsString()
    relatedData?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => DataRequirementDto)
    requirement?: DataRequirement

    @IsOptional()
    @IsString()
    title?: string

  }
  export class RequestOrchestrationActionRelatedActionDto implements RequestOrchestrationActionRelatedAction {
    @IsNotEmpty()
    @IsIn(["before", "before-start", "before-end", "concurrent", "concurrent-with-start", "concurrent-with-end", "after", "after-start", "after-end"])
    endRelationship: "before" | "before-start" | "before-end" | "concurrent" | "concurrent-with-start" | "concurrent-with-end" | "after" | "after-start" | "after-end"

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    offsetDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    offsetRange?: Range

    @IsNotEmpty()
    @IsIn(["before", "before-start", "before-end", "concurrent", "concurrent-with-start", "concurrent-with-end", "after", "after-start", "after-end"])
    relationship: "before" | "before-start" | "before-end" | "concurrent" | "concurrent-with-start" | "concurrent-with-end" | "after" | "after-start" | "after-end"

    @IsNotEmpty()
    @IsString()
    targetId: string

  }
  export class RequestOrchestrationActionParticipantDto implements RequestOrchestrationActionParticipant {
    @IsOptional()
    @IsString()
    actorCanonical?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    actorReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    function?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    role?: CodeableConcept

    @IsNotEmpty()
    @IsIn(["careteam", "device", "group", "healthcareservice", "location", "organization", "patient", "practitioner", "practitionerrole", "relatedperson"])
    type: "careteam" | "device" | "group" | "healthcareservice" | "location" | "organization" | "patient" | "practitioner" | "practitionerrole" | "relatedperson"

    @IsOptional()
    @IsString()
    typeCanonical?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    typeReference?: Reference

  }
  export class RequestOrchestrationActionDynamicValueDto implements RequestOrchestrationActionDynamicValue {
    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    expression?: Expression

    @IsOptional()
    @IsString()
    path?: string

  }
  export class RequestOrchestrationActionDto implements RequestOrchestrationAction {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RequestOrchestrationActionDto)
    action?: RequestOrchestrationAction[]

    @IsNotEmpty()
    @IsIn(["single", "multiple"])
    cardinalityBehavior: "single" | "multiple"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RequestOrchestrationActionConditionDto)
    condition?: RequestOrchestrationActionCondition[]

    @IsOptional()
    @IsString()
    definitionCanonical?: string

    @IsOptional()
    @IsString()
    definitionUri?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    documentation?: RelatedArtifact[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RequestOrchestrationActionDynamicValueDto)
    dynamicValue?: RequestOrchestrationActionDynamicValue[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    goal?: Reference[]

    @IsNotEmpty()
    @IsIn(["visual-group", "logical-group", "sentence-group"])
    groupingBehavior: "visual-group" | "logical-group" | "sentence-group"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RequestOrchestrationActionInputDto)
    input?: RequestOrchestrationActionInput[]

    @IsOptional()
    @IsString()
    linkId?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    location?: CodeableReference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RequestOrchestrationActionOutputDto)
    output?: RequestOrchestrationActionOutput[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RequestOrchestrationActionParticipantDto)
    participant?: RequestOrchestrationActionParticipant[]

    @IsNotEmpty()
    @IsIn(["yes", "no"])
    precheckBehavior: "yes" | "no"

    @IsOptional()
    @IsString()
    prefix?: string

    @IsNotEmpty()
    @IsIn(["routine", "urgent", "asap", "stat"])
    priority: "routine" | "urgent" | "asap" | "stat"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RequestOrchestrationActionRelatedActionDto)
    relatedAction?: RequestOrchestrationActionRelatedAction[]

    @IsNotEmpty()
    @IsIn(["must", "could", "must-unless-documented"])
    requiredBehavior: "must" | "could" | "must-unless-documented"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    resource?: Reference

    @IsNotEmpty()
    @IsIn(["any", "all", "all-or-none", "exactly-one", "at-most-one", "one-or-more"])
    selectionBehavior: "any" | "all" | "all-or-none" | "exactly-one" | "at-most-one" | "one-or-more"

    @IsOptional()
    @IsString()
    textEquivalent?: string

    @IsOptional()
    @IsString()
    timingDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    timingAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    timingPeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    timingDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    timingRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    timingTiming?: Timing

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsString()
    transform?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class RequestOrchestrationDto implements RequestOrchestration {
    @IsNotEmpty()
    @IsIn(["RequestOrchestration"])
    resourceType: "RequestOrchestration"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RequestOrchestrationActionDto)
    action?: RequestOrchestrationAction[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    author?: Reference

    @IsOptional()
    @IsString()
    authoredOn?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    goal?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    groupIdentifier?: Identifier

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesCanonical?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesUri?: string[]

    @IsNotEmpty()
    @IsIn(["proposal", "plan", "directive", "order", "original-order", "reflex-order", "filler-order", "instance-order", "option"])
    intent: "proposal" | "plan" | "directive" | "order" | "original-order" | "reflex-order" | "filler-order" | "instance-order" | "option"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsNotEmpty()
    @IsIn(["routine", "urgent", "asap", "stat"])
    priority: "routine" | "urgent" | "asap" | "stat"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    reason?: CodeableReference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    replaces?: Reference[]

    @IsNotEmpty()
    @IsIn(["draft", "active", "unknown", "entered-in-error", "on-hold", "completed", "revoked"])
    status: "draft" | "active" | "unknown" | "entered-in-error" | "on-hold" | "completed" | "revoked"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

  }
  export class RequirementsStatementDto implements RequirementsStatement {
    @IsNotEmpty()
    @IsBoolean()
    conditionality: boolean

    @IsOptional()
    @IsArray()
    @IsIn(["SHALL", "SHOULD", "MAY", "SHOULD-NOT"], { each: true })
    conformance?: ("SHALL" | "SHOULD" | "MAY" | "SHOULD-NOT")[]

    @IsOptional()
    @IsString()
    derivedFrom?: string

    @IsNotEmpty()
    @IsString()
    key: string

    @IsOptional()
    @IsString()
    label?: string

    @IsOptional()
    @IsString()
    parent?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    reference?: string[]

    @IsNotEmpty()
    @IsString()
    requirement: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    satisfiedBy?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    source?: Reference[]

  }
  export class RequirementsDto implements Requirements {
    @IsNotEmpty()
    @IsIn(["Requirements"])
    resourceType: "Requirements"

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    actor?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    copyrightLabel?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    derivedFrom?: string[]

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    reference?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RequirementsStatementDto)
    statement?: RequirementsStatement[]

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @IsString()
    versionAlgorithmString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    versionAlgorithmCoding?: Coding

  }
  export class ResearchStudyLabelDto implements ResearchStudyLabel {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsOptional()
    @IsString()
    value?: string

  }
  export class ResearchStudyAssociatedPartyDto implements ResearchStudyAssociatedParty {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    classifier?: CodeableConcept[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    party?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PeriodDto)
    period?: Period[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    role: CodeableConcept

  }
  export class ResearchStudyProgressStatusDto implements ResearchStudyProgressStatus {
    @IsNotEmpty()
    @IsBoolean()
    actual: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    state: CodeableConcept

  }
  export class ResearchStudyRecruitmentDto implements ResearchStudyRecruitment {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    actualGroup?: Reference

    @IsOptional()
    @IsNumber()
    actualNumber?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    eligibility?: Reference

    @IsOptional()
    @IsNumber()
    targetNumber?: number

  }
  export class ResearchStudyComparisonGroupDto implements ResearchStudyComparisonGroup {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    intendedExposure?: Reference[]

    @IsOptional()
    @IsString()
    linkId?: string

    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    observedGroup?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class ResearchStudyObjectiveDto implements ResearchStudyObjective {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class ResearchStudyOutcomeMeasureDto implements ResearchStudyOutcomeMeasure {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    reference?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

  }
  export class ResearchStudyDto implements ResearchStudy {
    @IsNotEmpty()
    @IsIn(["ResearchStudy"])
    resourceType: "ResearchStudy"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ResearchStudyAssociatedPartyDto)
    associatedParty?: ResearchStudyAssociatedParty[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    classifier?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ResearchStudyComparisonGroupDto)
    comparisonGroup?: ResearchStudyComparisonGroup[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    condition?: CodeableConcept[]

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    descriptionSummary?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    focus?: CodeableReference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    keyword?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ResearchStudyLabelDto)
    label?: ResearchStudyLabel[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ResearchStudyObjectiveDto)
    objective?: ResearchStudyObjective[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ResearchStudyOutcomeMeasureDto)
    outcomeMeasure?: ResearchStudyOutcomeMeasure[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    partOf?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    phase?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    primaryPurposeType?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ResearchStudyProgressStatusDto)
    progressStatus?: ResearchStudyProgressStatus[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    protocol?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ResearchStudyRecruitmentDto)
    recruitment?: ResearchStudyRecruitment

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    region?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    relatedArtifact?: RelatedArtifact[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    result?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    site?: Reference[]

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    studyDesign?: CodeableConcept[]

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    whyStopped?: CodeableConcept

  }
  export class ResearchSubjectProgressDto implements ResearchSubjectProgress {
    @IsOptional()
    @IsString()
    endDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    milestone?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    reason?: CodeableConcept

    @IsOptional()
    @IsString()
    startDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    subjectState?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class ResearchSubjectDto implements ResearchSubject {
    @IsNotEmpty()
    @IsIn(["ResearchSubject"])
    resourceType: "ResearchSubject"

    @IsOptional()
    @IsString()
    actualComparisonGroup?: string

    @IsOptional()
    @IsString()
    assignedComparisonGroup?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    consent?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ResearchSubjectProgressDto)
    progress?: ResearchSubjectProgress[]

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    study: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

  }
  export class ResourceDto implements Resource {
    @IsNotEmpty()
    @IsString()
    resourceType: string

    @IsOptional()
    @IsString()
    id?: string

    @IsOptional()
    @IsString()
    implicitRules?: string

    @IsOptional()
    @IsString()
    language?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => MetaDto)
    meta?: Meta

  }
  export class RiskAssessmentPredictionDto implements RiskAssessmentPrediction {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    outcome?: CodeableConcept

    @IsOptional()
    @IsNumber()
    probabilityDecimal?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    probabilityRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    qualitativeRisk?: CodeableConcept

    @IsOptional()
    @IsString()
    rationale?: string

    @IsOptional()
    @IsNumber()
    relativeRisk?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    whenPeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    whenRange?: Range

  }
  export class RiskAssessmentDto implements RiskAssessment {
    @IsNotEmpty()
    @IsIn(["RiskAssessment"])
    resourceType: "RiskAssessment"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    basedOn?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basis?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    condition?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    method?: CodeableConcept

    @IsOptional()
    @IsString()
    mitigation?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    occurrenceDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    occurrencePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    parent?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    performer?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RiskAssessmentPredictionDto)
    prediction?: RiskAssessmentPrediction[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    reason?: CodeableReference[]

    @IsNotEmpty()
    @IsIn(["unknown", "entered-in-error", "cancelled", "registered", "preliminary", "final", "amended", "corrected"])
    status: "unknown" | "entered-in-error" | "cancelled" | "registered" | "preliminary" | "final" | "amended" | "corrected"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

  }
  export class ScheduleDto implements Schedule {
    @IsNotEmpty()
    @IsIn(["Schedule"])
    resourceType: "Schedule"

    @IsNotEmpty()
    @IsBoolean()
    active: boolean

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    actor: Reference[]

    @IsOptional()
    @IsString()
    comment?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    planningHorizon?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    serviceCategory?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    serviceType?: CodeableReference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    specialty?: CodeableConcept[]

  }
  export class SearchParameterComponentDto implements SearchParameterComponent {
    @IsNotEmpty()
    @IsString()
    definition: string

    @IsNotEmpty()
    @IsString()
    expression: string

  }
  export class SearchParameterDto implements SearchParameter {
    @IsNotEmpty()
    @IsIn(["SearchParameter"])
    resourceType: "SearchParameter"

    @IsNotEmpty()
    @IsArray()
    @IsString({ each: true })
    base: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    chain?: string[]

    @IsNotEmpty()
    @IsString()
    code: string

    @IsOptional()
    @IsArray()
    @IsIn(["eq", "gt", "lt", "ge", "le", "sa", "eb", "ne", "ap"], { each: true })
    comparator?: ("eq" | "gt" | "lt" | "ge" | "le" | "sa" | "eb" | "ne" | "ap")[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SearchParameterComponentDto)
    component?: SearchParameterComponent[]

    @IsOptional()
    @IsString()
    constraint?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    copyrightLabel?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    derivedFrom?: string

    @IsNotEmpty()
    @IsString()
    description: string

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsString()
    expression?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @IsIn(["type", "in", "contains", "not-in", "identifier", "text", "missing", "exact", "not", "below", "above", "of-type", "code-text", "text-advanced", "iterate"], { each: true })
    modifier?: ("type" | "in" | "contains" | "not-in" | "identifier" | "text" | "missing" | "exact" | "not" | "below" | "above" | "of-type" | "code-text" | "text-advanced" | "iterate")[]

    @IsNotEmpty()
    @IsBoolean()
    multipleAnd: boolean

    @IsNotEmpty()
    @IsBoolean()
    multipleOr: boolean

    @IsNotEmpty()
    @IsString()
    name: string

    @IsNotEmpty()
    @IsIn(["other", "normal", "phonetic"])
    processingMode: "other" | "normal" | "phonetic"

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    target?: string[]

    @IsOptional()
    @IsString()
    title?: string

    @IsNotEmpty()
    @IsIn(["string", "number", "date", "token", "reference", "composite", "quantity", "uri", "special"])
    type: "string" | "number" | "date" | "token" | "reference" | "composite" | "quantity" | "uri" | "special"

    @IsNotEmpty()
    @IsString()
    url: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @IsString()
    versionAlgorithmString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    versionAlgorithmCoding?: Coding

  }
  export class ServiceRequestOrderDetailParameterDto implements ServiceRequestOrderDetailParameter {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    valueRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    valuePeriod?: Period

  }
  export class ServiceRequestOrderDetailDto implements ServiceRequestOrderDetail {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ServiceRequestOrderDetailParameterDto)
    parameter: ServiceRequestOrderDetailParameter[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    parameterFocus?: CodeableReference

  }
  export class ServiceRequestPatientInstructionDto implements ServiceRequestPatientInstruction {
    @IsOptional()
    @IsString()
    instructionMarkdown?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    instructionReference?: Reference

  }
  export class ServiceRequestDto implements ServiceRequest {
    @IsNotEmpty()
    @IsIn(["ServiceRequest"])
    resourceType: "ServiceRequest"

    @IsNotEmpty()
    @IsBoolean()
    asNeededBoolean: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    asNeededCodeableConcept?: CodeableConcept

    @IsOptional()
    @IsString()
    authoredOn?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    bodySite?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    bodyStructure?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    code?: CodeableReference

    @IsNotEmpty()
    @IsBoolean()
    doNotPerform: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    focus?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesCanonical?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesUri?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    insurance?: Reference[]

    @IsNotEmpty()
    @IsIn(["proposal", "plan", "directive", "order", "original-order", "reflex-order", "filler-order", "instance-order", "option"])
    intent: "proposal" | "plan" | "directive" | "order" | "original-order" | "reflex-order" | "filler-order" | "instance-order" | "option"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    location?: CodeableReference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    occurrenceDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    occurrencePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    occurrenceTiming?: Timing

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ServiceRequestOrderDetailDto)
    orderDetail?: ServiceRequestOrderDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ServiceRequestPatientInstructionDto)
    patientInstruction?: ServiceRequestPatientInstruction[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    performer?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    performerType?: CodeableConcept

    @IsNotEmpty()
    @IsIn(["routine", "urgent", "asap", "stat"])
    priority: "routine" | "urgent" | "asap" | "stat"

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantityQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    quantityRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    quantityRange?: Range

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    reason?: CodeableReference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    relevantHistory?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    replaces?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    requester?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    requisition?: Identifier

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    specimen?: Reference[]

    @IsNotEmpty()
    @IsIn(["draft", "active", "unknown", "entered-in-error", "on-hold", "completed", "revoked"])
    status: "draft" | "active" | "unknown" | "entered-in-error" | "on-hold" | "completed" | "revoked"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    supportingInfo?: CodeableReference[]

  }
  export class SlotDto implements Slot {
    @IsNotEmpty()
    @IsIn(["Slot"])
    resourceType: "Slot"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    appointmentType?: CodeableConcept[]

    @IsOptional()
    @IsString()
    comment?: string

    @IsNotEmpty()
    @IsString()
    end: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsNotEmpty()
    @IsBoolean()
    overbooked: boolean

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    schedule: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    serviceCategory?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    serviceType?: CodeableReference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    specialty?: CodeableConcept[]

    @IsNotEmpty()
    @IsString()
    start: string

    @IsNotEmpty()
    @IsIn(["entered-in-error", "busy", "free", "busy-unavailable", "busy-tentative"])
    status: "entered-in-error" | "busy" | "free" | "busy-unavailable" | "busy-tentative"

  }
  export class SpecimenFeatureDto implements SpecimenFeature {
    @IsNotEmpty()
    @IsString()
    description: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class SpecimenCollectionDto implements SpecimenCollection {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    bodySite?: CodeableReference

    @IsOptional()
    @IsString()
    collectedDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    collectedPeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    collector?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    device?: CodeableReference

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    duration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    fastingStatusCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    fastingStatusDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    method?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    procedure?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

  }
  export class SpecimenProcessingDto implements SpecimenProcessing {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    additive?: Reference[]

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    method?: CodeableConcept

    @IsOptional()
    @IsString()
    timeDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    timePeriod?: Period

  }
  export class SpecimenContainerDto implements SpecimenContainer {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    device: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    location?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    specimenQuantity?: Quantity

  }
  export class SpecimenDto implements Specimen {
    @IsNotEmpty()
    @IsIn(["Specimen"])
    resourceType: "Specimen"

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    accessionIdentifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => SpecimenCollectionDto)
    collection?: SpecimenCollection

    @IsNotEmpty()
    @IsIn(["grouped", "pooled"])
    combined: "grouped" | "pooled"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    condition?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SpecimenContainerDto)
    container?: SpecimenContainer[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SpecimenFeatureDto)
    feature?: SpecimenFeature[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    parent?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SpecimenProcessingDto)
    processing?: SpecimenProcessing[]

    @IsOptional()
    @IsString()
    receivedTime?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    request?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    role?: CodeableConcept[]

    @IsNotEmpty()
    @IsIn(["entered-in-error", "available", "unavailable", "unsatisfactory"])
    status: "entered-in-error" | "available" | "unavailable" | "unsatisfactory"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class SpecimenDefinitionTypeTestedContainerAdditiveDto implements SpecimenDefinitionTypeTestedContainerAdditive {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    additiveCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    additiveReference?: Reference

  }
  export class SpecimenDefinitionTypeTestedContainerDto implements SpecimenDefinitionTypeTestedContainer {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SpecimenDefinitionTypeTestedContainerAdditiveDto)
    additive?: SpecimenDefinitionTypeTestedContainerAdditive[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    cap?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    capacity?: Quantity

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    material?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    minimumVolumeQuantity?: Quantity

    @IsOptional()
    @IsString()
    minimumVolumeString?: string

    @IsOptional()
    @IsString()
    preparation?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class SpecimenDefinitionTypeTestedHandlingDto implements SpecimenDefinitionTypeTestedHandling {
    @IsOptional()
    @IsString()
    instruction?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    maxDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    temperatureQualifier?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    temperatureRange?: Range

  }
  export class SpecimenDefinitionTypeTestedDto implements SpecimenDefinitionTypeTested {
    @IsOptional()
    @ValidateNested()
    @Type(() => SpecimenDefinitionTypeTestedContainerDto)
    container?: SpecimenDefinitionTypeTestedContainer

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SpecimenDefinitionTypeTestedHandlingDto)
    handling?: SpecimenDefinitionTypeTestedHandling[]

    @IsNotEmpty()
    @IsBoolean()
    isDerived: boolean

    @IsNotEmpty()
    @IsIn(["preferred", "alternate"])
    preference: "preferred" | "alternate"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    rejectionCriterion?: CodeableConcept[]

    @IsOptional()
    @IsString()
    requirement?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    retentionTime?: Duration

    @IsNotEmpty()
    @IsBoolean()
    singleUse: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    testingDestination?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class SpecimenDefinitionDto implements SpecimenDefinition {
    @IsNotEmpty()
    @IsIn(["SpecimenDefinition"])
    resourceType: "SpecimenDefinition"

    @IsOptional()
    @IsString()
    approvalDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    collection?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    copyrightLabel?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    derivedFromCanonical?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    derivedFromUri?: string[]

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    lastReviewDate?: string

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    patientPreparation?: CodeableConcept[]

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    subjectCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subjectReference?: Reference

    @IsOptional()
    @IsString()
    timeAspect?: string

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    typeCollected?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SpecimenDefinitionTypeTestedDto)
    typeTested?: SpecimenDefinitionTypeTested[]

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @IsString()
    versionAlgorithmString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    versionAlgorithmCoding?: Coding

  }
  export class StructureDefinitionMappingDto implements StructureDefinitionMapping {
    @IsOptional()
    @IsString()
    comment?: string

    @IsNotEmpty()
    @IsString()
    identity: string

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsString()
    uri?: string

  }
  export class StructureDefinitionContextDto implements StructureDefinitionContext {
    @IsNotEmpty()
    @IsString()
    expression: string

    @IsNotEmpty()
    @IsIn(["fhirpath", "element", "extension"])
    type: "fhirpath" | "element" | "extension"

  }
  export class StructureDefinitionSnapshotDto implements StructureDefinitionSnapshot {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ElementDefinitionDto)
    element: ElementDefinition[]

  }
  export class StructureDefinitionDifferentialDto implements StructureDefinitionDifferential {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ElementDefinitionDto)
    element: ElementDefinition[]

  }
  export class StructureDefinitionDto implements StructureDefinition {
    @IsNotEmpty()
    @IsIn(["StructureDefinition"])
    resourceType: "StructureDefinition"

    @IsNotEmpty()
    @IsBoolean()
    abstract: boolean

    @IsOptional()
    @IsString()
    baseDefinition?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => StructureDefinitionContextDto)
    context?: StructureDefinitionContext[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    contextInvariant?: string[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    copyrightLabel?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsNotEmpty()
    @IsIn(["specialization", "constraint"])
    derivation: "specialization" | "constraint"

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => StructureDefinitionDifferentialDto)
    differential?: StructureDefinitionDifferential

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsString()
    fhirVersion?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    keyword?: Coding[]

    @IsNotEmpty()
    @IsIn(["logical", "primitive-type", "complex-type", "resource"])
    kind: "logical" | "primitive-type" | "complex-type" | "resource"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => StructureDefinitionMappingDto)
    mapping?: StructureDefinitionMapping[]

    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => StructureDefinitionSnapshotDto)
    snapshot?: StructureDefinitionSnapshot

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @IsString()
    title?: string

    @IsNotEmpty()
    @IsString()
    type: string

    @IsNotEmpty()
    @IsString()
    url: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @IsString()
    versionAlgorithmString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    versionAlgorithmCoding?: Coding

  }
  export class StructureMapStructureDto implements StructureMapStructure {
    @IsOptional()
    @IsString()
    alias?: string

    @IsOptional()
    @IsString()
    documentation?: string

    @IsNotEmpty()
    @IsIn(["source", "queried", "target", "produced"])
    mode: "source" | "queried" | "target" | "produced"

    @IsNotEmpty()
    @IsString()
    url: string

  }
  export class StructureMapConstDto implements StructureMapConst {
    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsString()
    value?: string

  }
  export class StructureMapGroupInputDto implements StructureMapGroupInput {
    @IsOptional()
    @IsString()
    documentation?: string

    @IsNotEmpty()
    @IsIn(["source", "target"])
    mode: "source" | "target"

    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @IsString()
    type?: string

  }
  export class StructureMapGroupRuleSourceDto implements StructureMapGroupRuleSource {
    @IsOptional()
    @IsString()
    check?: string

    @IsOptional()
    @IsString()
    condition?: string

    @IsNotEmpty()
    @IsString()
    context: string

    @IsOptional()
    @IsString()
    defaultValue?: string

    @IsOptional()
    @IsString()
    element?: string

    @IsNotEmpty()
    @IsIn(["first", "not_first", "last", "not_last", "only_one"])
    listMode: "first" | "not_first" | "last" | "not_last" | "only_one"

    @IsOptional()
    @IsString()
    logMessage?: string

    @IsOptional()
    @IsString()
    max?: string

    @IsOptional()
    @IsNumber()
    min?: number

    @IsOptional()
    @IsString()
    type?: string

    @IsOptional()
    @IsString()
    variable?: string

  }
  export class StructureMapGroupRuleTargetParameterDto implements StructureMapGroupRuleTargetParameter {
    @IsOptional()
    @IsString()
    valueId?: string

    @IsOptional()
    @IsString()
    valueString?: string

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsOptional()
    @IsNumber()
    valueDecimal?: number

    @IsOptional()
    @IsString()
    valueDate?: string

    @IsOptional()
    @IsString()
    valueTime?: string

    @IsOptional()
    @IsString()
    valueDateTime?: string

  }
  export class StructureMapGroupRuleTargetDto implements StructureMapGroupRuleTarget {
    @IsOptional()
    @IsString()
    context?: string

    @IsOptional()
    @IsString()
    element?: string

    @IsOptional()
    @IsArray()
    @IsIn(["single", "first", "last", "share"], { each: true })
    listMode?: ("single" | "first" | "last" | "share")[]

    @IsOptional()
    @IsString()
    listRuleId?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => StructureMapGroupRuleTargetParameterDto)
    parameter?: StructureMapGroupRuleTargetParameter[]

    @IsNotEmpty()
    @IsIn(["create", "reference", "uuid", "copy", "truncate", "escape", "cast", "append", "translate", "dateOp", "pointer", "evaluate", "cc", "c", "qty", "id", "cp"])
    transform: "create" | "reference" | "uuid" | "copy" | "truncate" | "escape" | "cast" | "append" | "translate" | "dateOp" | "pointer" | "evaluate" | "cc" | "c" | "qty" | "id" | "cp"

    @IsOptional()
    @IsString()
    variable?: string

  }
  export class StructureMapGroupRuleDependentDto implements StructureMapGroupRuleDependent {
    @IsNotEmpty()
    @IsString()
    name: string

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => StructureMapGroupRuleTargetParameterDto)
    parameter: StructureMapGroupRuleTargetParameter[]

  }
  export class StructureMapGroupRuleDto implements StructureMapGroupRule {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => StructureMapGroupRuleDependentDto)
    dependent?: StructureMapGroupRuleDependent[]

    @IsOptional()
    @IsString()
    documentation?: string

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => StructureMapGroupRuleDto)
    rule?: StructureMapGroupRule[]

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => StructureMapGroupRuleSourceDto)
    source: StructureMapGroupRuleSource[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => StructureMapGroupRuleTargetDto)
    target?: StructureMapGroupRuleTarget[]

  }
  export class StructureMapGroupDto implements StructureMapGroup {
    @IsOptional()
    @IsString()
    documentation?: string

    @IsOptional()
    @IsString()
    extends?: string

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => StructureMapGroupInputDto)
    input: StructureMapGroupInput[]

    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => StructureMapGroupRuleDto)
    rule?: StructureMapGroupRule[]

    @IsNotEmpty()
    @IsIn(["types", "type-and-types"])
    typeMode: "types" | "type-and-types"

  }
  export class StructureMapDto implements StructureMap {
    @IsNotEmpty()
    @IsIn(["StructureMap"])
    resourceType: "StructureMap"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => StructureMapConstDto)
    const?: StructureMapConst[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    copyrightLabel?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => StructureMapGroupDto)
    group: StructureMapGroup[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    import?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => StructureMapStructureDto)
    structure?: StructureMapStructure[]

    @IsOptional()
    @IsString()
    title?: string

    @IsNotEmpty()
    @IsString()
    url: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @IsString()
    versionAlgorithmString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    versionAlgorithmCoding?: Coding

  }
  export class SubscriptionFilterByDto implements SubscriptionFilterBy {
    @IsNotEmpty()
    @IsIn(["eq", "gt", "lt", "ge", "le", "sa", "eb", "ne", "ap"])
    comparator: "eq" | "gt" | "lt" | "ge" | "le" | "sa" | "eb" | "ne" | "ap"

    @IsNotEmpty()
    @IsString()
    filterParameter: string

    @IsNotEmpty()
    @IsIn(["type", "in", "contains", "not-in", "identifier", "text", "missing", "exact", "not", "below", "above", "of-type", "code-text", "text-advanced", "iterate"])
    modifier: "type" | "in" | "contains" | "not-in" | "identifier" | "text" | "missing" | "exact" | "not" | "below" | "above" | "of-type" | "code-text" | "text-advanced" | "iterate"

    @IsOptional()
    @IsString()
    resourceType?: string

    @IsNotEmpty()
    @IsString()
    value: string

  }
  export class SubscriptionParameterDto implements SubscriptionParameter {
    @IsNotEmpty()
    @IsString()
    name: string

    @IsNotEmpty()
    @IsString()
    value: string

  }
  export class SubscriptionDto implements Subscription {
    @IsNotEmpty()
    @IsIn(["Subscription"])
    resourceType: "Subscription"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodingDto)
    channelType: Coding

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactPointDto)
    contact?: ContactPoint[]

    @IsNotEmpty()
    @IsIn(["empty", "id-only", "full-resource"])
    content: "empty" | "id-only" | "full-resource"

    @IsOptional()
    @IsString()
    contentType?: string

    @IsOptional()
    @IsString()
    end?: string

    @IsOptional()
    @IsString()
    endpoint?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubscriptionFilterByDto)
    filterBy?: SubscriptionFilterBy[]

    @IsOptional()
    @IsNumber()
    heartbeatPeriod?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    managingEntity?: Reference

    @IsOptional()
    @IsNumber()
    maxCount?: number

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubscriptionParameterDto)
    parameter?: SubscriptionParameter[]

    @IsOptional()
    @IsString()
    reason?: string

    @IsNotEmpty()
    @IsIn(["error", "active", "entered-in-error", "off", "requested"])
    status: "error" | "active" | "entered-in-error" | "off" | "requested"

    @IsOptional()
    @IsNumber()
    timeout?: number

    @IsNotEmpty()
    @IsString()
    topic: string

  }
  export class SubscriptionStatusNotificationEventDto implements SubscriptionStatusNotificationEvent {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    additionalContext?: Reference[]

    @IsNotEmpty()
    @IsString()
    eventNumber: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    focus?: Reference

    @IsOptional()
    @IsString()
    timestamp?: string

  }
  export class SubscriptionStatusDto implements SubscriptionStatus {
    @IsNotEmpty()
    @IsIn(["SubscriptionStatus"])
    resourceType: "SubscriptionStatus"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    error?: CodeableConcept[]

    @IsOptional()
    @IsString()
    eventsSinceSubscriptionStart?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubscriptionStatusNotificationEventDto)
    notificationEvent?: SubscriptionStatusNotificationEvent[]

    @IsNotEmpty()
    @IsIn(["error", "active", "entered-in-error", "off", "requested"])
    status: "error" | "active" | "entered-in-error" | "off" | "requested"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subscription: Reference

    @IsOptional()
    @IsString()
    topic?: string

    @IsNotEmpty()
    @IsIn(["handshake", "heartbeat", "event-notification", "query-status", "query-event"])
    type: "handshake" | "heartbeat" | "event-notification" | "query-status" | "query-event"

  }
  export class SubscriptionTopicResourceTriggerQueryCriteriaDto implements SubscriptionTopicResourceTriggerQueryCriteria {
    @IsOptional()
    @IsString()
    current?: string

    @IsOptional()
    @IsString()
    previous?: string

    @IsNotEmpty()
    @IsBoolean()
    requireBoth: boolean

    @IsNotEmpty()
    @IsIn(["test-passes", "test-fails"])
    resultForCreate: "test-passes" | "test-fails"

    @IsNotEmpty()
    @IsIn(["test-passes", "test-fails"])
    resultForDelete: "test-passes" | "test-fails"

  }
  export class SubscriptionTopicResourceTriggerDto implements SubscriptionTopicResourceTrigger {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    fhirPathCriteria?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => SubscriptionTopicResourceTriggerQueryCriteriaDto)
    queryCriteria?: SubscriptionTopicResourceTriggerQueryCriteria

    @IsNotEmpty()
    @IsString()
    resource: string

    @IsOptional()
    @IsArray()
    @IsIn(["update", "delete", "create"], { each: true })
    supportedInteraction?: ("update" | "delete" | "create")[]

  }
  export class SubscriptionTopicEventTriggerDto implements SubscriptionTopicEventTrigger {
    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    event: CodeableConcept

    @IsNotEmpty()
    @IsString()
    resource: string

  }
  export class SubscriptionTopicCanFilterByDto implements SubscriptionTopicCanFilterBy {
    @IsOptional()
    @IsArray()
    @IsIn(["eq", "gt", "lt", "ge", "le", "sa", "eb", "ne", "ap"], { each: true })
    comparator?: ("eq" | "gt" | "lt" | "ge" | "le" | "sa" | "eb" | "ne" | "ap")[]

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    filterDefinition?: string

    @IsNotEmpty()
    @IsString()
    filterParameter: string

    @IsOptional()
    @IsArray()
    @IsIn(["type", "in", "contains", "not-in", "identifier", "text", "missing", "exact", "not", "below", "above", "of-type", "code-text", "text-advanced", "iterate"], { each: true })
    modifier?: ("type" | "in" | "contains" | "not-in" | "identifier" | "text" | "missing" | "exact" | "not" | "below" | "above" | "of-type" | "code-text" | "text-advanced" | "iterate")[]

    @IsOptional()
    @IsString()
    resource?: string

  }
  export class SubscriptionTopicNotificationShapeDto implements SubscriptionTopicNotificationShape {
    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    include?: string[]

    @IsNotEmpty()
    @IsString()
    resource: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    revInclude?: string[]

  }
  export class SubscriptionTopicDto implements SubscriptionTopic {
    @IsNotEmpty()
    @IsIn(["SubscriptionTopic"])
    resourceType: "SubscriptionTopic"

    @IsOptional()
    @IsString()
    approvalDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubscriptionTopicCanFilterByDto)
    canFilterBy?: SubscriptionTopicCanFilterBy[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    copyrightLabel?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    derivedFrom?: string[]

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubscriptionTopicEventTriggerDto)
    eventTrigger?: SubscriptionTopicEventTrigger[]

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    lastReviewDate?: string

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubscriptionTopicNotificationShapeDto)
    notificationShape?: SubscriptionTopicNotificationShape[]

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubscriptionTopicResourceTriggerDto)
    resourceTrigger?: SubscriptionTopicResourceTrigger[]

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @IsString()
    title?: string

    @IsNotEmpty()
    @IsString()
    url: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @IsString()
    versionAlgorithmString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    versionAlgorithmCoding?: Coding

  }
  export class SubstanceIngredientDto implements SubstanceIngredient {
    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    quantity?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    substanceCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    substanceReference?: Reference

  }
  export class SubstanceDto implements Substance {
    @IsNotEmpty()
    @IsIn(["Substance"])
    resourceType: "Substance"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    code: CodeableReference

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    expiry?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstanceIngredientDto)
    ingredient?: SubstanceIngredient[]

    @IsNotEmpty()
    @IsBoolean()
    instance: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsNotEmpty()
    @IsIn(["active", "inactive", "entered-in-error"])
    status: "active" | "inactive" | "entered-in-error"

  }
  export class SubstanceDefinitionMoietyDto implements SubstanceDefinitionMoiety {
    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    amountQuantity?: Quantity

    @IsOptional()
    @IsString()
    amountString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    measurementType?: CodeableConcept

    @IsOptional()
    @IsString()
    molecularFormula?: string

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    opticalActivity?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    role?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    stereochemistry?: CodeableConcept

  }
  export class SubstanceDefinitionCharacterizationDto implements SubstanceDefinitionCharacterization {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AttachmentDto)
    file?: Attachment[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    form?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    technique?: CodeableConcept

  }
  export class SubstanceDefinitionPropertyDto implements SubstanceDefinitionProperty {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @IsString()
    valueDate?: string

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

  }
  export class SubstanceDefinitionMolecularWeightDto implements SubstanceDefinitionMolecularWeight {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => QuantityDto)
    amount: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    method?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class SubstanceDefinitionStructureRepresentationDto implements SubstanceDefinitionStructureRepresentation {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    document?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    format?: CodeableConcept

    @IsOptional()
    @IsString()
    representation?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class SubstanceDefinitionStructureDto implements SubstanceDefinitionStructure {
    @IsOptional()
    @IsString()
    molecularFormula?: string

    @IsOptional()
    @IsString()
    molecularFormulaByMoiety?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => SubstanceDefinitionMolecularWeightDto)
    molecularWeight?: SubstanceDefinitionMolecularWeight

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    opticalActivity?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstanceDefinitionStructureRepresentationDto)
    representation?: SubstanceDefinitionStructureRepresentation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    sourceDocument?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    stereochemistry?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    technique?: CodeableConcept[]

  }
  export class SubstanceDefinitionCodeDto implements SubstanceDefinitionCode {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    source?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    status?: CodeableConcept

    @IsOptional()
    @IsString()
    statusDate?: string

  }
  export class SubstanceDefinitionNameOfficialDto implements SubstanceDefinitionNameOfficial {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    authority?: CodeableConcept

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    status?: CodeableConcept

  }
  export class SubstanceDefinitionNameDto implements SubstanceDefinitionName {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    domain?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    language?: CodeableConcept[]

    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstanceDefinitionNameOfficialDto)
    official?: SubstanceDefinitionNameOfficial[]

    @IsNotEmpty()
    @IsBoolean()
    preferred: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    source?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    status?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstanceDefinitionNameDto)
    synonym?: SubstanceDefinitionName[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstanceDefinitionNameDto)
    translation?: SubstanceDefinitionName[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class SubstanceDefinitionRelationshipDto implements SubstanceDefinitionRelationship {
    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    amountQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    amountRatio?: Ratio

    @IsOptional()
    @IsString()
    amountString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    comparator?: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    isDefining: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    ratioHighLimitAmount?: Ratio

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    source?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    substanceDefinitionReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    substanceDefinitionCodeableConcept?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class SubstanceDefinitionSourceMaterialDto implements SubstanceDefinitionSourceMaterial {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    countryOfOrigin?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    genus?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    part?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    species?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class SubstanceDefinitionDto implements SubstanceDefinition {
    @IsNotEmpty()
    @IsIn(["SubstanceDefinition"])
    resourceType: "SubstanceDefinition"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstanceDefinitionCharacterizationDto)
    characterization?: SubstanceDefinitionCharacterization[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    classification?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstanceDefinitionCodeDto)
    code?: SubstanceDefinitionCode[]

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    domain?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    grade?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    informationSource?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    manufacturer?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstanceDefinitionMoietyDto)
    moiety?: SubstanceDefinitionMoiety[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstanceDefinitionMolecularWeightDto)
    molecularWeight?: SubstanceDefinitionMolecularWeight[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstanceDefinitionNameDto)
    name?: SubstanceDefinitionName[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    nucleicAcid?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    polymer?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstanceDefinitionPropertyDto)
    property?: SubstanceDefinitionProperty[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    protein?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    referenceInformation?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstanceDefinitionRelationshipDto)
    relationship?: SubstanceDefinitionRelationship[]

    @IsOptional()
    @ValidateNested()
    @Type(() => SubstanceDefinitionSourceMaterialDto)
    sourceMaterial?: SubstanceDefinitionSourceMaterial

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    status?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => SubstanceDefinitionStructureDto)
    structure?: SubstanceDefinitionStructure

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    supplier?: Reference[]

    @IsOptional()
    @IsString()
    version?: string

  }
  export class SubstanceNucleicAcidSubunitLinkageDto implements SubstanceNucleicAcidSubunitLinkage {
    @IsOptional()
    @IsString()
    connectivity?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsString()
    residueSite?: string

  }
  export class SubstanceNucleicAcidSubunitSugarDto implements SubstanceNucleicAcidSubunitSugar {
    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsString()
    residueSite?: string

  }
  export class SubstanceNucleicAcidSubunitDto implements SubstanceNucleicAcidSubunit {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    fivePrime?: CodeableConcept

    @IsOptional()
    @IsNumber()
    length?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstanceNucleicAcidSubunitLinkageDto)
    linkage?: SubstanceNucleicAcidSubunitLinkage[]

    @IsOptional()
    @IsString()
    sequence?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    sequenceAttachment?: Attachment

    @IsOptional()
    @IsNumber()
    subunit?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstanceNucleicAcidSubunitSugarDto)
    sugar?: SubstanceNucleicAcidSubunitSugar[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    threePrime?: CodeableConcept

  }
  export class SubstanceNucleicAcidDto implements SubstanceNucleicAcid {
    @IsNotEmpty()
    @IsIn(["SubstanceNucleicAcid"])
    resourceType: "SubstanceNucleicAcid"

    @IsOptional()
    @IsString()
    areaOfHybridisation?: string

    @IsOptional()
    @IsNumber()
    numberOfSubunits?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    oligoNucleotideType?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    sequenceType?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstanceNucleicAcidSubunitDto)
    subunit?: SubstanceNucleicAcidSubunit[]

  }
  export class SubstancePolymerMonomerSetStartingMaterialDto implements SubstancePolymerMonomerSetStartingMaterial {
    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    amount?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    isDefining: boolean

  }
  export class SubstancePolymerMonomerSetDto implements SubstancePolymerMonomerSet {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    ratioType?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstancePolymerMonomerSetStartingMaterialDto)
    startingMaterial?: SubstancePolymerMonomerSetStartingMaterial[]

  }
  export class SubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationDto implements SubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation {
    @IsOptional()
    @IsNumber()
    average?: number

    @IsOptional()
    @IsNumber()
    high?: number

    @IsOptional()
    @IsNumber()
    low?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class SubstancePolymerRepeatRepeatUnitStructuralRepresentationDto implements SubstancePolymerRepeatRepeatUnitStructuralRepresentation {
    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    attachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    format?: CodeableConcept

    @IsOptional()
    @IsString()
    representation?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class SubstancePolymerRepeatRepeatUnitDto implements SubstancePolymerRepeatRepeatUnit {
    @IsOptional()
    @IsNumber()
    amount?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationDto)
    degreeOfPolymerisation?: SubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    orientation?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstancePolymerRepeatRepeatUnitStructuralRepresentationDto)
    structuralRepresentation?: SubstancePolymerRepeatRepeatUnitStructuralRepresentation[]

    @IsOptional()
    @IsString()
    unit?: string

  }
  export class SubstancePolymerRepeatDto implements SubstancePolymerRepeat {
    @IsOptional()
    @IsString()
    averageMolecularFormula?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstancePolymerRepeatRepeatUnitDto)
    repeatUnit?: SubstancePolymerRepeatRepeatUnit[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    repeatUnitAmountType?: CodeableConcept

  }
  export class SubstancePolymerDto implements SubstancePolymer {
    @IsNotEmpty()
    @IsIn(["SubstancePolymer"])
    resourceType: "SubstancePolymer"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    class?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    copolymerConnectivity?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    geometry?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsOptional()
    @IsString()
    modification?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstancePolymerMonomerSetDto)
    monomerSet?: SubstancePolymerMonomerSet[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstancePolymerRepeatDto)
    repeat?: SubstancePolymerRepeat[]

  }
  export class SubstanceProteinSubunitDto implements SubstanceProteinSubunit {
    @IsOptional()
    @IsString()
    cTerminalModification?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    cTerminalModificationId?: Identifier

    @IsOptional()
    @IsNumber()
    length?: number

    @IsOptional()
    @IsString()
    nTerminalModification?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    nTerminalModificationId?: Identifier

    @IsOptional()
    @IsString()
    sequence?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    sequenceAttachment?: Attachment

    @IsOptional()
    @IsNumber()
    subunit?: number

  }
  export class SubstanceProteinDto implements SubstanceProtein {
    @IsNotEmpty()
    @IsIn(["SubstanceProtein"])
    resourceType: "SubstanceProtein"

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    disulfideLinkage?: string[]

    @IsOptional()
    @IsNumber()
    numberOfSubunits?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    sequenceType?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstanceProteinSubunitDto)
    subunit?: SubstanceProteinSubunit[]

  }
  export class SubstanceReferenceInformationGeneDto implements SubstanceReferenceInformationGene {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    gene?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    geneSequenceOrigin?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    source?: Reference[]

  }
  export class SubstanceReferenceInformationGeneElementDto implements SubstanceReferenceInformationGeneElement {
    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    element?: Identifier

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    source?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class SubstanceReferenceInformationTargetDto implements SubstanceReferenceInformationTarget {
    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    amountQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    amountRange?: Range

    @IsOptional()
    @IsString()
    amountString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    amountType?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    interaction?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    organism?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    organismType?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    source?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    target?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class SubstanceReferenceInformationDto implements SubstanceReferenceInformation {
    @IsNotEmpty()
    @IsIn(["SubstanceReferenceInformation"])
    resourceType: "SubstanceReferenceInformation"

    @IsOptional()
    @IsString()
    comment?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstanceReferenceInformationGeneDto)
    gene?: SubstanceReferenceInformationGene[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstanceReferenceInformationGeneElementDto)
    geneElement?: SubstanceReferenceInformationGeneElement[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstanceReferenceInformationTargetDto)
    target?: SubstanceReferenceInformationTarget[]

  }
  export class SubstanceSourceMaterialFractionDescriptionDto implements SubstanceSourceMaterialFractionDescription {
    @IsOptional()
    @IsString()
    fraction?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    materialType?: CodeableConcept

  }
  export class SubstanceSourceMaterialOrganismAuthorDto implements SubstanceSourceMaterialOrganismAuthor {
    @IsOptional()
    @IsString()
    authorDescription?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    authorType?: CodeableConcept

  }
  export class SubstanceSourceMaterialOrganismHybridDto implements SubstanceSourceMaterialOrganismHybrid {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    hybridType?: CodeableConcept

    @IsOptional()
    @IsString()
    maternalOrganismId?: string

    @IsOptional()
    @IsString()
    maternalOrganismName?: string

    @IsOptional()
    @IsString()
    paternalOrganismId?: string

    @IsOptional()
    @IsString()
    paternalOrganismName?: string

  }
  export class SubstanceSourceMaterialOrganismOrganismGeneralDto implements SubstanceSourceMaterialOrganismOrganismGeneral {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    class?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    kingdom?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    order?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    phylum?: CodeableConcept

  }
  export class SubstanceSourceMaterialOrganismDto implements SubstanceSourceMaterialOrganism {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstanceSourceMaterialOrganismAuthorDto)
    author?: SubstanceSourceMaterialOrganismAuthor[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    family?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    genus?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => SubstanceSourceMaterialOrganismHybridDto)
    hybrid?: SubstanceSourceMaterialOrganismHybrid

    @IsOptional()
    @IsString()
    intraspecificDescription?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    intraspecificType?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => SubstanceSourceMaterialOrganismOrganismGeneralDto)
    organismGeneral?: SubstanceSourceMaterialOrganismOrganismGeneral

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    species?: CodeableConcept

  }
  export class SubstanceSourceMaterialPartDescriptionDto implements SubstanceSourceMaterialPartDescription {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    part?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    partLocation?: CodeableConcept

  }
  export class SubstanceSourceMaterialDto implements SubstanceSourceMaterial {
    @IsNotEmpty()
    @IsIn(["SubstanceSourceMaterial"])
    resourceType: "SubstanceSourceMaterial"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    countryOfOrigin?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    developmentStage?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstanceSourceMaterialFractionDescriptionDto)
    fractionDescription?: SubstanceSourceMaterialFractionDescription[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    geographicalLocation?: string[]

    @IsOptional()
    @ValidateNested()
    @Type(() => SubstanceSourceMaterialOrganismDto)
    organism?: SubstanceSourceMaterialOrganism

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    organismId?: Identifier

    @IsOptional()
    @IsString()
    organismName?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    parentSubstanceId?: Identifier[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    parentSubstanceName?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstanceSourceMaterialPartDescriptionDto)
    partDescription?: SubstanceSourceMaterialPartDescription[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    sourceMaterialClass?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    sourceMaterialState?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    sourceMaterialType?: CodeableConcept

  }
  export class SupplyDeliverySuppliedItemDto implements SupplyDeliverySuppliedItem {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    itemCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    itemReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

  }
  export class SupplyDeliveryDto implements SupplyDelivery {
    @IsNotEmpty()
    @IsIn(["SupplyDelivery"])
    resourceType: "SupplyDelivery"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    destination?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsString()
    occurrenceDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    occurrencePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    occurrenceTiming?: Timing

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    partOf?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    receiver?: Reference[]

    @IsNotEmpty()
    @IsIn(["entered-in-error", "in-progress", "completed", "abandoned"])
    status: "entered-in-error" | "in-progress" | "completed" | "abandoned"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SupplyDeliverySuppliedItemDto)
    suppliedItem?: SupplyDeliverySuppliedItem[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    supplier?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class SupplyRequestParameterDto implements SupplyRequestParameter {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

  }
  export class SupplyRequestDto implements SupplyRequest {
    @IsNotEmpty()
    @IsIn(["SupplyRequest"])
    resourceType: "SupplyRequest"

    @IsOptional()
    @IsString()
    authoredOn?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    deliverFor?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    deliverFrom?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    deliverTo?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    item: CodeableReference

    @IsOptional()
    @IsString()
    occurrenceDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    occurrencePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    occurrenceTiming?: Timing

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SupplyRequestParameterDto)
    parameter?: SupplyRequestParameter[]

    @IsNotEmpty()
    @IsIn(["routine", "urgent", "asap", "stat"])
    priority: "routine" | "urgent" | "asap" | "stat"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity: Quantity

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    reason?: CodeableReference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    requester?: Reference

    @IsNotEmpty()
    @IsIn(["draft", "active", "unknown", "entered-in-error", "completed", "cancelled", "suspended"])
    status: "draft" | "active" | "unknown" | "entered-in-error" | "completed" | "cancelled" | "suspended"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    supplier?: Reference[]

  }
  export class TaskPerformerDto implements TaskPerformer {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    actor: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    function?: CodeableConcept

  }
  export class TaskRestrictionDto implements TaskRestriction {
    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    recipient?: Reference[]

    @IsOptional()
    @IsNumber()
    repetitions?: number

  }
  export class TaskInputDto implements TaskInput {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @IsString()
    valueBase64Binary?: string

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsString()
    valueCanonical?: string

    @IsOptional()
    @IsString()
    valueCode?: string

    @IsOptional()
    @IsString()
    valueDate?: string

    @IsOptional()
    @IsString()
    valueDateTime?: string

    @IsOptional()
    @IsNumber()
    valueDecimal?: number

    @IsOptional()
    @IsString()
    valueId?: string

    @IsOptional()
    @IsString()
    valueInstant?: string

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsOptional()
    @IsString()
    valueInteger64?: string

    @IsOptional()
    @IsString()
    valueMarkdown?: string

    @IsOptional()
    @IsString()
    valueOid?: string

    @IsOptional()
    @IsNumber()
    valuePositiveInt?: number

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @IsString()
    valueTime?: string

    @IsOptional()
    @IsNumber()
    valueUnsignedInt?: number

    @IsOptional()
    @IsString()
    valueUri?: string

    @IsOptional()
    @IsString()
    valueUrl?: string

    @IsOptional()
    @IsString()
    valueUuid?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    valueAddress?: Address

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    valueAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => AnnotationDto)
    valueAnnotation?: Annotation

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    valueCodeableReference?: CodeableReference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    valueCoding?: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactPointDto)
    valueContactPoint?: ContactPoint

    @IsOptional()
    @ValidateNested()
    @Type(() => CountDto)
    valueCount?: Count

    @IsOptional()
    @ValidateNested()
    @Type(() => DistanceDto)
    valueDistance?: Distance

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    valueDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => HumanNameDto)
    valueHumanName?: HumanName

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    valueIdentifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    valueMoney?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    valuePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    valueRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioRangeDto)
    valueRatioRange?: RatioRange

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => SampledDataDto)
    valueSampledData?: SampledData

    @IsOptional()
    @ValidateNested()
    @Type(() => SignatureDto)
    valueSignature?: Signature

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    valueTiming?: Timing

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactDetailDto)
    valueContactDetail?: ContactDetail

    @IsOptional()
    @ValidateNested()
    @Type(() => DataRequirementDto)
    valueDataRequirement?: DataRequirement

    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    valueExpression?: Expression

    @IsOptional()
    @ValidateNested()
    @Type(() => ParameterDefinitionDto)
    valueParameterDefinition?: ParameterDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => RelatedArtifactDto)
    valueRelatedArtifact?: RelatedArtifact

    @IsOptional()
    @ValidateNested()
    @Type(() => TriggerDefinitionDto)
    valueTriggerDefinition?: TriggerDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => UsageContextDto)
    valueUsageContext?: UsageContext

    @IsOptional()
    @ValidateNested()
    @Type(() => AvailabilityDto)
    valueAvailability?: Availability

    @IsOptional()
    @ValidateNested()
    @Type(() => ExtendedContactDetailDto)
    valueExtendedContactDetail?: ExtendedContactDetail

    @IsOptional()
    @ValidateNested()
    @Type(() => DosageDto)
    valueDosage?: Dosage

    @IsOptional()
    @ValidateNested()
    @Type(() => MetaDto)
    valueMeta?: Meta

  }
  export class TaskOutputDto implements TaskOutput {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @IsString()
    valueBase64Binary?: string

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsString()
    valueCanonical?: string

    @IsOptional()
    @IsString()
    valueCode?: string

    @IsOptional()
    @IsString()
    valueDate?: string

    @IsOptional()
    @IsString()
    valueDateTime?: string

    @IsOptional()
    @IsNumber()
    valueDecimal?: number

    @IsOptional()
    @IsString()
    valueId?: string

    @IsOptional()
    @IsString()
    valueInstant?: string

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsOptional()
    @IsString()
    valueInteger64?: string

    @IsOptional()
    @IsString()
    valueMarkdown?: string

    @IsOptional()
    @IsString()
    valueOid?: string

    @IsOptional()
    @IsNumber()
    valuePositiveInt?: number

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @IsString()
    valueTime?: string

    @IsOptional()
    @IsNumber()
    valueUnsignedInt?: number

    @IsOptional()
    @IsString()
    valueUri?: string

    @IsOptional()
    @IsString()
    valueUrl?: string

    @IsOptional()
    @IsString()
    valueUuid?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    valueAddress?: Address

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    valueAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => AnnotationDto)
    valueAnnotation?: Annotation

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    valueCodeableReference?: CodeableReference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    valueCoding?: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactPointDto)
    valueContactPoint?: ContactPoint

    @IsOptional()
    @ValidateNested()
    @Type(() => CountDto)
    valueCount?: Count

    @IsOptional()
    @ValidateNested()
    @Type(() => DistanceDto)
    valueDistance?: Distance

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    valueDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => HumanNameDto)
    valueHumanName?: HumanName

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    valueIdentifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    valueMoney?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    valuePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    valueRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioRangeDto)
    valueRatioRange?: RatioRange

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => SampledDataDto)
    valueSampledData?: SampledData

    @IsOptional()
    @ValidateNested()
    @Type(() => SignatureDto)
    valueSignature?: Signature

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    valueTiming?: Timing

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactDetailDto)
    valueContactDetail?: ContactDetail

    @IsOptional()
    @ValidateNested()
    @Type(() => DataRequirementDto)
    valueDataRequirement?: DataRequirement

    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    valueExpression?: Expression

    @IsOptional()
    @ValidateNested()
    @Type(() => ParameterDefinitionDto)
    valueParameterDefinition?: ParameterDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => RelatedArtifactDto)
    valueRelatedArtifact?: RelatedArtifact

    @IsOptional()
    @ValidateNested()
    @Type(() => TriggerDefinitionDto)
    valueTriggerDefinition?: TriggerDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => UsageContextDto)
    valueUsageContext?: UsageContext

    @IsOptional()
    @ValidateNested()
    @Type(() => AvailabilityDto)
    valueAvailability?: Availability

    @IsOptional()
    @ValidateNested()
    @Type(() => ExtendedContactDetailDto)
    valueExtendedContactDetail?: ExtendedContactDetail

    @IsOptional()
    @ValidateNested()
    @Type(() => DosageDto)
    valueDosage?: Dosage

    @IsOptional()
    @ValidateNested()
    @Type(() => MetaDto)
    valueMeta?: Meta

  }
  export class TaskDto implements Task {
    @IsNotEmpty()
    @IsIn(["Task"])
    resourceType: "Task"

    @IsOptional()
    @IsString()
    authoredOn?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    businessStatus?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsBoolean()
    doNotPerform: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    executionPeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    focus?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    for?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    groupIdentifier?: Identifier

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TaskInputDto)
    input?: TaskInput[]

    @IsOptional()
    @IsString()
    instantiatesCanonical?: string

    @IsOptional()
    @IsString()
    instantiatesUri?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    insurance?: Reference[]

    @IsNotEmpty()
    @IsIn(["unknown", "proposal", "plan", "order", "original-order", "reflex-order", "filler-order", "instance-order", "option"])
    intent: "unknown" | "proposal" | "plan" | "order" | "original-order" | "reflex-order" | "filler-order" | "instance-order" | "option"

    @IsOptional()
    @IsString()
    lastModified?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    location?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TaskOutputDto)
    output?: TaskOutput[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    owner?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    partOf?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TaskPerformerDto)
    performer?: TaskPerformer[]

    @IsNotEmpty()
    @IsIn(["routine", "urgent", "asap", "stat"])
    priority: "routine" | "urgent" | "asap" | "stat"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    reason?: CodeableReference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    relevantHistory?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    requestedPerformer?: CodeableReference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    requestedPeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    requester?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => TaskRestrictionDto)
    restriction?: TaskRestriction

    @IsNotEmpty()
    @IsIn(["draft", "entered-in-error", "on-hold", "in-progress", "completed", "accepted", "cancelled", "rejected", "requested", "received", "ready", "failed"])
    status: "draft" | "entered-in-error" | "on-hold" | "in-progress" | "completed" | "accepted" | "cancelled" | "rejected" | "requested" | "received" | "ready" | "failed"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    statusReason?: CodeableReference

  }
  export class TerminologyCapabilitiesSoftwareDto implements TerminologyCapabilitiesSoftware {
    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @IsString()
    version?: string

  }
  export class TerminologyCapabilitiesImplementationDto implements TerminologyCapabilitiesImplementation {
    @IsNotEmpty()
    @IsString()
    description: string

    @IsOptional()
    @IsString()
    url?: string

  }
  export class TerminologyCapabilitiesCodeSystemVersionFilterDto implements TerminologyCapabilitiesCodeSystemVersionFilter {
    @IsNotEmpty()
    @IsString()
    code: string

    @IsNotEmpty()
    @IsArray()
    @IsString({ each: true })
    op: string[]

  }
  export class TerminologyCapabilitiesCodeSystemVersionDto implements TerminologyCapabilitiesCodeSystemVersion {
    @IsOptional()
    @IsString()
    code?: string

    @IsNotEmpty()
    @IsBoolean()
    compositional: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TerminologyCapabilitiesCodeSystemVersionFilterDto)
    filter?: TerminologyCapabilitiesCodeSystemVersionFilter[]

    @IsNotEmpty()
    @IsBoolean()
    isDefault: boolean

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    language?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    property?: string[]

  }
  export class TerminologyCapabilitiesCodeSystemDto implements TerminologyCapabilitiesCodeSystem {
    @IsNotEmpty()
    @IsIn(["example", "complete", "not-present", "fragment", "supplement"])
    content: "example" | "complete" | "not-present" | "fragment" | "supplement"

    @IsNotEmpty()
    @IsBoolean()
    subsumption: boolean

    @IsOptional()
    @IsString()
    uri?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TerminologyCapabilitiesCodeSystemVersionDto)
    version?: TerminologyCapabilitiesCodeSystemVersion[]

  }
  export class TerminologyCapabilitiesExpansionParameterDto implements TerminologyCapabilitiesExpansionParameter {
    @IsOptional()
    @IsString()
    documentation?: string

    @IsNotEmpty()
    @IsString()
    name: string

  }
  export class TerminologyCapabilitiesExpansionDto implements TerminologyCapabilitiesExpansion {
    @IsNotEmpty()
    @IsBoolean()
    hierarchical: boolean

    @IsNotEmpty()
    @IsBoolean()
    incomplete: boolean

    @IsNotEmpty()
    @IsBoolean()
    paging: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TerminologyCapabilitiesExpansionParameterDto)
    parameter?: TerminologyCapabilitiesExpansionParameter[]

    @IsOptional()
    @IsString()
    textFilter?: string

  }
  export class TerminologyCapabilitiesValidateCodeDto implements TerminologyCapabilitiesValidateCode {
    @IsNotEmpty()
    @IsBoolean()
    translations: boolean

  }
  export class TerminologyCapabilitiesTranslationDto implements TerminologyCapabilitiesTranslation {
    @IsNotEmpty()
    @IsBoolean()
    needsMap: boolean

  }
  export class TerminologyCapabilitiesClosureDto implements TerminologyCapabilitiesClosure {
    @IsNotEmpty()
    @IsBoolean()
    translation: boolean

  }
  export class TerminologyCapabilitiesDto implements TerminologyCapabilities {
    @IsNotEmpty()
    @IsIn(["TerminologyCapabilities"])
    resourceType: "TerminologyCapabilities"

    @IsOptional()
    @ValidateNested()
    @Type(() => TerminologyCapabilitiesClosureDto)
    closure?: TerminologyCapabilitiesClosure

    @IsNotEmpty()
    @IsIn(["in-compose", "in-expansion", "in-compose-or-expansion"])
    codeSearch: "in-compose" | "in-expansion" | "in-compose-or-expansion"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TerminologyCapabilitiesCodeSystemDto)
    codeSystem?: TerminologyCapabilitiesCodeSystem[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    copyrightLabel?: string

    @IsNotEmpty()
    @IsString()
    date: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => TerminologyCapabilitiesExpansionDto)
    expansion?: TerminologyCapabilitiesExpansion

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => TerminologyCapabilitiesImplementationDto)
    implementation?: TerminologyCapabilitiesImplementation

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsNotEmpty()
    @IsIn(["instance", "capability", "requirements"])
    kind: "instance" | "capability" | "requirements"

    @IsNotEmpty()
    @IsBoolean()
    lockedDate: boolean

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => TerminologyCapabilitiesSoftwareDto)
    software?: TerminologyCapabilitiesSoftware

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => TerminologyCapabilitiesTranslationDto)
    translation?: TerminologyCapabilitiesTranslation

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @ValidateNested()
    @Type(() => TerminologyCapabilitiesValidateCodeDto)
    validateCode?: TerminologyCapabilitiesValidateCode

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @IsString()
    versionAlgorithmString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    versionAlgorithmCoding?: Coding

  }
  export class TestPlanDependencyDto implements TestPlanDependency {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    predecessor?: Reference

  }
  export class TestPlanTestCaseDependencyDto implements TestPlanTestCaseDependency {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    predecessor?: Reference

  }
  export class TestPlanTestCaseTestRunScriptDto implements TestPlanTestCaseTestRunScript {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    language?: CodeableConcept

    @IsOptional()
    @IsString()
    sourceString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    sourceReference?: Reference

  }
  export class TestPlanTestCaseTestRunDto implements TestPlanTestCaseTestRun {
    @IsOptional()
    @IsString()
    narrative?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => TestPlanTestCaseTestRunScriptDto)
    script?: TestPlanTestCaseTestRunScript

  }
  export class TestPlanTestCaseTestDataDto implements TestPlanTestCaseTestData {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    content?: Reference

    @IsOptional()
    @IsString()
    sourceString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    sourceReference?: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodingDto)
    type: Coding

  }
  export class TestPlanTestCaseAssertionDto implements TestPlanTestCaseAssertion {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    object?: CodeableReference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    result?: CodeableReference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

  }
  export class TestPlanTestCaseDto implements TestPlanTestCase {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestPlanTestCaseAssertionDto)
    assertion?: TestPlanTestCaseAssertion[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestPlanTestCaseDependencyDto)
    dependency?: TestPlanTestCaseDependency[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    scope?: Reference[]

    @IsOptional()
    @IsNumber()
    sequence?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestPlanTestCaseTestDataDto)
    testData?: TestPlanTestCaseTestData[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestPlanTestCaseTestRunDto)
    testRun?: TestPlanTestCaseTestRun[]

  }
  export class TestPlanDto implements TestPlan {
    @IsNotEmpty()
    @IsIn(["TestPlan"])
    resourceType: "TestPlan"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    copyrightLabel?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestPlanDependencyDto)
    dependency?: TestPlanDependency[]

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    exitCriteria?: string

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    scope?: Reference[]

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestPlanTestCaseDto)
    testCase?: TestPlanTestCase[]

    @IsOptional()
    @IsString()
    testTools?: string

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @IsString()
    versionAlgorithmString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    versionAlgorithmCoding?: Coding

  }
  export class TestReportParticipantDto implements TestReportParticipant {
    @IsOptional()
    @IsString()
    display?: string

    @IsNotEmpty()
    @IsIn(["client", "server", "test-engine"])
    type: "client" | "server" | "test-engine"

    @IsNotEmpty()
    @IsString()
    uri: string

  }
  export class TestReportSetupActionOperationDto implements TestReportSetupActionOperation {
    @IsOptional()
    @IsString()
    detail?: string

    @IsOptional()
    @IsString()
    message?: string

    @IsNotEmpty()
    @IsIn(["error", "warning", "pass", "skip", "fail"])
    result: "error" | "warning" | "pass" | "skip" | "fail"

  }
  export class TestReportSetupActionAssertRequirementDto implements TestReportSetupActionAssertRequirement {
    @IsOptional()
    @IsString()
    linkUri?: string

    @IsOptional()
    @IsString()
    linkCanonical?: string

  }
  export class TestReportSetupActionAssertDto implements TestReportSetupActionAssert {
    @IsOptional()
    @IsString()
    detail?: string

    @IsOptional()
    @IsString()
    message?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestReportSetupActionAssertRequirementDto)
    requirement?: TestReportSetupActionAssertRequirement[]

    @IsNotEmpty()
    @IsIn(["error", "warning", "pass", "skip", "fail"])
    result: "error" | "warning" | "pass" | "skip" | "fail"

  }
  export class TestReportSetupActionDto implements TestReportSetupAction {
    @IsOptional()
    @ValidateNested()
    @Type(() => TestReportSetupActionAssertDto)
    assert?: TestReportSetupActionAssert

    @IsOptional()
    @ValidateNested()
    @Type(() => TestReportSetupActionOperationDto)
    operation?: TestReportSetupActionOperation

  }
  export class TestReportSetupDto implements TestReportSetup {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestReportSetupActionDto)
    action: TestReportSetupAction[]

  }
  export class TestReportTestActionDto implements TestReportTestAction {
    @IsOptional()
    @ValidateNested()
    @Type(() => TestReportSetupActionAssertDto)
    assert?: TestReportSetupActionAssert

    @IsOptional()
    @ValidateNested()
    @Type(() => TestReportSetupActionOperationDto)
    operation?: TestReportSetupActionOperation

  }
  export class TestReportTestDto implements TestReportTest {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestReportTestActionDto)
    action: TestReportTestAction[]

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    name?: string

  }
  export class TestReportTeardownActionDto implements TestReportTeardownAction {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => TestReportSetupActionOperationDto)
    operation: TestReportSetupActionOperation

  }
  export class TestReportTeardownDto implements TestReportTeardown {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestReportTeardownActionDto)
    action: TestReportTeardownAction[]

  }
  export class TestReportDto implements TestReport {
    @IsNotEmpty()
    @IsIn(["TestReport"])
    resourceType: "TestReport"

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsOptional()
    @IsString()
    issued?: string

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestReportParticipantDto)
    participant?: TestReportParticipant[]

    @IsNotEmpty()
    @IsIn(["pending", "pass", "fail"])
    result: "pending" | "pass" | "fail"

    @IsOptional()
    @IsNumber()
    score?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => TestReportSetupDto)
    setup?: TestReportSetup

    @IsNotEmpty()
    @IsIn(["entered-in-error", "in-progress", "completed", "stopped", "waiting"])
    status: "entered-in-error" | "in-progress" | "completed" | "stopped" | "waiting"

    @IsOptional()
    @ValidateNested()
    @Type(() => TestReportTeardownDto)
    teardown?: TestReportTeardown

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestReportTestDto)
    test?: TestReportTest[]

    @IsOptional()
    @IsString()
    tester?: string

    @IsNotEmpty()
    @IsString()
    testScript: string

  }
  export class TestScriptOriginDto implements TestScriptOrigin {
    @IsNotEmpty()
    @IsNumber()
    index: number

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodingDto)
    profile: Coding

    @IsOptional()
    @IsString()
    url?: string

  }
  export class TestScriptDestinationDto implements TestScriptDestination {
    @IsNotEmpty()
    @IsNumber()
    index: number

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodingDto)
    profile: Coding

    @IsOptional()
    @IsString()
    url?: string

  }
  export class TestScriptMetadataLinkDto implements TestScriptMetadataLink {
    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsString()
    url: string

  }
  export class TestScriptMetadataCapabilityDto implements TestScriptMetadataCapability {
    @IsNotEmpty()
    @IsString()
    capabilities: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsNumber()
    destination?: number

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    link?: string[]

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    origin?: number[]

    @IsNotEmpty()
    @IsBoolean()
    required: boolean

    @IsNotEmpty()
    @IsBoolean()
    validated: boolean

  }
  export class TestScriptMetadataDto implements TestScriptMetadata {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestScriptMetadataCapabilityDto)
    capability: TestScriptMetadataCapability[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestScriptMetadataLinkDto)
    link?: TestScriptMetadataLink[]

  }
  export class TestScriptScopeDto implements TestScriptScope {
    @IsNotEmpty()
    @IsString()
    artifact: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    conformance?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    phase?: CodeableConcept

  }
  export class TestScriptFixtureDto implements TestScriptFixture {
    @IsNotEmpty()
    @IsBoolean()
    autocreate: boolean

    @IsNotEmpty()
    @IsBoolean()
    autodelete: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    resource?: Reference

  }
  export class TestScriptVariableDto implements TestScriptVariable {
    @IsOptional()
    @IsString()
    defaultValue?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    expression?: string

    @IsOptional()
    @IsString()
    headerField?: string

    @IsOptional()
    @IsString()
    hint?: string

    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @IsString()
    path?: string

    @IsOptional()
    @IsString()
    sourceId?: string

  }
  export class TestScriptSetupActionOperationRequestHeaderDto implements TestScriptSetupActionOperationRequestHeader {
    @IsNotEmpty()
    @IsString()
    field: string

    @IsNotEmpty()
    @IsString()
    value: string

  }
  export class TestScriptSetupActionOperationDto implements TestScriptSetupActionOperation {
    @IsOptional()
    @IsString()
    accept?: string

    @IsOptional()
    @IsString()
    contentType?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsNumber()
    destination?: number

    @IsNotEmpty()
    @IsBoolean()
    encodeRequestUrl: boolean

    @IsOptional()
    @IsString()
    label?: string

    @IsNotEmpty()
    @IsIn(["patch", "delete", "get", "options", "post", "put", "head"])
    method: "patch" | "delete" | "get" | "options" | "post" | "put" | "head"

    @IsOptional()
    @IsNumber()
    origin?: number

    @IsOptional()
    @IsString()
    params?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestScriptSetupActionOperationRequestHeaderDto)
    requestHeader?: TestScriptSetupActionOperationRequestHeader[]

    @IsOptional()
    @IsString()
    requestId?: string

    @IsOptional()
    @IsString()
    resource?: string

    @IsOptional()
    @IsString()
    responseId?: string

    @IsOptional()
    @IsString()
    sourceId?: string

    @IsOptional()
    @IsString()
    targetId?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    type?: Coding

    @IsOptional()
    @IsString()
    url?: string

  }
  export class TestScriptSetupActionAssertRequirementDto implements TestScriptSetupActionAssertRequirement {
    @IsOptional()
    @IsString()
    linkUri?: string

    @IsOptional()
    @IsString()
    linkCanonical?: string

  }
  export class TestScriptSetupActionAssertDto implements TestScriptSetupActionAssert {
    @IsOptional()
    @IsString()
    compareToSourceExpression?: string

    @IsOptional()
    @IsString()
    compareToSourceId?: string

    @IsOptional()
    @IsString()
    compareToSourcePath?: string

    @IsOptional()
    @IsString()
    contentType?: string

    @IsNotEmpty()
    @IsIn(["stop", "pass", "skip", "fail"])
    defaultManualCompletion: "stop" | "pass" | "skip" | "fail"

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsIn(["response", "request"])
    direction: "response" | "request"

    @IsOptional()
    @IsString()
    expression?: string

    @IsOptional()
    @IsString()
    headerField?: string

    @IsOptional()
    @IsString()
    label?: string

    @IsOptional()
    @IsString()
    minimumId?: string

    @IsNotEmpty()
    @IsBoolean()
    navigationLinks: boolean

    @IsNotEmpty()
    @IsIn(["empty", "in", "contains", "equals", "notEquals", "notIn", "greaterThan", "lessThan", "notEmpty", "notContains", "eval", "manualEval"])
    operator: "empty" | "in" | "contains" | "equals" | "notEquals" | "notIn" | "greaterThan" | "lessThan" | "notEmpty" | "notContains" | "eval" | "manualEval"

    @IsOptional()
    @IsString()
    path?: string

    @IsNotEmpty()
    @IsIn(["patch", "delete", "get", "options", "post", "put", "head"])
    requestMethod: "patch" | "delete" | "get" | "options" | "post" | "put" | "head"

    @IsOptional()
    @IsString()
    requestURL?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestScriptSetupActionAssertRequirementDto)
    requirement?: TestScriptSetupActionAssertRequirement[]

    @IsOptional()
    @IsString()
    resource?: string

    @IsNotEmpty()
    @IsIn(["accepted", "continue", "switchingProtocols", "okay", "created", "nonAuthoritativeInformation", "noContent", "resetContent", "partialContent", "multipleChoices", "movedPermanently", "found", "seeOther", "notModified", "useProxy", "temporaryRedirect", "permanentRedirect", "badRequest", "unauthorized", "paymentRequired", "forbidden", "notFound", "methodNotAllowed", "notAcceptable", "proxyAuthenticationRequired", "requestTimeout", "conflict", "gone", "lengthRequired", "preconditionFailed", "contentTooLarge", "uriTooLong", "unsupportedMediaType", "rangeNotSatisfiable", "expectationFailed", "misdirectedRequest", "unprocessableContent", "upgradeRequired", "internalServerError", "notImplemented", "badGateway", "serviceUnavailable", "gatewayTimeout", "httpVersionNotSupported"])
    response: "accepted" | "continue" | "switchingProtocols" | "okay" | "created" | "nonAuthoritativeInformation" | "noContent" | "resetContent" | "partialContent" | "multipleChoices" | "movedPermanently" | "found" | "seeOther" | "notModified" | "useProxy" | "temporaryRedirect" | "permanentRedirect" | "badRequest" | "unauthorized" | "paymentRequired" | "forbidden" | "notFound" | "methodNotAllowed" | "notAcceptable" | "proxyAuthenticationRequired" | "requestTimeout" | "conflict" | "gone" | "lengthRequired" | "preconditionFailed" | "contentTooLarge" | "uriTooLong" | "unsupportedMediaType" | "rangeNotSatisfiable" | "expectationFailed" | "misdirectedRequest" | "unprocessableContent" | "upgradeRequired" | "internalServerError" | "notImplemented" | "badGateway" | "serviceUnavailable" | "gatewayTimeout" | "httpVersionNotSupported"

    @IsOptional()
    @IsString()
    responseCode?: string

    @IsOptional()
    @IsString()
    sourceId?: string

    @IsNotEmpty()
    @IsBoolean()
    stopTestOnFail: boolean

    @IsOptional()
    @IsString()
    validateProfileId?: string

    @IsOptional()
    @IsString()
    value?: string

    @IsNotEmpty()
    @IsBoolean()
    warningOnly: boolean

  }
  export class TestScriptSetupActionDto implements TestScriptSetupAction {
    @IsOptional()
    @ValidateNested()
    @Type(() => TestScriptSetupActionAssertDto)
    assert?: TestScriptSetupActionAssert

    @IsOptional()
    @ValidateNested()
    @Type(() => TestScriptSetupActionOperationDto)
    operation?: TestScriptSetupActionOperation

  }
  export class TestScriptSetupDto implements TestScriptSetup {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestScriptSetupActionDto)
    action: TestScriptSetupAction[]

  }
  export class TestScriptTestActionDto implements TestScriptTestAction {
    @IsOptional()
    @ValidateNested()
    @Type(() => TestScriptSetupActionAssertDto)
    assert?: TestScriptSetupActionAssert

    @IsOptional()
    @ValidateNested()
    @Type(() => TestScriptSetupActionOperationDto)
    operation?: TestScriptSetupActionOperation

  }
  export class TestScriptTestDto implements TestScriptTest {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestScriptTestActionDto)
    action: TestScriptTestAction[]

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    name?: string

  }
  export class TestScriptTeardownActionDto implements TestScriptTeardownAction {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => TestScriptSetupActionOperationDto)
    operation: TestScriptSetupActionOperation

  }
  export class TestScriptTeardownDto implements TestScriptTeardown {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestScriptTeardownActionDto)
    action: TestScriptTeardownAction[]

  }
  export class TestScriptDto implements TestScript {
    @IsNotEmpty()
    @IsIn(["TestScript"])
    resourceType: "TestScript"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    copyrightLabel?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestScriptDestinationDto)
    destination?: TestScriptDestination[]

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestScriptFixtureDto)
    fixture?: TestScriptFixture[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => TestScriptMetadataDto)
    metadata?: TestScriptMetadata

    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestScriptOriginDto)
    origin?: TestScriptOrigin[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    profile?: string[]

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestScriptScopeDto)
    scope?: TestScriptScope[]

    @IsOptional()
    @ValidateNested()
    @Type(() => TestScriptSetupDto)
    setup?: TestScriptSetup

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @ValidateNested()
    @Type(() => TestScriptTeardownDto)
    teardown?: TestScriptTeardown

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestScriptTestDto)
    test?: TestScriptTest[]

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestScriptVariableDto)
    variable?: TestScriptVariable[]

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @IsString()
    versionAlgorithmString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    versionAlgorithmCoding?: Coding

  }
  export class TransportRestrictionDto implements TransportRestriction {
    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    recipient?: Reference[]

    @IsOptional()
    @IsNumber()
    repetitions?: number

  }
  export class TransportInputDto implements TransportInput {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @IsString()
    valueBase64Binary?: string

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsString()
    valueCanonical?: string

    @IsOptional()
    @IsString()
    valueCode?: string

    @IsOptional()
    @IsString()
    valueDate?: string

    @IsOptional()
    @IsString()
    valueDateTime?: string

    @IsOptional()
    @IsNumber()
    valueDecimal?: number

    @IsOptional()
    @IsString()
    valueId?: string

    @IsOptional()
    @IsString()
    valueInstant?: string

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsOptional()
    @IsString()
    valueInteger64?: string

    @IsOptional()
    @IsString()
    valueMarkdown?: string

    @IsOptional()
    @IsString()
    valueOid?: string

    @IsOptional()
    @IsNumber()
    valuePositiveInt?: number

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @IsString()
    valueTime?: string

    @IsOptional()
    @IsNumber()
    valueUnsignedInt?: number

    @IsOptional()
    @IsString()
    valueUri?: string

    @IsOptional()
    @IsString()
    valueUrl?: string

    @IsOptional()
    @IsString()
    valueUuid?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    valueAddress?: Address

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    valueAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => AnnotationDto)
    valueAnnotation?: Annotation

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    valueCodeableReference?: CodeableReference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    valueCoding?: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactPointDto)
    valueContactPoint?: ContactPoint

    @IsOptional()
    @ValidateNested()
    @Type(() => CountDto)
    valueCount?: Count

    @IsOptional()
    @ValidateNested()
    @Type(() => DistanceDto)
    valueDistance?: Distance

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    valueDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => HumanNameDto)
    valueHumanName?: HumanName

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    valueIdentifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    valueMoney?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    valuePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    valueRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioRangeDto)
    valueRatioRange?: RatioRange

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => SampledDataDto)
    valueSampledData?: SampledData

    @IsOptional()
    @ValidateNested()
    @Type(() => SignatureDto)
    valueSignature?: Signature

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    valueTiming?: Timing

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactDetailDto)
    valueContactDetail?: ContactDetail

    @IsOptional()
    @ValidateNested()
    @Type(() => DataRequirementDto)
    valueDataRequirement?: DataRequirement

    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    valueExpression?: Expression

    @IsOptional()
    @ValidateNested()
    @Type(() => ParameterDefinitionDto)
    valueParameterDefinition?: ParameterDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => RelatedArtifactDto)
    valueRelatedArtifact?: RelatedArtifact

    @IsOptional()
    @ValidateNested()
    @Type(() => TriggerDefinitionDto)
    valueTriggerDefinition?: TriggerDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => UsageContextDto)
    valueUsageContext?: UsageContext

    @IsOptional()
    @ValidateNested()
    @Type(() => AvailabilityDto)
    valueAvailability?: Availability

    @IsOptional()
    @ValidateNested()
    @Type(() => ExtendedContactDetailDto)
    valueExtendedContactDetail?: ExtendedContactDetail

    @IsOptional()
    @ValidateNested()
    @Type(() => DosageDto)
    valueDosage?: Dosage

    @IsOptional()
    @ValidateNested()
    @Type(() => MetaDto)
    valueMeta?: Meta

  }
  export class TransportOutputDto implements TransportOutput {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @IsString()
    valueBase64Binary?: string

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsString()
    valueCanonical?: string

    @IsOptional()
    @IsString()
    valueCode?: string

    @IsOptional()
    @IsString()
    valueDate?: string

    @IsOptional()
    @IsString()
    valueDateTime?: string

    @IsOptional()
    @IsNumber()
    valueDecimal?: number

    @IsOptional()
    @IsString()
    valueId?: string

    @IsOptional()
    @IsString()
    valueInstant?: string

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsOptional()
    @IsString()
    valueInteger64?: string

    @IsOptional()
    @IsString()
    valueMarkdown?: string

    @IsOptional()
    @IsString()
    valueOid?: string

    @IsOptional()
    @IsNumber()
    valuePositiveInt?: number

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @IsString()
    valueTime?: string

    @IsOptional()
    @IsNumber()
    valueUnsignedInt?: number

    @IsOptional()
    @IsString()
    valueUri?: string

    @IsOptional()
    @IsString()
    valueUrl?: string

    @IsOptional()
    @IsString()
    valueUuid?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    valueAddress?: Address

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    valueAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => AnnotationDto)
    valueAnnotation?: Annotation

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    valueCodeableReference?: CodeableReference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    valueCoding?: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactPointDto)
    valueContactPoint?: ContactPoint

    @IsOptional()
    @ValidateNested()
    @Type(() => CountDto)
    valueCount?: Count

    @IsOptional()
    @ValidateNested()
    @Type(() => DistanceDto)
    valueDistance?: Distance

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    valueDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => HumanNameDto)
    valueHumanName?: HumanName

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    valueIdentifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    valueMoney?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    valuePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    valueRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioRangeDto)
    valueRatioRange?: RatioRange

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => SampledDataDto)
    valueSampledData?: SampledData

    @IsOptional()
    @ValidateNested()
    @Type(() => SignatureDto)
    valueSignature?: Signature

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    valueTiming?: Timing

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactDetailDto)
    valueContactDetail?: ContactDetail

    @IsOptional()
    @ValidateNested()
    @Type(() => DataRequirementDto)
    valueDataRequirement?: DataRequirement

    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    valueExpression?: Expression

    @IsOptional()
    @ValidateNested()
    @Type(() => ParameterDefinitionDto)
    valueParameterDefinition?: ParameterDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => RelatedArtifactDto)
    valueRelatedArtifact?: RelatedArtifact

    @IsOptional()
    @ValidateNested()
    @Type(() => TriggerDefinitionDto)
    valueTriggerDefinition?: TriggerDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => UsageContextDto)
    valueUsageContext?: UsageContext

    @IsOptional()
    @ValidateNested()
    @Type(() => AvailabilityDto)
    valueAvailability?: Availability

    @IsOptional()
    @ValidateNested()
    @Type(() => ExtendedContactDetailDto)
    valueExtendedContactDetail?: ExtendedContactDetail

    @IsOptional()
    @ValidateNested()
    @Type(() => DosageDto)
    valueDosage?: Dosage

    @IsOptional()
    @ValidateNested()
    @Type(() => MetaDto)
    valueMeta?: Meta

  }
  export class TransportDto implements Transport {
    @IsNotEmpty()
    @IsIn(["Transport"])
    resourceType: "Transport"

    @IsOptional()
    @IsString()
    authoredOn?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsString()
    completionTime?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    currentLocation: Reference

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    focus?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    for?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    groupIdentifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    history?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TransportInputDto)
    input?: TransportInput[]

    @IsOptional()
    @IsString()
    instantiatesCanonical?: string

    @IsOptional()
    @IsString()
    instantiatesUri?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    insurance?: Reference[]

    @IsNotEmpty()
    @IsIn(["unknown", "proposal", "plan", "order", "original-order", "reflex-order", "filler-order", "instance-order", "option"])
    intent: "unknown" | "proposal" | "plan" | "order" | "original-order" | "reflex-order" | "filler-order" | "instance-order" | "option"

    @IsOptional()
    @IsString()
    lastModified?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    location?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TransportOutputDto)
    output?: TransportOutput[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    owner?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    partOf?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    performerType?: CodeableConcept[]

    @IsNotEmpty()
    @IsIn(["routine", "urgent", "asap", "stat"])
    priority: "routine" | "urgent" | "asap" | "stat"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    reason?: CodeableReference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    relevantHistory?: Reference[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    requestedLocation: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    requester?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => TransportRestrictionDto)
    restriction?: TransportRestriction

    @IsNotEmpty()
    @IsIn(["entered-in-error", "in-progress", "completed", "cancelled", "planned", "abandoned"])
    status: "entered-in-error" | "in-progress" | "completed" | "cancelled" | "planned" | "abandoned"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    statusReason?: CodeableConcept

  }
  export class ValueSetComposeIncludeConceptDesignationDto implements ValueSetComposeIncludeConceptDesignation {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    additionalUse?: Coding[]

    @IsOptional()
    @IsString()
    language?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    use?: Coding

    @IsNotEmpty()
    @IsString()
    value: string

  }
  export class ValueSetComposeIncludeConceptDto implements ValueSetComposeIncludeConcept {
    @IsNotEmpty()
    @IsString()
    code: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ValueSetComposeIncludeConceptDesignationDto)
    designation?: ValueSetComposeIncludeConceptDesignation[]

    @IsOptional()
    @IsString()
    display?: string

  }
  export class ValueSetComposeIncludeFilterDto implements ValueSetComposeIncludeFilter {
    @IsNotEmpty()
    @IsIn(["exists", "in", "=", "is-a", "descendent-of", "is-not-a", "regex", "not-in", "generalizes", "child-of", "descendent-leaf"])
    op: "exists" | "in" | "=" | "is-a" | "descendent-of" | "is-not-a" | "regex" | "not-in" | "generalizes" | "child-of" | "descendent-leaf"

    @IsNotEmpty()
    @IsString()
    property: string

    @IsNotEmpty()
    @IsString()
    value: string

  }
  export class ValueSetComposeIncludeDto implements ValueSetComposeInclude {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ValueSetComposeIncludeConceptDto)
    concept?: ValueSetComposeIncludeConcept[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ValueSetComposeIncludeFilterDto)
    filter?: ValueSetComposeIncludeFilter[]

    @IsOptional()
    @IsString()
    system?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    valueSet?: string[]

    @IsOptional()
    @IsString()
    version?: string

  }
  export class ValueSetComposeDto implements ValueSetCompose {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ValueSetComposeIncludeDto)
    exclude?: ValueSetComposeInclude[]

    @IsNotEmpty()
    @IsBoolean()
    inactive: boolean

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ValueSetComposeIncludeDto)
    include: ValueSetComposeInclude[]

    @IsOptional()
    @IsString()
    lockedDate?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    property?: string[]

  }
  export class ValueSetExpansionParameterDto implements ValueSetExpansionParameter {
    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @IsString()
    valueString?: string

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsOptional()
    @IsNumber()
    valueDecimal?: number

    @IsOptional()
    @IsString()
    valueUri?: string

    @IsOptional()
    @IsString()
    valueCode?: string

    @IsOptional()
    @IsString()
    valueDateTime?: string

  }
  export class ValueSetExpansionPropertyDto implements ValueSetExpansionProperty {
    @IsNotEmpty()
    @IsString()
    code: string

    @IsOptional()
    @IsString()
    uri?: string

  }
  export class ValueSetExpansionContainsPropertySubPropertyDto implements ValueSetExpansionContainsPropertySubProperty {
    @IsNotEmpty()
    @IsString()
    code: string

    @IsOptional()
    @IsString()
    valueCode?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    valueCoding?: Coding

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsString()
    valueDateTime?: string

    @IsOptional()
    @IsNumber()
    valueDecimal?: number

  }
  export class ValueSetExpansionContainsPropertyDto implements ValueSetExpansionContainsProperty {
    @IsNotEmpty()
    @IsString()
    code: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ValueSetExpansionContainsPropertySubPropertyDto)
    subProperty?: ValueSetExpansionContainsPropertySubProperty[]

    @IsOptional()
    @IsString()
    valueCode?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    valueCoding?: Coding

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsString()
    valueDateTime?: string

    @IsOptional()
    @IsNumber()
    valueDecimal?: number

  }
  export class ValueSetExpansionContainsDto implements ValueSetExpansionContains {
    @IsNotEmpty()
    @IsBoolean()
    abstract: boolean

    @IsOptional()
    @IsString()
    code?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ValueSetExpansionContainsDto)
    contains?: ValueSetExpansionContains[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ValueSetComposeIncludeConceptDesignationDto)
    designation?: ValueSetComposeIncludeConceptDesignation[]

    @IsOptional()
    @IsString()
    display?: string

    @IsNotEmpty()
    @IsBoolean()
    inactive: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ValueSetExpansionContainsPropertyDto)
    property?: ValueSetExpansionContainsProperty[]

    @IsOptional()
    @IsString()
    system?: string

    @IsOptional()
    @IsString()
    version?: string

  }
  export class ValueSetExpansionDto implements ValueSetExpansion {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ValueSetExpansionContainsDto)
    contains?: ValueSetExpansionContains[]

    @IsOptional()
    @IsString()
    identifier?: string

    @IsOptional()
    @IsString()
    next?: string

    @IsOptional()
    @IsNumber()
    offset?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ValueSetExpansionParameterDto)
    parameter?: ValueSetExpansionParameter[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ValueSetExpansionPropertyDto)
    property?: ValueSetExpansionProperty[]

    @IsNotEmpty()
    @IsString()
    timestamp: string

    @IsOptional()
    @IsNumber()
    total?: number

  }
  export class ValueSetScopeDto implements ValueSetScope {
    @IsOptional()
    @IsString()
    exclusionCriteria?: string

    @IsOptional()
    @IsString()
    inclusionCriteria?: string

  }
  export class ValueSetDto implements ValueSet {
    @IsNotEmpty()
    @IsIn(["ValueSet"])
    resourceType: "ValueSet"

    @IsOptional()
    @IsString()
    approvalDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    author?: ContactDetail[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ValueSetComposeDto)
    compose?: ValueSetCompose

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    copyrightLabel?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    editor?: ContactDetail[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    endorser?: ContactDetail[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ValueSetExpansionDto)
    expansion?: ValueSetExpansion

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsNotEmpty()
    @IsBoolean()
    immutable: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    lastReviewDate?: string

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    relatedArtifact?: RelatedArtifact[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    reviewer?: ContactDetail[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ValueSetScopeDto)
    scope?: ValueSetScope

    @IsNotEmpty()
    @IsIn(["draft", "active", "retired", "unknown"])
    status: "draft" | "active" | "retired" | "unknown"

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    topic?: CodeableConcept[]

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @IsString()
    versionAlgorithmString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    versionAlgorithmCoding?: Coding

  }
  export class VerificationResultPrimarySourceDto implements VerificationResultPrimarySource {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    canPushUpdates?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    communicationMethod?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    pushTypeAvailable?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

    @IsOptional()
    @IsString()
    validationDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    validationStatus?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    who?: Reference

  }
  export class VerificationResultAttestationDto implements VerificationResultAttestation {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    communicationMethod?: CodeableConcept

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    onBehalfOf?: Reference

    @IsOptional()
    @IsString()
    proxyIdentityCertificate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => SignatureDto)
    proxySignature?: Signature

    @IsOptional()
    @IsString()
    sourceIdentityCertificate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => SignatureDto)
    sourceSignature?: Signature

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    who?: Reference

  }
  export class VerificationResultValidatorDto implements VerificationResultValidator {
    @IsOptional()
    @ValidateNested()
    @Type(() => SignatureDto)
    attestationSignature?: Signature

    @IsOptional()
    @IsString()
    identityCertificate?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    organization: Reference

  }
  export class VerificationResultDto implements VerificationResult {
    @IsNotEmpty()
    @IsIn(["VerificationResult"])
    resourceType: "VerificationResult"

    @IsOptional()
    @ValidateNested()
    @Type(() => VerificationResultAttestationDto)
    attestation?: VerificationResultAttestation

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    failureAction?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    frequency?: Timing

    @IsOptional()
    @IsString()
    lastPerformed?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    need?: CodeableConcept

    @IsOptional()
    @IsString()
    nextScheduled?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => VerificationResultPrimarySourceDto)
    primarySource?: VerificationResultPrimarySource[]

    @IsNotEmpty()
    @IsIn(["entered-in-error", "attested", "validated", "in-process", "req-revalid", "val-fail", "reval-fail"])
    status: "entered-in-error" | "attested" | "validated" | "in-process" | "req-revalid" | "val-fail" | "reval-fail"

    @IsOptional()
    @IsString()
    statusDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    target?: Reference[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    targetLocation?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    validationProcess?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    validationType?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => VerificationResultValidatorDto)
    validator?: VerificationResultValidator[]

  }
  export class VisionPrescriptionLensSpecificationPrismDto implements VisionPrescriptionLensSpecificationPrism {
    @IsNotEmpty()
    @IsNumber()
    amount: number

    @IsNotEmpty()
    @IsIn(["in", "out", "up", "down"])
    base: "in" | "out" | "up" | "down"

  }
  export class VisionPrescriptionLensSpecificationDto implements VisionPrescriptionLensSpecification {
    @IsOptional()
    @IsNumber()
    add?: number

    @IsOptional()
    @IsNumber()
    axis?: number

    @IsOptional()
    @IsNumber()
    backCurve?: number

    @IsOptional()
    @IsString()
    brand?: string

    @IsOptional()
    @IsString()
    color?: string

    @IsOptional()
    @IsNumber()
    cylinder?: number

    @IsOptional()
    @IsNumber()
    diameter?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    duration?: Quantity

    @IsNotEmpty()
    @IsIn(["right", "left"])
    eye: "right" | "left"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsNumber()
    power?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => VisionPrescriptionLensSpecificationPrismDto)
    prism?: VisionPrescriptionLensSpecificationPrism[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    product: CodeableConcept

    @IsOptional()
    @IsNumber()
    sphere?: number

  }
  export class VisionPrescriptionDto implements VisionPrescription {
    @IsNotEmpty()
    @IsIn(["VisionPrescription"])
    resourceType: "VisionPrescription"

    @IsNotEmpty()
    @IsString()
    created: string

    @IsNotEmpty()
    @IsString()
    dateWritten: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => VisionPrescriptionLensSpecificationDto)
    lensSpecification: VisionPrescriptionLensSpecification[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    prescriber: Reference

    @IsNotEmpty()
    @IsIn(["draft", "active", "entered-in-error", "cancelled"])
    status: "draft" | "active" | "entered-in-error" | "cancelled"

  }
}