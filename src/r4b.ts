import { Address, Age, Annotation, Attachment, BackboneElement, CodeableConcept, CodeableReference, Coding, ContactDetail, ContactPoint, Contributor, Count, DataRequirementCodeFilter, DataRequirementDateFilter, DataRequirementSort, DataRequirement, DataType, Distance, DosageDoseAndRate, Dosage, Duration, Element, ElementDefinitionSlicingDiscriminator, ElementDefinitionSlicing, ElementDefinitionBase, ElementDefinitionType, ElementDefinitionExample, ElementDefinitionConstraint, ElementDefinitionBinding, ElementDefinitionMapping, ElementDefinition, Expression, Extension, HumanName, Identifier, MarketingStatus, Meta, Money, Narrative, ParameterDefinition, Period, Population, ProdCharacteristic, ProductShelfLife, Quantity, Range, Ratio, RatioRange, Reference, RelatedArtifact, SampledData, Signature, TimingRepeat, Timing, TriggerDefinition, UsageContext, AccountCoverage, AccountGuarantor, Account, ActivityDefinitionParticipant, ActivityDefinitionDynamicValue, ActivityDefinition, AdministrableProductDefinitionProperty, AdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod, AdministrableProductDefinitionRouteOfAdministrationTargetSpecies, AdministrableProductDefinitionRouteOfAdministration, AdministrableProductDefinition, AdverseEventSuspectEntityCausality, AdverseEventSuspectEntity, AdverseEvent, AllergyIntoleranceReaction, AllergyIntolerance, AppointmentParticipant, Appointment, AppointmentResponse, AuditEventAgentNetwork, AuditEventAgent, AuditEventSource, AuditEventEntityDetail, AuditEventEntity, AuditEvent, Basic, Binary, BiologicallyDerivedProductCollection, BiologicallyDerivedProductProcessing, BiologicallyDerivedProductManipulation, BiologicallyDerivedProductStorage, BiologicallyDerivedProduct, BodyStructure, BundleLink, BundleEntrySearch, BundleEntryRequest, BundleEntryResponse, BundleEntry, Bundle, CapabilityStatementSoftware, CapabilityStatementImplementation, CapabilityStatementRestSecurity, CapabilityStatementRestResourceInteraction, CapabilityStatementRestResourceSearchParam, CapabilityStatementRestResourceOperation, CapabilityStatementRestResource, CapabilityStatementRestInteraction, CapabilityStatementRest, CapabilityStatementMessagingEndpoint, CapabilityStatementMessagingSupportedMessage, CapabilityStatementMessaging, CapabilityStatementDocument, CapabilityStatement, CarePlanActivityDetail, CarePlanActivity, CarePlan, CareTeamParticipant, CareTeam, CatalogEntryRelatedEntry, CatalogEntry, ChargeItemPerformer, ChargeItem, ChargeItemDefinitionApplicability, ChargeItemDefinitionPropertyGroupPriceComponent, ChargeItemDefinitionPropertyGroup, ChargeItemDefinition, CitationSummary, CitationClassification, CitationStatusDate, CitationRelatesTo, CitationCitedArtifactVersion, CitationCitedArtifactStatusDate, CitationCitedArtifactTitle, CitationCitedArtifactAbstract, CitationCitedArtifactPart, CitationCitedArtifactRelatesTo, CitationCitedArtifactPublicationFormPublishedIn, CitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication, CitationCitedArtifactPublicationFormPeriodicRelease, CitationCitedArtifactPublicationForm, CitationCitedArtifactWebLocation, CitationCitedArtifactClassificationWhoClassified, CitationCitedArtifactClassification, CitationCitedArtifactContributorshipEntryAffiliationInfo, CitationCitedArtifactContributorshipEntryContributionInstance, CitationCitedArtifactContributorshipEntry, CitationCitedArtifactContributorshipSummary, CitationCitedArtifactContributorship, CitationCitedArtifact, Citation, ClaimRelated, ClaimPayee, ClaimCareTeam, ClaimSupportingInfo, ClaimDiagnosis, ClaimProcedure, ClaimInsurance, ClaimAccident, ClaimItemDetailSubDetail, ClaimItemDetail, ClaimItem, Claim, ClaimResponseItemAdjudication, ClaimResponseItemDetailSubDetail, ClaimResponseItemDetail, ClaimResponseItem, ClaimResponseAddItemDetailSubDetail, ClaimResponseAddItemDetail, ClaimResponseAddItem, ClaimResponseTotal, ClaimResponsePayment, ClaimResponseProcessNote, ClaimResponseInsurance, ClaimResponseError, ClaimResponse, ClinicalImpressionInvestigation, ClinicalImpressionFinding, ClinicalImpression, ClinicalUseDefinitionContraindicationOtherTherapy, ClinicalUseDefinitionContraindication, ClinicalUseDefinitionIndication, ClinicalUseDefinitionInteractionInteractant, ClinicalUseDefinitionInteraction, ClinicalUseDefinitionUndesirableEffect, ClinicalUseDefinitionWarning, ClinicalUseDefinition, CodeSystemFilter, CodeSystemProperty, CodeSystemConceptDesignation, CodeSystemConceptProperty, CodeSystemConcept, CodeSystem, CommunicationPayload, Communication, CommunicationRequestPayload, CommunicationRequest, CompartmentDefinitionResource, CompartmentDefinition, CompositionAttester, CompositionRelatesTo, CompositionEvent, CompositionSection, Composition, ConceptMapGroupElementTargetDependsOn, ConceptMapGroupElementTarget, ConceptMapGroupElement, ConceptMapGroupUnmapped, ConceptMapGroup, ConceptMap, ConditionStage, ConditionEvidence, Condition, ConsentPolicy, ConsentVerification, ConsentProvisionActor, ConsentProvisionData, ConsentProvision, Consent, ContractContentDefinition, ContractTermSecurityLabel, ContractTermOfferParty, ContractTermOfferAnswer, ContractTermOffer, ContractTermAssetContext, ContractTermAssetValuedItem, ContractTermAsset, ContractTermActionSubject, ContractTermAction, ContractTerm, ContractSigner, ContractFriendly, ContractLegal, ContractRule, Contract, CoverageClass, CoverageCostToBeneficiaryException, CoverageCostToBeneficiary, Coverage, CoverageEligibilityRequestSupportingInfo, CoverageEligibilityRequestInsurance, CoverageEligibilityRequestItemDiagnosis, CoverageEligibilityRequestItem, CoverageEligibilityRequest, CoverageEligibilityResponseInsuranceItemBenefit, CoverageEligibilityResponseInsuranceItem, CoverageEligibilityResponseInsurance, CoverageEligibilityResponseError, CoverageEligibilityResponse, DetectedIssueEvidence, DetectedIssueMitigation, DetectedIssue, DeviceUdiCarrier, DeviceDeviceName, DeviceSpecialization, DeviceVersion, DeviceProperty, Device, DeviceDefinitionUdiDeviceIdentifier, DeviceDefinitionDeviceName, DeviceDefinitionSpecialization, DeviceDefinitionCapability, DeviceDefinitionProperty, DeviceDefinitionMaterial, DeviceDefinition, DeviceMetricCalibration, DeviceMetric, DeviceRequestParameter, DeviceRequest, DeviceUseStatement, DiagnosticReportMedia, DiagnosticReport, DocumentManifestRelated, DocumentManifest, DocumentReferenceRelatesTo, DocumentReferenceContent, DocumentReferenceContext, DocumentReference, DomainResource, EncounterStatusHistory, EncounterClassHistory, EncounterParticipant, EncounterDiagnosis, EncounterHospitalization, EncounterLocation, Encounter, Endpoint, EnrollmentRequest, EnrollmentResponse, EpisodeOfCareStatusHistory, EpisodeOfCareDiagnosis, EpisodeOfCare, EventDefinition, EvidenceVariableDefinition, EvidenceStatisticSampleSize, EvidenceStatisticAttributeEstimate, EvidenceStatisticModelCharacteristicVariable, EvidenceStatisticModelCharacteristic, EvidenceStatistic, EvidenceCertainty, Evidence, EvidenceReportSubjectCharacteristic, EvidenceReportSubject, EvidenceReportRelatesTo, EvidenceReportSection, EvidenceReport, EvidenceVariableCharacteristicTimeFromStart, EvidenceVariableCharacteristic, EvidenceVariableCategory, EvidenceVariable, ExampleScenarioActor, ExampleScenarioInstanceVersion, ExampleScenarioInstanceContainedInstance, ExampleScenarioInstance, ExampleScenarioProcessStepOperation, ExampleScenarioProcessStepAlternative, ExampleScenarioProcessStep, ExampleScenarioProcess, ExampleScenario, ExplanationOfBenefitRelated, ExplanationOfBenefitPayee, ExplanationOfBenefitCareTeam, ExplanationOfBenefitSupportingInfo, ExplanationOfBenefitDiagnosis, ExplanationOfBenefitProcedure, ExplanationOfBenefitInsurance, ExplanationOfBenefitAccident, ExplanationOfBenefitItemAdjudication, ExplanationOfBenefitItemDetailSubDetail, ExplanationOfBenefitItemDetail, ExplanationOfBenefitItem, ExplanationOfBenefitAddItemDetailSubDetail, ExplanationOfBenefitAddItemDetail, ExplanationOfBenefitAddItem, ExplanationOfBenefitTotal, ExplanationOfBenefitPayment, ExplanationOfBenefitProcessNote, ExplanationOfBenefitBenefitBalanceFinancial, ExplanationOfBenefitBenefitBalance, ExplanationOfBenefit, FamilyMemberHistoryCondition, FamilyMemberHistory, Flag, GoalTarget, Goal, GraphDefinitionLinkTargetCompartment, GraphDefinitionLinkTarget, GraphDefinitionLink, GraphDefinition, GroupCharacteristic, GroupMember, Group, GuidanceResponse, HealthcareServiceEligibility, HealthcareServiceAvailableTime, HealthcareServiceNotAvailable, HealthcareService, ImagingStudySeriesPerformer, ImagingStudySeriesInstance, ImagingStudySeries, ImagingStudy, ImmunizationPerformer, ImmunizationEducation, ImmunizationReaction, ImmunizationProtocolApplied, Immunization, ImmunizationEvaluation, ImmunizationRecommendationRecommendationDateCriterion, ImmunizationRecommendationRecommendation, ImmunizationRecommendation, ImplementationGuideDependsOn, ImplementationGuideGlobal, ImplementationGuideDefinitionGrouping, ImplementationGuideDefinitionResource, ImplementationGuideDefinitionPage, ImplementationGuideDefinitionParameter, ImplementationGuideDefinitionTemplate, ImplementationGuideDefinition, ImplementationGuideManifestResource, ImplementationGuideManifestPage, ImplementationGuideManifest, ImplementationGuide, IngredientManufacturer, IngredientSubstanceStrengthReferenceStrength, IngredientSubstanceStrength, IngredientSubstance, Ingredient, InsurancePlanContact, InsurancePlanCoverageBenefitLimit, InsurancePlanCoverageBenefit, InsurancePlanCoverage, InsurancePlanPlanGeneralCost, InsurancePlanPlanSpecificCostBenefitCost, InsurancePlanPlanSpecificCostBenefit, InsurancePlanPlanSpecificCost, InsurancePlanPlan, InsurancePlan, InvoiceParticipant, InvoiceLineItemPriceComponent, InvoiceLineItem, Invoice, Library, LinkageItem, Linkage, ListEntry, List, LocationPosition, LocationHoursOfOperation, Location, ManufacturedItemDefinitionProperty, ManufacturedItemDefinition, MeasureGroupPopulation, MeasureGroupStratifierComponent, MeasureGroupStratifier, MeasureGroup, MeasureSupplementalData, Measure, MeasureReportGroupPopulation, MeasureReportGroupStratifierStratumComponent, MeasureReportGroupStratifierStratumPopulation, MeasureReportGroupStratifierStratum, MeasureReportGroupStratifier, MeasureReportGroup, MeasureReport, Media, MedicationIngredient, MedicationBatch, Medication, MedicationAdministrationPerformer, MedicationAdministrationDosage, MedicationAdministration, MedicationDispensePerformer, MedicationDispenseSubstitution, MedicationDispense, MedicationKnowledgeRelatedMedicationKnowledge, MedicationKnowledgeMonograph, MedicationKnowledgeIngredient, MedicationKnowledgeCost, MedicationKnowledgeMonitoringProgram, MedicationKnowledgeAdministrationGuidelinesDosage, MedicationKnowledgeAdministrationGuidelinesPatientCharacteristics, MedicationKnowledgeAdministrationGuidelines, MedicationKnowledgeMedicineClassification, MedicationKnowledgePackaging, MedicationKnowledgeDrugCharacteristic, MedicationKnowledgeRegulatorySubstitution, MedicationKnowledgeRegulatorySchedule, MedicationKnowledgeRegulatoryMaxDispense, MedicationKnowledgeRegulatory, MedicationKnowledgeKinetics, MedicationKnowledge, MedicationRequestDispenseRequestInitialFill, MedicationRequestDispenseRequest, MedicationRequestSubstitution, MedicationRequest, MedicationStatement, MedicinalProductDefinitionContact, MedicinalProductDefinitionNameNamePart, MedicinalProductDefinitionNameCountryLanguage, MedicinalProductDefinitionName, MedicinalProductDefinitionCrossReference, MedicinalProductDefinitionOperation, MedicinalProductDefinitionCharacteristic, MedicinalProductDefinition, MessageDefinitionFocus, MessageDefinitionAllowedResponse, MessageDefinition, MessageHeaderDestination, MessageHeaderSource, MessageHeaderResponse, MessageHeader, MolecularSequenceReferenceSeq, MolecularSequenceVariant, MolecularSequenceQualityRoc, MolecularSequenceQuality, MolecularSequenceRepository, MolecularSequenceStructureVariantOuter, MolecularSequenceStructureVariantInner, MolecularSequenceStructureVariant, MolecularSequence, NamingSystemUniqueId, NamingSystem, NutritionOrderOralDietNutrient, NutritionOrderOralDietTexture, NutritionOrderOralDiet, NutritionOrderSupplement, NutritionOrderEnteralFormulaAdministration, NutritionOrderEnteralFormula, NutritionOrder, NutritionProductNutrient, NutritionProductIngredient, NutritionProductProductCharacteristic, NutritionProductInstance, NutritionProduct, ObservationReferenceRange, ObservationComponent, Observation, ObservationDefinitionQuantitativeDetails, ObservationDefinitionQualifiedInterval, ObservationDefinition, OperationDefinitionParameterBinding, OperationDefinitionParameterReferencedFrom, OperationDefinitionParameter, OperationDefinitionOverload, OperationDefinition, OperationOutcomeIssue, OperationOutcome, OrganizationContact, Organization, OrganizationAffiliation, PackagedProductDefinitionLegalStatusOfSupply, PackagedProductDefinitionPackageShelfLifeStorage, PackagedProductDefinitionPackageProperty, PackagedProductDefinitionPackageContainedItem, PackagedProductDefinitionPackage, PackagedProductDefinition, ParametersParameter, Parameters, PatientContact, PatientCommunication, PatientLink, Patient, PaymentNotice, PaymentReconciliationDetail, PaymentReconciliationProcessNote, PaymentReconciliation, PersonLink, Person, PlanDefinitionGoalTarget, PlanDefinitionGoal, PlanDefinitionActionCondition, PlanDefinitionActionRelatedAction, PlanDefinitionActionParticipant, PlanDefinitionActionDynamicValue, PlanDefinitionAction, PlanDefinition, PractitionerQualification, Practitioner, PractitionerRoleAvailableTime, PractitionerRoleNotAvailable, PractitionerRole, ProcedurePerformer, ProcedureFocalDevice, Procedure, ProvenanceAgent, ProvenanceEntity, Provenance, QuestionnaireItemEnableWhen, QuestionnaireItemAnswerOption, QuestionnaireItemInitial, QuestionnaireItem, Questionnaire, QuestionnaireResponseItemAnswer, QuestionnaireResponseItem, QuestionnaireResponse, RegulatedAuthorizationCase, RegulatedAuthorization, RelatedPersonCommunication, RelatedPerson, RequestGroupActionCondition, RequestGroupActionRelatedAction, RequestGroupAction, RequestGroup, ResearchDefinition, ResearchElementDefinitionCharacteristic, ResearchElementDefinition, ResearchStudyArm, ResearchStudyObjective, ResearchStudy, ResearchSubject, Resource, RiskAssessmentPrediction, RiskAssessment, Schedule, SearchParameterComponent, SearchParameter, ServiceRequest, Slot, SpecimenCollection, SpecimenProcessing, SpecimenContainer, Specimen, SpecimenDefinitionTypeTestedContainerAdditive, SpecimenDefinitionTypeTestedContainer, SpecimenDefinitionTypeTestedHandling, SpecimenDefinitionTypeTested, SpecimenDefinition, StructureDefinitionMapping, StructureDefinitionContext, StructureDefinitionSnapshot, StructureDefinitionDifferential, StructureDefinition, StructureMapStructure, StructureMapGroupInput, StructureMapGroupRuleSource, StructureMapGroupRuleTargetParameter, StructureMapGroupRuleTarget, StructureMapGroupRuleDependent, StructureMapGroupRule, StructureMapGroup, StructureMap, SubscriptionChannel, Subscription, SubscriptionStatusNotificationEvent, SubscriptionStatus, SubscriptionTopicResourceTriggerQueryCriteria, SubscriptionTopicResourceTrigger, SubscriptionTopicEventTrigger, SubscriptionTopicCanFilterBy, SubscriptionTopicNotificationShape, SubscriptionTopic, SubstanceInstance, SubstanceIngredient, Substance, SubstanceDefinitionMoiety, SubstanceDefinitionProperty, SubstanceDefinitionMolecularWeight, SubstanceDefinitionStructureRepresentation, SubstanceDefinitionStructure, SubstanceDefinitionCode, SubstanceDefinitionNameOfficial, SubstanceDefinitionName, SubstanceDefinitionRelationship, SubstanceDefinitionSourceMaterial, SubstanceDefinition, SupplyDeliverySuppliedItem, SupplyDelivery, SupplyRequestParameter, SupplyRequest, TaskRestriction, TaskInput, TaskOutput, Task, TerminologyCapabilitiesSoftware, TerminologyCapabilitiesImplementation, TerminologyCapabilitiesCodeSystemVersionFilter, TerminologyCapabilitiesCodeSystemVersion, TerminologyCapabilitiesCodeSystem, TerminologyCapabilitiesExpansionParameter, TerminologyCapabilitiesExpansion, TerminologyCapabilitiesValidateCode, TerminologyCapabilitiesTranslation, TerminologyCapabilitiesClosure, TerminologyCapabilities, TestReportParticipant, TestReportSetupActionOperation, TestReportSetupActionAssert, TestReportSetupAction, TestReportSetup, TestReportTestAction, TestReportTest, TestReportTeardownAction, TestReportTeardown, TestReport, TestScriptOrigin, TestScriptDestination, TestScriptMetadataLink, TestScriptMetadataCapability, TestScriptMetadata, TestScriptFixture, TestScriptVariable, TestScriptSetupActionOperationRequestHeader, TestScriptSetupActionOperation, TestScriptSetupActionAssert, TestScriptSetupAction, TestScriptSetup, TestScriptTestAction, TestScriptTest, TestScriptTeardownAction, TestScriptTeardown, TestScript, ValueSetComposeIncludeConceptDesignation, ValueSetComposeIncludeConcept, ValueSetComposeIncludeFilter, ValueSetComposeInclude, ValueSetCompose, ValueSetExpansionParameter, ValueSetExpansionContains, ValueSetExpansion, ValueSet, VerificationResultPrimarySource, VerificationResultAttestation, VerificationResultValidator, VerificationResult, VisionPrescriptionLensSpecificationPrism, VisionPrescriptionLensSpecification, VisionPrescription, FhirResource } from "fhir/r4b"
import { IsString, IsOptional, IsArray, ValidateNested, IsNotEmpty, IsIn, IsNumber, IsBoolean } from "class-validator"
import { Type } from "class-transformer"

namespace r4b {


  export class QuantityDto implements Quantity {
    @IsOptional()
    @IsString()
    code?: string

    @IsNotEmpty()
    @IsIn(["<", "<=", ">=", ">"])
    comparator: "<" | "<=" | ">=" | ">"

    @IsOptional()
    @IsString()
    system?: string

    @IsOptional()
    @IsString()
    unit?: string

    @IsOptional()
    @IsNumber()
    value?: number

  }
  export class ElementDto implements Element {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExtensionDto)
    extension?: Extension[]

    @IsOptional()
    @IsString()
    id?: string

  }
  export class AddressDto implements Address {
    @IsOptional()
    @IsString()
    city?: string

    @IsOptional()
    @IsString()
    country?: string

    @IsOptional()
    @IsString()
    district?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    line?: string[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @IsString()
    postalCode?: string

    @IsOptional()
    @IsString()
    state?: string

    @IsOptional()
    @IsString()
    text?: string

    @IsNotEmpty()
    @IsIn(["postal", "physical", "both"])
    type: "postal" | "physical" | "both"

    @IsNotEmpty()
    @IsIn(["home", "work", "temp", "old", "billing"])
    use: "home" | "work" | "temp" | "old" | "billing"

  }
  export class AgeDto extends QuantityDto { }

  export class AnnotationDto implements Annotation {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    authorReference?: Reference

    @IsOptional()
    @IsString()
    authorString?: string

    @IsNotEmpty()
    @IsString()
    text: string

    @IsOptional()
    @IsString()
    time?: string

  }
  export class AttachmentDto implements Attachment {
    @IsOptional()
    @IsString()
    contentType?: string

    @IsOptional()
    @IsString()
    creation?: string

    @IsOptional()
    @IsString()
    data?: string

    @IsOptional()
    @IsString()
    hash?: string

    @IsOptional()
    @IsString()
    language?: string

    @IsOptional()
    @IsNumber()
    size?: number

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsString()
    url?: string

  }
  export class BackboneElementDto implements BackboneElement {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExtensionDto)
    modifierExtension?: Extension[]

  }
  export class CodeableConceptDto implements CodeableConcept {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    coding?: Coding[]

    @IsOptional()
    @IsString()
    text?: string

  }
  export class CodeableReferenceDto implements CodeableReference {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    concept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    reference?: Reference

  }
  export class CodingDto implements Coding {
    @IsOptional()
    @IsString()
    code?: string

    @IsOptional()
    @IsString()
    display?: string

    @IsOptional()
    @IsString()
    system?: string

    @IsNotEmpty()
    @IsBoolean()
    userSelected: boolean

    @IsOptional()
    @IsString()
    version?: string

  }
  export class ContactDetailDto implements ContactDetail {
    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactPointDto)
    telecom?: ContactPoint[]

  }
  export class ContactPointDto implements ContactPoint {
    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @IsNumber()
    rank?: number

    @IsNotEmpty()
    @IsIn(["phone", "fax", "email", "pager", "url", "sms", "other"])
    system: "phone" | "fax" | "email" | "pager" | "url" | "sms" | "other"

    @IsNotEmpty()
    @IsIn(["home", "work", "temp", "old", "mobile"])
    use: "home" | "work" | "temp" | "old" | "mobile"

    @IsOptional()
    @IsString()
    value?: string

  }
  export class ContributorDto implements Contributor {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsNotEmpty()
    @IsString()
    name: string

    @IsNotEmpty()
    @IsIn(["author", "editor", "reviewer", "endorser"])
    type: "author" | "editor" | "reviewer" | "endorser"

  }
  export class CountDto extends QuantityDto { }

  export class DataRequirementCodeFilterDto implements DataRequirementCodeFilter {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    code?: Coding[]

    @IsOptional()
    @IsString()
    path?: string

    @IsOptional()
    @IsString()
    searchParam?: string

    @IsOptional()
    @IsString()
    valueSet?: string

  }
  export class DataRequirementDateFilterDto implements DataRequirementDateFilter {
    @IsOptional()
    @IsString()
    path?: string

    @IsOptional()
    @IsString()
    searchParam?: string

    @IsOptional()
    @IsString()
    valueDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    valuePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    valueDuration?: Duration

  }
  export class DataRequirementSortDto implements DataRequirementSort {
    @IsNotEmpty()
    @IsIn(["ascending", "descending"])
    direction: "ascending" | "descending"

    @IsNotEmpty()
    @IsString()
    path: string

  }
  export class DataRequirementDto implements DataRequirement {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DataRequirementCodeFilterDto)
    codeFilter?: DataRequirementCodeFilter[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DataRequirementDateFilterDto)
    dateFilter?: DataRequirementDateFilter[]

    @IsOptional()
    @IsNumber()
    limit?: number

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    mustSupport?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    profile?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DataRequirementSortDto)
    sort?: DataRequirementSort[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    subjectCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subjectReference?: Reference

    @IsNotEmpty()
    @IsString()
    type: string

  }
  export class DataTypeDto extends ElementDto { }

  export class DistanceDto extends QuantityDto { }

  export class DosageDoseAndRateDto implements DosageDoseAndRate {
    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    doseRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    doseQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    rateRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    rateRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    rateQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class DosageDto implements Dosage {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    additionalInstruction?: CodeableConcept[]

    @IsNotEmpty()
    @IsBoolean()
    asNeededBoolean: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    asNeededCodeableConcept?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DosageDoseAndRateDto)
    doseAndRate?: DosageDoseAndRate[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    maxDosePerAdministration?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    maxDosePerLifetime?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    maxDosePerPeriod?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    method?: CodeableConcept

    @IsOptional()
    @IsString()
    patientInstruction?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    route?: CodeableConcept

    @IsOptional()
    @IsNumber()
    sequence?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    site?: CodeableConcept

    @IsOptional()
    @IsString()
    text?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    timing?: Timing

  }
  export class DurationDto extends QuantityDto { }

  export class ElementDefinitionSlicingDiscriminatorDto implements ElementDefinitionSlicingDiscriminator {
    @IsNotEmpty()
    @IsString()
    path: string

    @IsNotEmpty()
    @IsIn(["value", "exists", "pattern", "type", "profile"])
    type: "value" | "exists" | "pattern" | "type" | "profile"

  }
  export class ElementDefinitionSlicingDto implements ElementDefinitionSlicing {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ElementDefinitionSlicingDiscriminatorDto)
    discriminator?: ElementDefinitionSlicingDiscriminator[]

    @IsNotEmpty()
    @IsBoolean()
    ordered: boolean

    @IsNotEmpty()
    @IsIn(["closed", "open", "openAtEnd"])
    rules: "closed" | "open" | "openAtEnd"

  }
  export class ElementDefinitionBaseDto implements ElementDefinitionBase {
    @IsNotEmpty()
    @IsString()
    max: string

    @IsNotEmpty()
    @IsNumber()
    min: number

    @IsNotEmpty()
    @IsString()
    path: string

  }
  export class ElementDefinitionTypeDto implements ElementDefinitionType {
    @IsOptional()
    @IsArray()
    @IsIn(["contained", "referenced", "bundled"], { each: true })
    aggregation?: ("contained" | "referenced" | "bundled")[]

    @IsNotEmpty()
    @IsString()
    code: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    profile?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    targetProfile?: string[]

    @IsNotEmpty()
    @IsIn(["either", "independent", "specific"])
    versioning: "either" | "independent" | "specific"

  }
  export class ElementDefinitionExampleDto implements ElementDefinitionExample {
    @IsNotEmpty()
    @IsString()
    label: string

    @IsOptional()
    @IsString()
    valueBase64Binary?: string

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsString()
    valueCanonical?: string

    @IsOptional()
    @IsString()
    valueCode?: string

    @IsOptional()
    @IsString()
    valueDate?: string

    @IsOptional()
    @IsString()
    valueDateTime?: string

    @IsOptional()
    @IsNumber()
    valueDecimal?: number

    @IsOptional()
    @IsString()
    valueId?: string

    @IsOptional()
    @IsString()
    valueInstant?: string

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsOptional()
    @IsString()
    valueMarkdown?: string

    @IsOptional()
    @IsString()
    valueOid?: string

    @IsOptional()
    @IsNumber()
    valuePositiveInt?: number

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @IsString()
    valueTime?: string

    @IsOptional()
    @IsNumber()
    valueUnsignedInt?: number

    @IsOptional()
    @IsString()
    valueUri?: string

    @IsOptional()
    @IsString()
    valueUrl?: string

    @IsOptional()
    @IsString()
    valueUuid?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    valueAddress?: Address

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    valueAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => AnnotationDto)
    valueAnnotation?: Annotation

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    valueCodeableReference?: CodeableReference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    valueCoding?: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactPointDto)
    valueContactPoint?: ContactPoint

    @IsOptional()
    @ValidateNested()
    @Type(() => CountDto)
    valueCount?: Count

    @IsOptional()
    @ValidateNested()
    @Type(() => DistanceDto)
    valueDistance?: Distance

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    valueDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => HumanNameDto)
    valueHumanName?: HumanName

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    valueIdentifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    valueMoney?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    valuePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    valueRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioRangeDto)
    valueRatioRange?: RatioRange

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => SampledDataDto)
    valueSampledData?: SampledData

    @IsOptional()
    @ValidateNested()
    @Type(() => SignatureDto)
    valueSignature?: Signature

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    valueTiming?: Timing

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactDetailDto)
    valueContactDetail?: ContactDetail

    @IsOptional()
    @ValidateNested()
    @Type(() => ContributorDto)
    valueContributor?: Contributor

    @IsOptional()
    @ValidateNested()
    @Type(() => DataRequirementDto)
    valueDataRequirement?: DataRequirement

    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    valueExpression?: Expression

    @IsOptional()
    @ValidateNested()
    @Type(() => ParameterDefinitionDto)
    valueParameterDefinition?: ParameterDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => RelatedArtifactDto)
    valueRelatedArtifact?: RelatedArtifact

    @IsOptional()
    @ValidateNested()
    @Type(() => TriggerDefinitionDto)
    valueTriggerDefinition?: TriggerDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => UsageContextDto)
    valueUsageContext?: UsageContext

    @IsOptional()
    @ValidateNested()
    @Type(() => DosageDto)
    valueDosage?: Dosage

  }
  export class ElementDefinitionConstraintDto implements ElementDefinitionConstraint {
    @IsOptional()
    @IsString()
    expression?: string

    @IsNotEmpty()
    @IsString()
    human: string

    @IsNotEmpty()
    @IsString()
    key: string

    @IsOptional()
    @IsString()
    requirements?: string

    @IsNotEmpty()
    @IsIn(["error", "warning"])
    severity: "error" | "warning"

    @IsOptional()
    @IsString()
    source?: string

    @IsOptional()
    @IsString()
    xpath?: string

  }
  export class ElementDefinitionBindingDto implements ElementDefinitionBinding {
    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsIn(["required", "extensible", "preferred", "example"])
    strength: "required" | "extensible" | "preferred" | "example"

    @IsOptional()
    @IsString()
    valueSet?: string

  }
  export class ElementDefinitionMappingDto implements ElementDefinitionMapping {
    @IsOptional()
    @IsString()
    comment?: string

    @IsNotEmpty()
    @IsString()
    identity: string

    @IsOptional()
    @IsString()
    language?: string

    @IsNotEmpty()
    @IsString()
    map: string

  }
  export class ElementDefinitionDto implements ElementDefinition {
    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    alias?: string[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ElementDefinitionBaseDto)
    base?: ElementDefinitionBase

    @IsOptional()
    @ValidateNested()
    @Type(() => ElementDefinitionBindingDto)
    binding?: ElementDefinitionBinding

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    code?: Coding[]

    @IsOptional()
    @IsString()
    comment?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    condition?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ElementDefinitionConstraintDto)
    constraint?: ElementDefinitionConstraint[]

    @IsOptional()
    @IsString()
    contentReference?: string

    @IsOptional()
    @IsString()
    defaultValueBase64Binary?: string

    @IsNotEmpty()
    @IsBoolean()
    defaultValueBoolean: boolean

    @IsOptional()
    @IsString()
    defaultValueCanonical?: string

    @IsOptional()
    @IsString()
    defaultValueCode?: string

    @IsOptional()
    @IsString()
    defaultValueDate?: string

    @IsOptional()
    @IsString()
    defaultValueDateTime?: string

    @IsOptional()
    @IsNumber()
    defaultValueDecimal?: number

    @IsOptional()
    @IsString()
    defaultValueId?: string

    @IsOptional()
    @IsString()
    defaultValueInstant?: string

    @IsOptional()
    @IsNumber()
    defaultValueInteger?: number

    @IsOptional()
    @IsString()
    defaultValueMarkdown?: string

    @IsOptional()
    @IsString()
    defaultValueOid?: string

    @IsOptional()
    @IsNumber()
    defaultValuePositiveInt?: number

    @IsOptional()
    @IsString()
    defaultValueString?: string

    @IsOptional()
    @IsString()
    defaultValueTime?: string

    @IsOptional()
    @IsNumber()
    defaultValueUnsignedInt?: number

    @IsOptional()
    @IsString()
    defaultValueUri?: string

    @IsOptional()
    @IsString()
    defaultValueUrl?: string

    @IsOptional()
    @IsString()
    defaultValueUuid?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    defaultValueAddress?: Address

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    defaultValueAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => AnnotationDto)
    defaultValueAnnotation?: Annotation

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    defaultValueAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    defaultValueCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    defaultValueCodeableReference?: CodeableReference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    defaultValueCoding?: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactPointDto)
    defaultValueContactPoint?: ContactPoint

    @IsOptional()
    @ValidateNested()
    @Type(() => CountDto)
    defaultValueCount?: Count

    @IsOptional()
    @ValidateNested()
    @Type(() => DistanceDto)
    defaultValueDistance?: Distance

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    defaultValueDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => HumanNameDto)
    defaultValueHumanName?: HumanName

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    defaultValueIdentifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    defaultValueMoney?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    defaultValuePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    defaultValueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    defaultValueRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    defaultValueRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioRangeDto)
    defaultValueRatioRange?: RatioRange

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    defaultValueReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => SampledDataDto)
    defaultValueSampledData?: SampledData

    @IsOptional()
    @ValidateNested()
    @Type(() => SignatureDto)
    defaultValueSignature?: Signature

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    defaultValueTiming?: Timing

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactDetailDto)
    defaultValueContactDetail?: ContactDetail

    @IsOptional()
    @ValidateNested()
    @Type(() => ContributorDto)
    defaultValueContributor?: Contributor

    @IsOptional()
    @ValidateNested()
    @Type(() => DataRequirementDto)
    defaultValueDataRequirement?: DataRequirement

    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    defaultValueExpression?: Expression

    @IsOptional()
    @ValidateNested()
    @Type(() => ParameterDefinitionDto)
    defaultValueParameterDefinition?: ParameterDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => RelatedArtifactDto)
    defaultValueRelatedArtifact?: RelatedArtifact

    @IsOptional()
    @ValidateNested()
    @Type(() => TriggerDefinitionDto)
    defaultValueTriggerDefinition?: TriggerDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => UsageContextDto)
    defaultValueUsageContext?: UsageContext

    @IsOptional()
    @ValidateNested()
    @Type(() => DosageDto)
    defaultValueDosage?: Dosage

    @IsOptional()
    @IsString()
    definition?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ElementDefinitionExampleDto)
    example?: ElementDefinitionExample[]

    @IsOptional()
    @IsString()
    fixedBase64Binary?: string

    @IsNotEmpty()
    @IsBoolean()
    fixedBoolean: boolean

    @IsOptional()
    @IsString()
    fixedCanonical?: string

    @IsOptional()
    @IsString()
    fixedCode?: string

    @IsOptional()
    @IsString()
    fixedDate?: string

    @IsOptional()
    @IsString()
    fixedDateTime?: string

    @IsOptional()
    @IsNumber()
    fixedDecimal?: number

    @IsOptional()
    @IsString()
    fixedId?: string

    @IsOptional()
    @IsString()
    fixedInstant?: string

    @IsOptional()
    @IsNumber()
    fixedInteger?: number

    @IsOptional()
    @IsString()
    fixedMarkdown?: string

    @IsOptional()
    @IsString()
    fixedOid?: string

    @IsOptional()
    @IsNumber()
    fixedPositiveInt?: number

    @IsOptional()
    @IsString()
    fixedString?: string

    @IsOptional()
    @IsString()
    fixedTime?: string

    @IsOptional()
    @IsNumber()
    fixedUnsignedInt?: number

    @IsOptional()
    @IsString()
    fixedUri?: string

    @IsOptional()
    @IsString()
    fixedUrl?: string

    @IsOptional()
    @IsString()
    fixedUuid?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    fixedAddress?: Address

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    fixedAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => AnnotationDto)
    fixedAnnotation?: Annotation

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    fixedAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    fixedCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    fixedCodeableReference?: CodeableReference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    fixedCoding?: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactPointDto)
    fixedContactPoint?: ContactPoint

    @IsOptional()
    @ValidateNested()
    @Type(() => CountDto)
    fixedCount?: Count

    @IsOptional()
    @ValidateNested()
    @Type(() => DistanceDto)
    fixedDistance?: Distance

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    fixedDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => HumanNameDto)
    fixedHumanName?: HumanName

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    fixedIdentifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    fixedMoney?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    fixedPeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    fixedQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    fixedRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    fixedRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioRangeDto)
    fixedRatioRange?: RatioRange

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    fixedReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => SampledDataDto)
    fixedSampledData?: SampledData

    @IsOptional()
    @ValidateNested()
    @Type(() => SignatureDto)
    fixedSignature?: Signature

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    fixedTiming?: Timing

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactDetailDto)
    fixedContactDetail?: ContactDetail

    @IsOptional()
    @ValidateNested()
    @Type(() => ContributorDto)
    fixedContributor?: Contributor

    @IsOptional()
    @ValidateNested()
    @Type(() => DataRequirementDto)
    fixedDataRequirement?: DataRequirement

    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    fixedExpression?: Expression

    @IsOptional()
    @ValidateNested()
    @Type(() => ParameterDefinitionDto)
    fixedParameterDefinition?: ParameterDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => RelatedArtifactDto)
    fixedRelatedArtifact?: RelatedArtifact

    @IsOptional()
    @ValidateNested()
    @Type(() => TriggerDefinitionDto)
    fixedTriggerDefinition?: TriggerDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => UsageContextDto)
    fixedUsageContext?: UsageContext

    @IsOptional()
    @ValidateNested()
    @Type(() => DosageDto)
    fixedDosage?: Dosage

    @IsNotEmpty()
    @IsBoolean()
    isModifier: boolean

    @IsOptional()
    @IsString()
    isModifierReason?: string

    @IsNotEmpty()
    @IsBoolean()
    isSummary: boolean

    @IsOptional()
    @IsString()
    label?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ElementDefinitionMappingDto)
    mapping?: ElementDefinitionMapping[]

    @IsOptional()
    @IsString()
    max?: string

    @IsOptional()
    @IsNumber()
    maxLength?: number

    @IsOptional()
    @IsString()
    maxValueDate?: string

    @IsOptional()
    @IsString()
    maxValueDateTime?: string

    @IsOptional()
    @IsString()
    maxValueInstant?: string

    @IsOptional()
    @IsString()
    maxValueTime?: string

    @IsOptional()
    @IsNumber()
    maxValueDecimal?: number

    @IsOptional()
    @IsNumber()
    maxValueInteger?: number

    @IsOptional()
    @IsNumber()
    maxValuePositiveInt?: number

    @IsOptional()
    @IsNumber()
    maxValueUnsignedInt?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    maxValueQuantity?: Quantity

    @IsOptional()
    @IsString()
    meaningWhenMissing?: string

    @IsOptional()
    @IsNumber()
    min?: number

    @IsOptional()
    @IsString()
    minValueDate?: string

    @IsOptional()
    @IsString()
    minValueDateTime?: string

    @IsOptional()
    @IsString()
    minValueInstant?: string

    @IsOptional()
    @IsString()
    minValueTime?: string

    @IsOptional()
    @IsNumber()
    minValueDecimal?: number

    @IsOptional()
    @IsNumber()
    minValueInteger?: number

    @IsOptional()
    @IsNumber()
    minValuePositiveInt?: number

    @IsOptional()
    @IsNumber()
    minValueUnsignedInt?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    minValueQuantity?: Quantity

    @IsNotEmpty()
    @IsBoolean()
    mustSupport: boolean

    @IsOptional()
    @IsString()
    orderMeaning?: string

    @IsNotEmpty()
    @IsString()
    path: string

    @IsOptional()
    @IsString()
    patternBase64Binary?: string

    @IsNotEmpty()
    @IsBoolean()
    patternBoolean: boolean

    @IsOptional()
    @IsString()
    patternCanonical?: string

    @IsOptional()
    @IsString()
    patternCode?: string

    @IsOptional()
    @IsString()
    patternDate?: string

    @IsOptional()
    @IsString()
    patternDateTime?: string

    @IsOptional()
    @IsNumber()
    patternDecimal?: number

    @IsOptional()
    @IsString()
    patternId?: string

    @IsOptional()
    @IsString()
    patternInstant?: string

    @IsOptional()
    @IsNumber()
    patternInteger?: number

    @IsOptional()
    @IsString()
    patternMarkdown?: string

    @IsOptional()
    @IsString()
    patternOid?: string

    @IsOptional()
    @IsNumber()
    patternPositiveInt?: number

    @IsOptional()
    @IsString()
    patternString?: string

    @IsOptional()
    @IsString()
    patternTime?: string

    @IsOptional()
    @IsNumber()
    patternUnsignedInt?: number

    @IsOptional()
    @IsString()
    patternUri?: string

    @IsOptional()
    @IsString()
    patternUrl?: string

    @IsOptional()
    @IsString()
    patternUuid?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    patternAddress?: Address

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    patternAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => AnnotationDto)
    patternAnnotation?: Annotation

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    patternAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    patternCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    patternCodeableReference?: CodeableReference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    patternCoding?: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactPointDto)
    patternContactPoint?: ContactPoint

    @IsOptional()
    @ValidateNested()
    @Type(() => CountDto)
    patternCount?: Count

    @IsOptional()
    @ValidateNested()
    @Type(() => DistanceDto)
    patternDistance?: Distance

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    patternDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => HumanNameDto)
    patternHumanName?: HumanName

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    patternIdentifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    patternMoney?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    patternPeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    patternQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    patternRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    patternRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioRangeDto)
    patternRatioRange?: RatioRange

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patternReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => SampledDataDto)
    patternSampledData?: SampledData

    @IsOptional()
    @ValidateNested()
    @Type(() => SignatureDto)
    patternSignature?: Signature

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    patternTiming?: Timing

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactDetailDto)
    patternContactDetail?: ContactDetail

    @IsOptional()
    @ValidateNested()
    @Type(() => ContributorDto)
    patternContributor?: Contributor

    @IsOptional()
    @ValidateNested()
    @Type(() => DataRequirementDto)
    patternDataRequirement?: DataRequirement

    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    patternExpression?: Expression

    @IsOptional()
    @ValidateNested()
    @Type(() => ParameterDefinitionDto)
    patternParameterDefinition?: ParameterDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => RelatedArtifactDto)
    patternRelatedArtifact?: RelatedArtifact

    @IsOptional()
    @ValidateNested()
    @Type(() => TriggerDefinitionDto)
    patternTriggerDefinition?: TriggerDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => UsageContextDto)
    patternUsageContext?: UsageContext

    @IsOptional()
    @ValidateNested()
    @Type(() => DosageDto)
    patternDosage?: Dosage

    @IsOptional()
    @IsArray()
    @IsIn(["xmlAttr", "xmlText", "typeAttr", "cdaText", "xhtml"], { each: true })
    representation?: ("xmlAttr" | "xmlText" | "typeAttr" | "cdaText" | "xhtml")[]

    @IsOptional()
    @IsString()
    requirements?: string

    @IsOptional()
    @IsString()
    short?: string

    @IsNotEmpty()
    @IsBoolean()
    sliceIsConstraining: boolean

    @IsOptional()
    @IsString()
    sliceName?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ElementDefinitionSlicingDto)
    slicing?: ElementDefinitionSlicing

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ElementDefinitionTypeDto)
    type?: ElementDefinitionType[]

  }
  export class ExpressionDto implements Expression {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    expression?: string

    @IsNotEmpty()
    @IsString()
    language: string

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsString()
    reference?: string

  }
  export class ExtensionDto implements Extension {
    @IsNotEmpty()
    @IsString()
    url: string

    @IsOptional()
    @IsString()
    valueBase64Binary?: string

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsString()
    valueCanonical?: string

    @IsOptional()
    @IsString()
    valueCode?: string

    @IsOptional()
    @IsString()
    valueDate?: string

    @IsOptional()
    @IsString()
    valueDateTime?: string

    @IsOptional()
    @IsNumber()
    valueDecimal?: number

    @IsOptional()
    @IsString()
    valueId?: string

    @IsOptional()
    @IsString()
    valueInstant?: string

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsOptional()
    @IsString()
    valueMarkdown?: string

    @IsOptional()
    @IsString()
    valueOid?: string

    @IsOptional()
    @IsNumber()
    valuePositiveInt?: number

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @IsString()
    valueTime?: string

    @IsOptional()
    @IsNumber()
    valueUnsignedInt?: number

    @IsOptional()
    @IsString()
    valueUri?: string

    @IsOptional()
    @IsString()
    valueUrl?: string

    @IsOptional()
    @IsString()
    valueUuid?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    valueAddress?: Address

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    valueAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => AnnotationDto)
    valueAnnotation?: Annotation

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    valueCodeableReference?: CodeableReference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    valueCoding?: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactPointDto)
    valueContactPoint?: ContactPoint

    @IsOptional()
    @ValidateNested()
    @Type(() => CountDto)
    valueCount?: Count

    @IsOptional()
    @ValidateNested()
    @Type(() => DistanceDto)
    valueDistance?: Distance

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    valueDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => HumanNameDto)
    valueHumanName?: HumanName

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    valueIdentifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    valueMoney?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    valuePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    valueRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioRangeDto)
    valueRatioRange?: RatioRange

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => SampledDataDto)
    valueSampledData?: SampledData

    @IsOptional()
    @ValidateNested()
    @Type(() => SignatureDto)
    valueSignature?: Signature

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    valueTiming?: Timing

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactDetailDto)
    valueContactDetail?: ContactDetail

    @IsOptional()
    @ValidateNested()
    @Type(() => ContributorDto)
    valueContributor?: Contributor

    @IsOptional()
    @ValidateNested()
    @Type(() => DataRequirementDto)
    valueDataRequirement?: DataRequirement

    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    valueExpression?: Expression

    @IsOptional()
    @ValidateNested()
    @Type(() => ParameterDefinitionDto)
    valueParameterDefinition?: ParameterDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => RelatedArtifactDto)
    valueRelatedArtifact?: RelatedArtifact

    @IsOptional()
    @ValidateNested()
    @Type(() => TriggerDefinitionDto)
    valueTriggerDefinition?: TriggerDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => UsageContextDto)
    valueUsageContext?: UsageContext

    @IsOptional()
    @ValidateNested()
    @Type(() => DosageDto)
    valueDosage?: Dosage

  }
  export class HumanNameDto implements HumanName {
    @IsOptional()
    @IsString()
    family?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    given?: string[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    prefix?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    suffix?: string[]

    @IsOptional()
    @IsString()
    text?: string

    @IsNotEmpty()
    @IsIn(["temp", "old", "usual", "official", "nickname", "anonymous", "maiden"])
    use: "temp" | "old" | "usual" | "official" | "nickname" | "anonymous" | "maiden"

  }
  export class IdentifierDto implements Identifier {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    assigner?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @IsString()
    system?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsNotEmpty()
    @IsIn(["temp", "old", "usual", "official", "secondary"])
    use: "temp" | "old" | "usual" | "official" | "secondary"

    @IsOptional()
    @IsString()
    value?: string

  }
  export class MarketingStatusDto implements MarketingStatus {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    country?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    dateRange?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept

    @IsOptional()
    @IsString()
    restoreDate?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    status: CodeableConcept

  }
  export class MetaDto implements Meta {
    @IsOptional()
    @IsString()
    lastUpdated?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    profile?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    security?: Coding[]

    @IsOptional()
    @IsString()
    source?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    tag?: Coding[]

    @IsOptional()
    @IsString()
    versionId?: string

  }
  export class MoneyDto implements Money {
    @IsOptional()
    @IsString()
    currency?: string

    @IsOptional()
    @IsNumber()
    value?: number

  }
  export class NarrativeDto implements Narrative {
    @IsNotEmpty()
    @IsString()
    div: string

    @IsNotEmpty()
    @IsIn(["generated", "extensions", "additional", "empty"])
    status: "generated" | "extensions" | "additional" | "empty"

  }
  export class ParameterDefinitionDto implements ParameterDefinition {
    @IsOptional()
    @IsString()
    documentation?: string

    @IsOptional()
    @IsString()
    max?: string

    @IsOptional()
    @IsNumber()
    min?: number

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsString()
    profile?: string

    @IsNotEmpty()
    @IsString()
    type: string

    @IsNotEmpty()
    @IsIn(["in", "out"])
    use: "in" | "out"

  }
  export class PeriodDto implements Period {
    @IsOptional()
    @IsString()
    end?: string

    @IsOptional()
    @IsString()
    start?: string

  }
  export class PopulationDto implements Population {
    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    ageRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    ageCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    gender?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    physiologicalCondition?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    race?: CodeableConcept

  }
  export class ProdCharacteristicDto implements ProdCharacteristic {
    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    color?: string[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    depth?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    externalDiameter?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    height?: Quantity

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AttachmentDto)
    image?: Attachment[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    imprint?: string[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    nominalVolume?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    scoring?: CodeableConcept

    @IsOptional()
    @IsString()
    shape?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    weight?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    width?: Quantity

  }
  export class ProductShelfLifeDto implements ProductShelfLife {
    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => QuantityDto)
    period: Quantity

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    specialPrecautionsForStorage?: CodeableConcept[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }

  export class RangeDto implements Range {
    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    high?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    low?: Quantity

  }
  export class RatioDto implements Ratio {
    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    denominator?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    numerator?: Quantity

  }
  export class RatioRangeDto implements RatioRange {
    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    denominator?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    highNumerator?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    lowNumerator?: Quantity

  }
  export class ReferenceDto implements Reference {
    @IsOptional()
    @IsString()
    display?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsOptional()
    @IsString()
    reference?: string

    @IsOptional()
    @IsString()
    type?: string

  }
  export class RelatedArtifactDto implements RelatedArtifact {
    @IsOptional()
    @IsString()
    citation?: string

    @IsOptional()
    @IsString()
    display?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    document?: Attachment

    @IsOptional()
    @IsString()
    label?: string

    @IsOptional()
    @IsString()
    resource?: string

    @IsNotEmpty()
    @IsIn(["documentation", "justification", "citation", "predecessor", "successor", "derived-from", "depends-on", "composed-of"])
    type: "documentation" | "justification" | "citation" | "predecessor" | "successor" | "derived-from" | "depends-on" | "composed-of"

    @IsOptional()
    @IsString()
    url?: string

  }
  export class SampledDataDto implements SampledData {
    @IsOptional()
    @IsString()
    data?: string

    @IsNotEmpty()
    @IsNumber()
    dimensions: number

    @IsOptional()
    @IsNumber()
    factor?: number

    @IsOptional()
    @IsNumber()
    lowerLimit?: number

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => QuantityDto)
    origin: Quantity

    @IsNotEmpty()
    @IsNumber()
    period: number

    @IsOptional()
    @IsNumber()
    upperLimit?: number

  }
  export class SignatureDto implements Signature {
    @IsOptional()
    @IsString()
    data?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    onBehalfOf?: Reference

    @IsOptional()
    @IsString()
    sigFormat?: string

    @IsOptional()
    @IsString()
    targetFormat?: string

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    type: Coding[]

    @IsNotEmpty()
    @IsString()
    when: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    who: Reference

  }
  export class TimingRepeatDto implements TimingRepeat {
    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    boundsDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    boundsRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    boundsPeriod?: Period

    @IsOptional()
    @IsNumber()
    count?: number

    @IsOptional()
    @IsNumber()
    countMax?: number

    @IsOptional()
    @IsArray()
    @IsIn(["mon", "tue", "wed", "thu", "fri", "sat", "sun"], { each: true })
    dayOfWeek?: ("mon" | "tue" | "wed" | "thu" | "fri" | "sat" | "sun")[]

    @IsOptional()
    @IsNumber()
    duration?: number

    @IsOptional()
    @IsNumber()
    durationMax?: number

    @IsNotEmpty()
    @IsIn(["s", "min", "h", "d", "wk", "mo", "a"])
    durationUnit: "s" | "min" | "h" | "d" | "wk" | "mo" | "a"

    @IsOptional()
    @IsNumber()
    frequency?: number

    @IsOptional()
    @IsNumber()
    frequencyMax?: number

    @IsOptional()
    @IsNumber()
    offset?: number

    @IsOptional()
    @IsNumber()
    period?: number

    @IsOptional()
    @IsNumber()
    periodMax?: number

    @IsNotEmpty()
    @IsIn(["s", "min", "h", "d", "wk", "mo", "a"])
    periodUnit: "s" | "min" | "h" | "d" | "wk" | "mo" | "a"

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    timeOfDay?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    when?: string[]

  }
  export class TimingDto implements Timing {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    event?: string[]

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingRepeatDto)
    repeat?: TimingRepeat

  }
  export class TriggerDefinitionDto implements TriggerDefinition {
    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    condition?: Expression

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DataRequirementDto)
    data?: DataRequirement[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    timingTiming?: Timing

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    timingReference?: Reference

    @IsOptional()
    @IsString()
    timingDate?: string

    @IsOptional()
    @IsString()
    timingDateTime?: string

    @IsNotEmpty()
    @IsIn(["named-event", "periodic", "data-changed", "data-added", "data-modified", "data-removed", "data-accessed", "data-access-ended"])
    type: "named-event" | "periodic" | "data-changed" | "data-added" | "data-modified" | "data-removed" | "data-accessed" | "data-access-ended"

  }
  export class UsageContextDto implements UsageContext {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodingDto)
    code: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

  }
  export class AccountCoverageDto implements AccountCoverage {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    coverage: Reference

    @IsOptional()
    @IsNumber()
    priority?: number

  }
  export class AccountGuarantorDto implements AccountGuarantor {
    @IsNotEmpty()
    @IsBoolean()
    onHold: boolean

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    party: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

  }
  export class AccountDto implements Account {
    @IsNotEmpty()
    @IsIn(["Account"])
    resourceType: "Account"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AccountCoverageDto)
    coverage?: AccountCoverage[]

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AccountGuarantorDto)
    guarantor?: AccountGuarantor[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    owner?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    partOf?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    servicePeriod?: Period

    @IsNotEmpty()
    @IsIn(["active", "inactive", "entered-in-error", "on-hold", "unknown"])
    status: "active" | "inactive" | "entered-in-error" | "on-hold" | "unknown"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    subject?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class ActivityDefinitionParticipantDto implements ActivityDefinitionParticipant {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    role?: CodeableConcept

    @IsNotEmpty()
    @IsIn(["patient", "practitioner", "related-person", "device"])
    type: "patient" | "practitioner" | "related-person" | "device"

  }
  export class ActivityDefinitionDynamicValueDto implements ActivityDefinitionDynamicValue {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ExpressionDto)
    expression: Expression

    @IsNotEmpty()
    @IsString()
    path: string

  }
  export class ActivityDefinitionDto implements ActivityDefinition {
    @IsNotEmpty()
    @IsIn(["ActivityDefinition"])
    resourceType: "ActivityDefinition"

    @IsOptional()
    @IsString()
    approvalDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    author?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    bodySite?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsBoolean()
    doNotPerform: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DosageDto)
    dosage?: Dosage[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ActivityDefinitionDynamicValueDto)
    dynamicValue?: ActivityDefinitionDynamicValue[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    editor?: ContactDetail[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    endorser?: ContactDetail[]

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsNotEmpty()
    @IsIn(["proposal", "plan", "directive", "order", "original-order", "reflex-order", "filler-order", "instance-order", "option"])
    intent: "proposal" | "plan" | "directive" | "order" | "original-order" | "reflex-order" | "filler-order" | "instance-order" | "option"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    kind?: string

    @IsOptional()
    @IsString()
    lastReviewDate?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    library?: string[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    location?: Reference

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    observationRequirement?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    observationResultRequirement?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ActivityDefinitionParticipantDto)
    participant?: ActivityDefinitionParticipant[]

    @IsNotEmpty()
    @IsIn(["routine", "urgent", "asap", "stat"])
    priority: "routine" | "urgent" | "asap" | "stat"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    productReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productCodeableConcept?: CodeableConcept

    @IsOptional()
    @IsString()
    profile?: string

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    relatedArtifact?: RelatedArtifact[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    reviewer?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    specimenRequirement?: Reference[]

    @IsNotEmpty()
    @IsIn(["active", "unknown", "draft", "retired"])
    status: "active" | "unknown" | "draft" | "retired"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    subjectCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subjectReference?: Reference

    @IsOptional()
    @IsString()
    subjectCanonical?: string

    @IsOptional()
    @IsString()
    subtitle?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    timingTiming?: Timing

    @IsOptional()
    @IsString()
    timingDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    timingAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    timingPeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    timingRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    timingDuration?: Duration

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    topic?: CodeableConcept[]

    @IsOptional()
    @IsString()
    transform?: string

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsString()
    usage?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

  }
  export class AdministrableProductDefinitionPropertyDto implements AdministrableProductDefinitionProperty {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    status?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @IsString()
    valueDate?: string

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

  }
  export class AdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodDto implements AdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod {
    @IsOptional()
    @IsString()
    supportingInformation?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    tissue: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => QuantityDto)
    value: Quantity

  }
  export class AdministrableProductDefinitionRouteOfAdministrationTargetSpeciesDto implements AdministrableProductDefinitionRouteOfAdministrationTargetSpecies {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodDto)
    withdrawalPeriod?: AdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod[]

  }
  export class AdministrableProductDefinitionRouteOfAdministrationDto implements AdministrableProductDefinitionRouteOfAdministration {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    firstDose?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    maxDosePerDay?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    maxDosePerTreatmentPeriod?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    maxSingleDose?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    maxTreatmentPeriod?: Duration

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AdministrableProductDefinitionRouteOfAdministrationTargetSpeciesDto)
    targetSpecies?: AdministrableProductDefinitionRouteOfAdministrationTargetSpecies[]

  }
  export class AdministrableProductDefinitionDto implements AdministrableProductDefinition {
    @IsNotEmpty()
    @IsIn(["AdministrableProductDefinition"])
    resourceType: "AdministrableProductDefinition"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    administrableDoseForm?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    device?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    formOf?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    ingredient?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    producedFrom?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AdministrableProductDefinitionPropertyDto)
    property?: AdministrableProductDefinitionProperty[]

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AdministrableProductDefinitionRouteOfAdministrationDto)
    routeOfAdministration: AdministrableProductDefinitionRouteOfAdministration[]

    @IsNotEmpty()
    @IsIn(["active", "unknown", "draft", "retired"])
    status: "active" | "unknown" | "draft" | "retired"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    unitOfPresentation?: CodeableConcept

  }
  export class AdverseEventSuspectEntityCausalityDto implements AdverseEventSuspectEntityCausality {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    assessment?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    author?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    method?: CodeableConcept

    @IsOptional()
    @IsString()
    productRelatedness?: string

  }
  export class AdverseEventSuspectEntityDto implements AdverseEventSuspectEntity {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AdverseEventSuspectEntityCausalityDto)
    causality?: AdverseEventSuspectEntityCausality[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    instance: Reference

  }
  export class AdverseEventDto implements AdverseEvent {
    @IsNotEmpty()
    @IsIn(["AdverseEvent"])
    resourceType: "AdverseEvent"

    @IsNotEmpty()
    @IsIn(["actual", "potential"])
    actuality: "actual" | "potential"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    contributor?: Reference[]

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    detected?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    event?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    location?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    outcome?: CodeableConcept

    @IsOptional()
    @IsString()
    recordedDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    recorder?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    referenceDocument?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    resultingCondition?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    seriousness?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    severity?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    study?: Reference[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    subjectMedicalHistory?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AdverseEventSuspectEntityDto)
    suspectEntity?: AdverseEventSuspectEntity[]

  }
  export class AllergyIntoleranceReactionDto implements AllergyIntoleranceReaction {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    exposureRoute?: CodeableConcept

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    manifestation: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    onset?: string

    @IsNotEmpty()
    @IsIn(["mild", "moderate", "severe"])
    severity: "mild" | "moderate" | "severe"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    substance?: CodeableConcept

  }
  export class AllergyIntoleranceDto implements AllergyIntolerance {
    @IsNotEmpty()
    @IsIn(["AllergyIntolerance"])
    resourceType: "AllergyIntolerance"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    asserter?: Reference

    @IsOptional()
    @IsArray()
    @IsIn(["food", "medication", "environment", "biologic"], { each: true })
    category?: ("food" | "medication" | "environment" | "biologic")[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    clinicalStatus?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsNotEmpty()
    @IsIn(["low", "high", "unable-to-assess"])
    criticality: "low" | "high" | "unable-to-assess"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsString()
    lastOccurrence?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    onsetDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    onsetAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    onsetPeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    onsetRange?: Range

    @IsOptional()
    @IsString()
    onsetString?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AllergyIntoleranceReactionDto)
    reaction?: AllergyIntoleranceReaction[]

    @IsOptional()
    @IsString()
    recordedDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    recorder?: Reference

    @IsNotEmpty()
    @IsIn(["allergy", "intolerance"])
    type: "allergy" | "intolerance"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    verificationStatus?: CodeableConcept

  }
  export class AppointmentParticipantDto implements AppointmentParticipant {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    actor?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsNotEmpty()
    @IsIn(["required", "optional", "information-only"])
    required: "required" | "optional" | "information-only"

    @IsNotEmpty()
    @IsIn(["accepted", "declined", "tentative", "needs-action"])
    status: "accepted" | "declined" | "tentative" | "needs-action"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

  }
  export class AppointmentDto implements Appointment {
    @IsNotEmpty()
    @IsIn(["Appointment"])
    resourceType: "Appointment"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    appointmentType?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    cancelationReason?: CodeableConcept

    @IsOptional()
    @IsString()
    comment?: string

    @IsOptional()
    @IsString()
    created?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    end?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsNumber()
    minutesDuration?: number

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AppointmentParticipantDto)
    participant: AppointmentParticipant[]

    @IsOptional()
    @IsString()
    patientInstruction?: string

    @IsOptional()
    @IsNumber()
    priority?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    reasonCode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    reasonReference?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PeriodDto)
    requestedPeriod?: Period[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    serviceCategory?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    serviceType?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    slot?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    specialty?: CodeableConcept[]

    @IsOptional()
    @IsString()
    start?: string

    @IsNotEmpty()
    @IsIn(["entered-in-error", "proposed", "pending", "booked", "arrived", "fulfilled", "cancelled", "noshow", "checked-in", "waitlist"])
    status: "entered-in-error" | "proposed" | "pending" | "booked" | "arrived" | "fulfilled" | "cancelled" | "noshow" | "checked-in" | "waitlist"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    supportingInformation?: Reference[]

  }
  export class AppointmentResponseDto implements AppointmentResponse {
    @IsNotEmpty()
    @IsIn(["AppointmentResponse"])
    resourceType: "AppointmentResponse"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    actor?: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    appointment: Reference

    @IsOptional()
    @IsString()
    comment?: string

    @IsOptional()
    @IsString()
    end?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsNotEmpty()
    @IsIn(["accepted", "declined", "tentative", "needs-action"])
    participantStatus: "accepted" | "declined" | "tentative" | "needs-action"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    participantType?: CodeableConcept[]

    @IsOptional()
    @IsString()
    start?: string

  }
  export class AuditEventAgentNetworkDto implements AuditEventAgentNetwork {
    @IsOptional()
    @IsString()
    address?: string

    @IsOptional()
    @IsString()
    type?: string

  }
  export class AuditEventAgentDto implements AuditEventAgent {
    @IsOptional()
    @IsString()
    altId?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    location?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    media?: Coding

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AuditEventAgentNetworkDto)
    network?: AuditEventAgentNetwork

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    policy?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    purposeOfUse?: CodeableConcept[]

    @IsNotEmpty()
    @IsBoolean()
    requestor: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    role?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    who?: Reference

  }
  export class AuditEventSourceDto implements AuditEventSource {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    observer: Reference

    @IsOptional()
    @IsString()
    site?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    type?: Coding[]

  }
  export class AuditEventEntityDetailDto implements AuditEventEntityDetail {
    @IsNotEmpty()
    @IsString()
    type: string

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @IsString()
    valueBase64Binary?: string

  }
  export class AuditEventEntityDto implements AuditEventEntity {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AuditEventEntityDetailDto)
    detail?: AuditEventEntityDetail[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    lifecycle?: Coding

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsString()
    query?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    role?: Coding

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    securityLabel?: Coding[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    type?: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    what?: Reference

  }
  export class AuditEventDto implements AuditEvent {
    @IsNotEmpty()
    @IsIn(["AuditEvent"])
    resourceType: "AuditEvent"

    @IsOptional()
    @IsString()
    action?: string

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AuditEventAgentDto)
    agent: AuditEventAgent[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AuditEventEntityDto)
    entity?: AuditEventEntity[]

    @IsOptional()
    @IsString()
    outcome?: string

    @IsOptional()
    @IsString()
    outcomeDesc?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    purposeOfEvent?: CodeableConcept[]

    @IsNotEmpty()
    @IsString()
    recorded: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => AuditEventSourceDto)
    source: AuditEventSource

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    subtype?: Coding[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodingDto)
    type: Coding

  }
  export class BasicDto implements Basic {
    @IsNotEmpty()
    @IsIn(["Basic"])
    resourceType: "Basic"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    author?: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsOptional()
    @IsString()
    created?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

  }
  export class BinaryDto implements Binary {
    @IsNotEmpty()
    @IsIn(["Binary"])
    resourceType: "Binary"

    @IsNotEmpty()
    @IsString()
    contentType: string

    @IsOptional()
    @IsString()
    data?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    securityContext?: Reference

  }
  export class BiologicallyDerivedProductCollectionDto implements BiologicallyDerivedProductCollection {
    @IsOptional()
    @IsString()
    collectedDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    collectedPeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    collector?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    source?: Reference

  }
  export class BiologicallyDerivedProductProcessingDto implements BiologicallyDerivedProductProcessing {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    additive?: Reference

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    procedure?: CodeableConcept

    @IsOptional()
    @IsString()
    timeDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    timePeriod?: Period

  }
  export class BiologicallyDerivedProductManipulationDto implements BiologicallyDerivedProductManipulation {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    timeDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    timePeriod?: Period

  }
  export class BiologicallyDerivedProductStorageDto implements BiologicallyDerivedProductStorage {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    duration?: Period

    @IsNotEmpty()
    @IsIn(["farenheit", "celsius", "kelvin"])
    scale: "farenheit" | "celsius" | "kelvin"

    @IsOptional()
    @IsNumber()
    temperature?: number

  }
  export class BiologicallyDerivedProductDto implements BiologicallyDerivedProduct {
    @IsNotEmpty()
    @IsIn(["BiologicallyDerivedProduct"])
    resourceType: "BiologicallyDerivedProduct"

    @IsOptional()
    @ValidateNested()
    @Type(() => BiologicallyDerivedProductCollectionDto)
    collection?: BiologicallyDerivedProductCollection

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => BiologicallyDerivedProductManipulationDto)
    manipulation?: BiologicallyDerivedProductManipulation

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    parent?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => BiologicallyDerivedProductProcessingDto)
    processing?: BiologicallyDerivedProductProcessing[]

    @IsNotEmpty()
    @IsIn(["organ", "tissue", "fluid", "cells", "biologicalAgent"])
    productCategory: "organ" | "tissue" | "fluid" | "cells" | "biologicalAgent"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productCode?: CodeableConcept

    @IsOptional()
    @IsNumber()
    quantity?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    request?: Reference[]

    @IsNotEmpty()
    @IsIn(["available", "unavailable"])
    status: "available" | "unavailable"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => BiologicallyDerivedProductStorageDto)
    storage?: BiologicallyDerivedProductStorage[]

  }
  export class BodyStructureDto implements BodyStructure {
    @IsNotEmpty()
    @IsIn(["BodyStructure"])
    resourceType: "BodyStructure"

    @IsNotEmpty()
    @IsBoolean()
    active: boolean

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AttachmentDto)
    image?: Attachment[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    location?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    locationQualifier?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    morphology?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient: Reference

  }
  export class BundleLinkDto implements BundleLink {
    @IsNotEmpty()
    @IsString()
    relation: string

    @IsNotEmpty()
    @IsString()
    url: string

  }
  export class BundleEntrySearchDto implements BundleEntrySearch {
    @IsNotEmpty()
    @IsIn(["match", "include", "outcome"])
    mode: "match" | "include" | "outcome"

    @IsOptional()
    @IsNumber()
    score?: number

  }
  export class BundleEntryRequestDto implements BundleEntryRequest {
    @IsOptional()
    @IsString()
    ifMatch?: string

    @IsOptional()
    @IsString()
    ifModifiedSince?: string

    @IsOptional()
    @IsString()
    ifNoneExist?: string

    @IsOptional()
    @IsString()
    ifNoneMatch?: string

    @IsNotEmpty()
    @IsIn(["GET", "HEAD", "POST", "PUT", "DELETE", "PATCH"])
    method: "GET" | "HEAD" | "POST" | "PUT" | "DELETE" | "PATCH"

    @IsNotEmpty()
    @IsString()
    url: string

  }
  export class BundleEntryResponseDto implements BundleEntryResponse {
    @IsOptional()
    @IsString()
    etag?: string

    @IsOptional()
    @IsString()
    lastModified?: string

    @IsOptional()
    @IsString()
    location?: string

    @IsNotEmpty()
    outcome: Account | ActivityDefinition | AdministrableProductDefinition | AdverseEvent | AllergyIntolerance | Appointment | AppointmentResponse | AuditEvent | Basic | Binary | BiologicallyDerivedProduct | BodyStructure | Bundle<FhirResource> | CapabilityStatement | CarePlan | CareTeam | CatalogEntry | ChargeItem | ChargeItemDefinition | Citation | Claim | ClaimResponse | ClinicalImpression | ClinicalUseDefinition | CodeSystem | Communication | CommunicationRequest | CompartmentDefinition | Composition | ConceptMap | Condition | Consent | Contract | Coverage | CoverageEligibilityRequest | CoverageEligibilityResponse | DetectedIssue | Device | DeviceDefinition | DeviceMetric | DeviceRequest | DeviceUseStatement | DiagnosticReport | DocumentManifest | DocumentReference | Encounter | Endpoint | EnrollmentRequest | EnrollmentResponse | EpisodeOfCare | EventDefinition | Evidence | EvidenceReport | EvidenceVariable | ExampleScenario | ExplanationOfBenefit | FamilyMemberHistory | Flag | Goal | GraphDefinition | Group | GuidanceResponse | HealthcareService | ImagingStudy | Immunization | ImmunizationEvaluation | ImmunizationRecommendation | ImplementationGuide | Ingredient | InsurancePlan | Invoice | Library | Linkage | List | Location | ManufacturedItemDefinition | Measure | MeasureReport | Media | Medication | MedicationAdministration | MedicationDispense | MedicationKnowledge | MedicationRequest | MedicationStatement | MedicinalProductDefinition | MessageDefinition | MessageHeader | MolecularSequence | NamingSystem | NutritionOrder | NutritionProduct | Observation | ObservationDefinition | OperationDefinition | OperationOutcome | Organization | OrganizationAffiliation | PackagedProductDefinition | Parameters | Patient | PaymentNotice | PaymentReconciliation | Person | PlanDefinition | Practitioner | PractitionerRole | Procedure | Provenance | Questionnaire | QuestionnaireResponse | RegulatedAuthorization | RelatedPerson | RequestGroup | ResearchDefinition | ResearchElementDefinition | ResearchStudy | ResearchSubject | RiskAssessment | Schedule | SearchParameter | ServiceRequest | Slot | Specimen | SpecimenDefinition | StructureDefinition | StructureMap | Subscription | SubscriptionStatus | SubscriptionTopic | Substance | SubstanceDefinition | SupplyDelivery | SupplyRequest | Task | TerminologyCapabilities | TestReport | TestScript | ValueSet | VerificationResult | VisionPrescription

    @IsNotEmpty()
    @IsString()
    status: string

  }
  export class BundleEntryDto<BundleContentType = FhirResource> implements BundleEntry<BundleContentType> {
    @IsOptional()
    @IsString()
    fullUrl?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => BundleLinkDto)
    link?: BundleLink[]

    @IsOptional()
    @ValidateNested()
    @Type(() => BundleEntryRequestDto)
    request?: BundleEntryRequest

    @IsOptional()
    resource?: BundleContentType

    @IsOptional()
    @ValidateNested()
    @Type(() => BundleEntryResponseDto)
    response?: BundleEntryResponse

    @IsOptional()
    @ValidateNested()
    @Type(() => BundleEntrySearchDto)
    search?: BundleEntrySearch

  }
  export class BundleDto<BundleContentType = FhirResource> implements Bundle<BundleContentType> {
    @IsNotEmpty()
    @IsIn(["Bundle"])
    resourceType: "Bundle"

    @IsOptional()
    @IsArray()
    entry?: BundleEntry<BundleContentType>[]

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => BundleLinkDto)
    link?: BundleLink[]

    @IsOptional()
    @ValidateNested()
    @Type(() => SignatureDto)
    signature?: Signature

    @IsOptional()
    @IsString()
    timestamp?: string

    @IsOptional()
    @IsNumber()
    total?: number

    @IsNotEmpty()
    @IsIn(["document", "message", "transaction", "transaction-response", "batch", "batch-response", "history", "searchset", "collection"])
    type: "document" | "message" | "transaction" | "transaction-response" | "batch" | "batch-response" | "history" | "searchset" | "collection"

  }
  export class CapabilityStatementSoftwareDto implements CapabilityStatementSoftware {
    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @IsString()
    releaseDate?: string

    @IsOptional()
    @IsString()
    version?: string

  }
  export class CapabilityStatementImplementationDto implements CapabilityStatementImplementation {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    custodian?: Reference

    @IsNotEmpty()
    @IsString()
    description: string

    @IsOptional()
    @IsString()
    url?: string

  }
  export class CapabilityStatementRestSecurityDto implements CapabilityStatementRestSecurity {
    @IsNotEmpty()
    @IsBoolean()
    cors: boolean

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    service?: CodeableConcept[]

  }
  export class CapabilityStatementRestResourceInteractionDto implements CapabilityStatementRestResourceInteraction {
    @IsNotEmpty()
    @IsIn(["read", "vread", "update", "patch", "delete", "history-instance", "history-type", "create", "search-type"])
    code: "read" | "vread" | "update" | "patch" | "delete" | "history-instance" | "history-type" | "create" | "search-type"

    @IsOptional()
    @IsString()
    documentation?: string

  }
  export class CapabilityStatementRestResourceSearchParamDto implements CapabilityStatementRestResourceSearchParam {
    @IsOptional()
    @IsString()
    definition?: string

    @IsOptional()
    @IsString()
    documentation?: string

    @IsNotEmpty()
    @IsString()
    name: string

    @IsNotEmpty()
    @IsIn(["string", "number", "date", "token", "reference", "composite", "quantity", "uri", "special"])
    type: "string" | "number" | "date" | "token" | "reference" | "composite" | "quantity" | "uri" | "special"

  }
  export class CapabilityStatementRestResourceOperationDto implements CapabilityStatementRestResourceOperation {
    @IsNotEmpty()
    @IsString()
    definition: string

    @IsOptional()
    @IsString()
    documentation?: string

    @IsNotEmpty()
    @IsString()
    name: string

  }
  export class CapabilityStatementRestResourceDto implements CapabilityStatementRestResource {
    @IsNotEmpty()
    @IsBoolean()
    conditionalCreate: boolean

    @IsNotEmpty()
    @IsIn(["not-supported", "single", "multiple"])
    conditionalDelete: "not-supported" | "single" | "multiple"

    @IsNotEmpty()
    @IsIn(["not-supported", "modified-since", "not-match", "full-support"])
    conditionalRead: "not-supported" | "modified-since" | "not-match" | "full-support"

    @IsNotEmpty()
    @IsBoolean()
    conditionalUpdate: boolean

    @IsOptional()
    @IsString()
    documentation?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CapabilityStatementRestResourceInteractionDto)
    interaction?: CapabilityStatementRestResourceInteraction[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CapabilityStatementRestResourceOperationDto)
    operation?: CapabilityStatementRestResourceOperation[]

    @IsOptional()
    @IsString()
    profile?: string

    @IsNotEmpty()
    @IsBoolean()
    readHistory: boolean

    @IsOptional()
    @IsArray()
    @IsIn(["literal", "logical", "resolves", "enforced", "local"], { each: true })
    referencePolicy?: ("literal" | "logical" | "resolves" | "enforced" | "local")[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    searchInclude?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CapabilityStatementRestResourceSearchParamDto)
    searchParam?: CapabilityStatementRestResourceSearchParam[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    searchRevInclude?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    supportedProfile?: string[]

    @IsNotEmpty()
    @IsString()
    type: string

    @IsNotEmpty()
    @IsBoolean()
    updateCreate: boolean

    @IsNotEmpty()
    @IsIn(["no-version", "versioned", "versioned-update"])
    versioning: "no-version" | "versioned" | "versioned-update"

  }
  export class CapabilityStatementRestInteractionDto implements CapabilityStatementRestInteraction {
    @IsNotEmpty()
    @IsIn(["transaction", "batch", "search-system", "history-system"])
    code: "transaction" | "batch" | "search-system" | "history-system"

    @IsOptional()
    @IsString()
    documentation?: string

  }
  export class CapabilityStatementRestDto implements CapabilityStatementRest {
    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    compartment?: string[]

    @IsOptional()
    @IsString()
    documentation?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CapabilityStatementRestInteractionDto)
    interaction?: CapabilityStatementRestInteraction[]

    @IsNotEmpty()
    @IsIn(["client", "server"])
    mode: "client" | "server"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CapabilityStatementRestResourceOperationDto)
    operation?: CapabilityStatementRestResourceOperation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CapabilityStatementRestResourceDto)
    resource?: CapabilityStatementRestResource[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CapabilityStatementRestResourceSearchParamDto)
    searchParam?: CapabilityStatementRestResourceSearchParam[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CapabilityStatementRestSecurityDto)
    security?: CapabilityStatementRestSecurity

  }
  export class CapabilityStatementMessagingEndpointDto implements CapabilityStatementMessagingEndpoint {
    @IsNotEmpty()
    @IsString()
    address: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodingDto)
    protocol: Coding

  }
  export class CapabilityStatementMessagingSupportedMessageDto implements CapabilityStatementMessagingSupportedMessage {
    @IsNotEmpty()
    @IsString()
    definition: string

    @IsNotEmpty()
    @IsIn(["sender", "receiver"])
    mode: "sender" | "receiver"

  }
  export class CapabilityStatementMessagingDto implements CapabilityStatementMessaging {
    @IsOptional()
    @IsString()
    documentation?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CapabilityStatementMessagingEndpointDto)
    endpoint?: CapabilityStatementMessagingEndpoint[]

    @IsOptional()
    @IsNumber()
    reliableCache?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CapabilityStatementMessagingSupportedMessageDto)
    supportedMessage?: CapabilityStatementMessagingSupportedMessage[]

  }
  export class CapabilityStatementDocumentDto implements CapabilityStatementDocument {
    @IsOptional()
    @IsString()
    documentation?: string

    @IsNotEmpty()
    @IsIn(["producer", "consumer"])
    mode: "producer" | "consumer"

    @IsNotEmpty()
    @IsString()
    profile: string

  }
  export class CapabilityStatementDto implements CapabilityStatement {
    @IsNotEmpty()
    @IsIn(["CapabilityStatement"])
    resourceType: "CapabilityStatement"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsNotEmpty()
    @IsString()
    date: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CapabilityStatementDocumentDto)
    document?: CapabilityStatementDocument[]

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsNotEmpty()
    @IsString()
    fhirVersion: string

    @IsNotEmpty()
    @IsArray()
    @IsString({ each: true })
    format: string[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CapabilityStatementImplementationDto)
    implementation?: CapabilityStatementImplementation

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    implementationGuide?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    imports?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiates?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsNotEmpty()
    @IsIn(["instance", "capability", "requirements"])
    kind: "instance" | "capability" | "requirements"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CapabilityStatementMessagingDto)
    messaging?: CapabilityStatementMessaging[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    patchFormat?: string[]

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CapabilityStatementRestDto)
    rest?: CapabilityStatementRest[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CapabilityStatementSoftwareDto)
    software?: CapabilityStatementSoftware

    @IsNotEmpty()
    @IsIn(["active", "unknown", "draft", "retired"])
    status: "active" | "unknown" | "draft" | "retired"

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

  }
  export class CarePlanActivityDetailDto implements CarePlanActivityDetail {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    dailyAmount?: Quantity

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsBoolean()
    doNotPerform: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    goal?: Reference[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesCanonical?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesUri?: string[]

    @IsNotEmpty()
    @IsIn(["Appointment", "CommunicationRequest", "DeviceRequest", "MedicationRequest", "NutritionOrder", "Task", "ServiceRequest", "VisionPrescription"])
    kind: "Appointment" | "CommunicationRequest" | "DeviceRequest" | "MedicationRequest" | "NutritionOrder" | "Task" | "ServiceRequest" | "VisionPrescription"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    location?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    performer?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    productReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    reasonCode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    reasonReference?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    scheduledTiming?: Timing

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    scheduledPeriod?: Period

    @IsOptional()
    @IsString()
    scheduledString?: string

    @IsNotEmpty()
    @IsIn(["entered-in-error", "on-hold", "unknown", "cancelled", "not-started", "scheduled", "in-progress", "completed", "stopped"])
    status: "entered-in-error" | "on-hold" | "unknown" | "cancelled" | "not-started" | "scheduled" | "in-progress" | "completed" | "stopped"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    statusReason?: CodeableConcept

  }
  export class CarePlanActivityDto implements CarePlanActivity {
    @IsOptional()
    @ValidateNested()
    @Type(() => CarePlanActivityDetailDto)
    detail?: CarePlanActivityDetail

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    outcomeCodeableConcept?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    outcomeReference?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    progress?: Annotation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    reference?: Reference

  }
  export class CarePlanDto implements CarePlan {
    @IsNotEmpty()
    @IsIn(["CarePlan"])
    resourceType: "CarePlan"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CarePlanActivityDto)
    activity?: CarePlanActivity[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    addresses?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    author?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    careTeam?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    contributor?: Reference[]

    @IsOptional()
    @IsString()
    created?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    goal?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesCanonical?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesUri?: string[]

    @IsNotEmpty()
    @IsIn(["proposal", "plan", "order", "option"])
    intent: "proposal" | "plan" | "order" | "option"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    partOf?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    replaces?: Reference[]

    @IsNotEmpty()
    @IsIn(["active", "entered-in-error", "on-hold", "unknown", "draft", "completed", "revoked"])
    status: "active" | "entered-in-error" | "on-hold" | "unknown" | "draft" | "completed" | "revoked"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    supportingInfo?: Reference[]

    @IsOptional()
    @IsString()
    title?: string

  }
  export class CareTeamParticipantDto implements CareTeamParticipant {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    member?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    onBehalfOf?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    role?: CodeableConcept[]

  }
  export class CareTeamDto implements CareTeam {
    @IsNotEmpty()
    @IsIn(["CareTeam"])
    resourceType: "CareTeam"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    managingOrganization?: Reference[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CareTeamParticipantDto)
    participant?: CareTeamParticipant[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    reasonCode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    reasonReference?: Reference[]

    @IsNotEmpty()
    @IsIn(["active", "inactive", "entered-in-error", "proposed", "suspended"])
    status: "active" | "inactive" | "entered-in-error" | "proposed" | "suspended"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactPointDto)
    telecom?: ContactPoint[]

  }
  export class CatalogEntryRelatedEntryDto implements CatalogEntryRelatedEntry {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    item: Reference

    @IsNotEmpty()
    @IsIn(["triggers", "is-replaced-by"])
    relationtype: "triggers" | "is-replaced-by"

  }
  export class CatalogEntryDto implements CatalogEntry {
    @IsNotEmpty()
    @IsIn(["CatalogEntry"])
    resourceType: "CatalogEntry"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    additionalCharacteristic?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    additionalClassification?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    additionalIdentifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    classification?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsString()
    lastUpdated?: string

    @IsNotEmpty()
    @IsBoolean()
    orderable: boolean

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    referencedItem: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CatalogEntryRelatedEntryDto)
    relatedEntry?: CatalogEntryRelatedEntry[]

    @IsNotEmpty()
    @IsIn(["active", "unknown", "draft", "retired"])
    status: "active" | "unknown" | "draft" | "retired"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    validityPeriod?: Period

    @IsOptional()
    @IsString()
    validTo?: string

  }
  export class ChargeItemPerformerDto implements ChargeItemPerformer {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    actor: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    function?: CodeableConcept

  }
  export class ChargeItemDto implements ChargeItem {
    @IsNotEmpty()
    @IsIn(["ChargeItem"])
    resourceType: "ChargeItem"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    account?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    bodysite?: CodeableConcept[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    context?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    costCenter?: Reference

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    definitionCanonical?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    definitionUri?: string[]

    @IsOptional()
    @IsString()
    enteredDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    enterer?: Reference

    @IsOptional()
    @IsNumber()
    factorOverride?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    occurrenceDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    occurrencePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    occurrenceTiming?: Timing

    @IsOptional()
    @IsString()
    overrideReason?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    partOf?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ChargeItemPerformerDto)
    performer?: ChargeItemPerformer[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    performingOrganization?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    priceOverride?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    productReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    reason?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    requestingOrganization?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    service?: Reference[]

    @IsNotEmpty()
    @IsIn(["entered-in-error", "unknown", "planned", "billable", "not-billable", "aborted", "billed"])
    status: "entered-in-error" | "unknown" | "planned" | "billable" | "not-billable" | "aborted" | "billed"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    supportingInformation?: Reference[]

  }
  export class ChargeItemDefinitionApplicabilityDto implements ChargeItemDefinitionApplicability {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    expression?: string

    @IsOptional()
    @IsString()
    language?: string

  }
  export class ChargeItemDefinitionPropertyGroupPriceComponentDto implements ChargeItemDefinitionPropertyGroupPriceComponent {
    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    amount?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsNumber()
    factor?: number

    @IsNotEmpty()
    @IsIn(["base", "surcharge", "deduction", "discount", "tax", "informational"])
    type: "base" | "surcharge" | "deduction" | "discount" | "tax" | "informational"

  }
  export class ChargeItemDefinitionPropertyGroupDto implements ChargeItemDefinitionPropertyGroup {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ChargeItemDefinitionApplicabilityDto)
    applicability?: ChargeItemDefinitionApplicability[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ChargeItemDefinitionPropertyGroupPriceComponentDto)
    priceComponent?: ChargeItemDefinitionPropertyGroupPriceComponent[]

  }
  export class ChargeItemDefinitionDto implements ChargeItemDefinition {
    @IsNotEmpty()
    @IsIn(["ChargeItemDefinition"])
    resourceType: "ChargeItemDefinition"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ChargeItemDefinitionApplicabilityDto)
    applicability?: ChargeItemDefinitionApplicability[]

    @IsOptional()
    @IsString()
    approvalDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    derivedFromUri?: string[]

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    instance?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    lastReviewDate?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    partOf?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ChargeItemDefinitionPropertyGroupDto)
    propertyGroup?: ChargeItemDefinitionPropertyGroup[]

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    replaces?: string[]

    @IsNotEmpty()
    @IsIn(["active", "unknown", "draft", "retired"])
    status: "active" | "unknown" | "draft" | "retired"

    @IsOptional()
    @IsString()
    title?: string

    @IsNotEmpty()
    @IsString()
    url: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

  }
  export class CitationSummaryDto implements CitationSummary {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    style?: CodeableConcept

    @IsNotEmpty()
    @IsString()
    text: string

  }
  export class CitationClassificationDto implements CitationClassification {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    classifier?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class CitationStatusDateDto implements CitationStatusDate {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    activity: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    actual: boolean

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => PeriodDto)
    period: Period

  }
  export class CitationRelatesToDto implements CitationRelatesTo {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    relationshipType: CodeableConcept

    @IsOptional()
    @IsString()
    targetUri?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    targetIdentifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    targetReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    targetAttachment?: Attachment

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    targetClassifier?: CodeableConcept[]

  }
  export class CitationCitedArtifactVersionDto implements CitationCitedArtifactVersion {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    baseCitation?: Reference

    @IsNotEmpty()
    @IsString()
    value: string

  }
  export class CitationCitedArtifactStatusDateDto implements CitationCitedArtifactStatusDate {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    activity: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    actual: boolean

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => PeriodDto)
    period: Period

  }
  export class CitationCitedArtifactTitleDto implements CitationCitedArtifactTitle {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    language?: CodeableConcept

    @IsNotEmpty()
    @IsString()
    text: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

  }
  export class CitationCitedArtifactAbstractDto implements CitationCitedArtifactAbstract {
    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    language?: CodeableConcept

    @IsNotEmpty()
    @IsString()
    text: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class CitationCitedArtifactPartDto implements CitationCitedArtifactPart {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    baseCitation?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsOptional()
    @IsString()
    value?: string

  }
  export class CitationCitedArtifactRelatesToDto implements CitationCitedArtifactRelatesTo {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    relationshipType: CodeableConcept

    @IsOptional()
    @IsString()
    targetUri?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    targetIdentifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    targetReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    targetAttachment?: Attachment

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    targetClassifier?: CodeableConcept[]

  }
  export class CitationCitedArtifactPublicationFormPublishedInDto implements CitationCitedArtifactPublicationFormPublishedIn {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    publisher?: Reference

    @IsOptional()
    @IsString()
    publisherLocation?: string

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class CitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationDto implements CitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication {
    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    day?: string

    @IsOptional()
    @IsString()
    month?: string

    @IsOptional()
    @IsString()
    season?: string

    @IsOptional()
    @IsString()
    text?: string

    @IsOptional()
    @IsString()
    year?: string

  }
  export class CitationCitedArtifactPublicationFormPeriodicReleaseDto implements CitationCitedArtifactPublicationFormPeriodicRelease {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    citedMedium?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublicationDto)
    dateOfPublication?: CitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication

    @IsOptional()
    @IsString()
    issue?: string

    @IsOptional()
    @IsString()
    volume?: string

  }
  export class CitationCitedArtifactPublicationFormDto implements CitationCitedArtifactPublicationForm {
    @IsOptional()
    @IsString()
    accessionNumber?: string

    @IsOptional()
    @IsString()
    articleDate?: string

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    firstPage?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    language?: CodeableConcept[]

    @IsOptional()
    @IsString()
    lastPage?: string

    @IsOptional()
    @IsString()
    lastRevisionDate?: string

    @IsOptional()
    @IsString()
    pageCount?: string

    @IsOptional()
    @IsString()
    pageString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CitationCitedArtifactPublicationFormPeriodicReleaseDto)
    periodicRelease?: CitationCitedArtifactPublicationFormPeriodicRelease

    @IsOptional()
    @ValidateNested()
    @Type(() => CitationCitedArtifactPublicationFormPublishedInDto)
    publishedIn?: CitationCitedArtifactPublicationFormPublishedIn

  }
  export class CitationCitedArtifactWebLocationDto implements CitationCitedArtifactWebLocation {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsOptional()
    @IsString()
    url?: string

  }
  export class CitationCitedArtifactClassificationWhoClassifiedDto implements CitationCitedArtifactClassificationWhoClassified {
    @IsOptional()
    @IsString()
    classifierCopyright?: string

    @IsNotEmpty()
    @IsBoolean()
    freeToShare: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    organization?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    person?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    publisher?: Reference

  }
  export class CitationCitedArtifactClassificationDto implements CitationCitedArtifactClassification {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    classifier?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CitationCitedArtifactClassificationWhoClassifiedDto)
    whoClassified?: CitationCitedArtifactClassificationWhoClassified

  }
  export class CitationCitedArtifactContributorshipEntryAffiliationInfoDto implements CitationCitedArtifactContributorshipEntryAffiliationInfo {
    @IsOptional()
    @IsString()
    affiliation?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsString()
    role?: string

  }
  export class CitationCitedArtifactContributorshipEntryContributionInstanceDto implements CitationCitedArtifactContributorshipEntryContributionInstance {
    @IsOptional()
    @IsString()
    time?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class CitationCitedArtifactContributorshipEntryDto implements CitationCitedArtifactContributorshipEntry {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AddressDto)
    address?: Address[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CitationCitedArtifactContributorshipEntryAffiliationInfoDto)
    affiliationInfo?: CitationCitedArtifactContributorshipEntryAffiliationInfo[]

    @IsOptional()
    @IsString()
    collectiveName?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CitationCitedArtifactContributorshipEntryContributionInstanceDto)
    contributionInstance?: CitationCitedArtifactContributorshipEntryContributionInstance[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    contributionType?: CodeableConcept[]

    @IsNotEmpty()
    @IsBoolean()
    correspondingContact: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsString()
    initials?: string

    @IsOptional()
    @IsNumber()
    listOrder?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => HumanNameDto)
    name?: HumanName

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    role?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactPointDto)
    telecom?: ContactPoint[]

  }
  export class CitationCitedArtifactContributorshipSummaryDto implements CitationCitedArtifactContributorshipSummary {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    source?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    style?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsNotEmpty()
    @IsString()
    value: string

  }
  export class CitationCitedArtifactContributorshipDto implements CitationCitedArtifactContributorship {
    @IsNotEmpty()
    @IsBoolean()
    complete: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CitationCitedArtifactContributorshipEntryDto)
    entry?: CitationCitedArtifactContributorshipEntry[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CitationCitedArtifactContributorshipSummaryDto)
    summary?: CitationCitedArtifactContributorshipSummary[]

  }
  export class CitationCitedArtifactDto implements CitationCitedArtifact {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CitationCitedArtifactAbstractDto)
    abstract?: CitationCitedArtifactAbstract[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CitationCitedArtifactClassificationDto)
    classification?: CitationCitedArtifactClassification[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CitationCitedArtifactContributorshipDto)
    contributorship?: CitationCitedArtifactContributorship

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    currentState?: CodeableConcept[]

    @IsOptional()
    @IsString()
    dateAccessed?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CitationCitedArtifactPartDto)
    part?: CitationCitedArtifactPart

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CitationCitedArtifactPublicationFormDto)
    publicationForm?: CitationCitedArtifactPublicationForm[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    relatedIdentifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CitationCitedArtifactRelatesToDto)
    relatesTo?: CitationCitedArtifactRelatesTo[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CitationCitedArtifactStatusDateDto)
    statusDate?: CitationCitedArtifactStatusDate[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CitationCitedArtifactTitleDto)
    title?: CitationCitedArtifactTitle[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CitationCitedArtifactVersionDto)
    version?: CitationCitedArtifactVersion

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CitationCitedArtifactWebLocationDto)
    webLocation?: CitationCitedArtifactWebLocation[]

  }
  export class CitationDto implements Citation {
    @IsNotEmpty()
    @IsIn(["Citation"])
    resourceType: "Citation"

    @IsOptional()
    @IsString()
    approvalDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    author?: ContactDetail[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CitationCitedArtifactDto)
    citedArtifact?: CitationCitedArtifact

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CitationClassificationDto)
    classification?: CitationClassification[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    currentState?: CodeableConcept[]

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    editor?: ContactDetail[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    endorser?: ContactDetail[]

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    lastReviewDate?: string

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CitationRelatesToDto)
    relatesTo?: CitationRelatesTo[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    reviewer?: ContactDetail[]

    @IsNotEmpty()
    @IsIn(["active", "unknown", "draft", "retired"])
    status: "active" | "unknown" | "draft" | "retired"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CitationStatusDateDto)
    statusDate?: CitationStatusDate[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CitationSummaryDto)
    summary?: CitationSummary[]

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

  }
  export class ClaimRelatedDto implements ClaimRelated {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    claim?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    reference?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    relationship?: CodeableConcept

  }
  export class ClaimPayeeDto implements ClaimPayee {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    party?: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class ClaimCareTeamDto implements ClaimCareTeam {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    provider: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    qualification?: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    responsible: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    role?: CodeableConcept

    @IsNotEmpty()
    @IsNumber()
    sequence: number

  }
  export class ClaimSupportingInfoDto implements ClaimSupportingInfo {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    reason?: CodeableConcept

    @IsNotEmpty()
    @IsNumber()
    sequence: number

    @IsOptional()
    @IsString()
    timingDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    timingPeriod?: Period

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

  }
  export class ClaimDiagnosisDto implements ClaimDiagnosis {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    diagnosisCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    diagnosisReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    onAdmission?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    packageCode?: CodeableConcept

    @IsNotEmpty()
    @IsNumber()
    sequence: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

  }
  export class ClaimProcedureDto implements ClaimProcedure {
    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    procedureCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    procedureReference?: Reference

    @IsNotEmpty()
    @IsNumber()
    sequence: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    udi?: Reference[]

  }
  export class ClaimInsuranceDto implements ClaimInsurance {
    @IsOptional()
    @IsString()
    businessArrangement?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    claimResponse?: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    coverage: Reference

    @IsNotEmpty()
    @IsBoolean()
    focal: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    preAuthRef?: string[]

    @IsNotEmpty()
    @IsNumber()
    sequence: number

  }
  export class ClaimAccidentDto implements ClaimAccident {
    @IsNotEmpty()
    @IsString()
    date: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    locationAddress?: Address

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    locationReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class ClaimItemDetailSubDetailDto implements ClaimItemDetailSubDetail {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept

    @IsOptional()
    @IsNumber()
    factor?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    modifier?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    net?: Money

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrService: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    programCode?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    revenue?: CodeableConcept

    @IsNotEmpty()
    @IsNumber()
    sequence: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    udi?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    unitPrice?: Money

  }
  export class ClaimItemDetailDto implements ClaimItemDetail {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept

    @IsOptional()
    @IsNumber()
    factor?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    modifier?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    net?: Money

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrService: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    programCode?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    revenue?: CodeableConcept

    @IsNotEmpty()
    @IsNumber()
    sequence: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimItemDetailSubDetailDto)
    subDetail?: ClaimItemDetailSubDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    udi?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    unitPrice?: Money

  }
  export class ClaimItemDto implements ClaimItem {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    bodySite?: CodeableConcept

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    careTeamSequence?: number[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimItemDetailDto)
    detail?: ClaimItemDetail[]

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    diagnosisSequence?: number[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    encounter?: Reference[]

    @IsOptional()
    @IsNumber()
    factor?: number

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    informationSequence?: number[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    locationCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    locationAddress?: Address

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    locationReference?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    modifier?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    net?: Money

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    procedureSequence?: number[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrService: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    programCode?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    revenue?: CodeableConcept

    @IsNotEmpty()
    @IsNumber()
    sequence: number

    @IsOptional()
    @IsString()
    servicedDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    servicedPeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    subSite?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    udi?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    unitPrice?: Money

  }
  export class ClaimDto implements Claim {
    @IsNotEmpty()
    @IsIn(["Claim"])
    resourceType: "Claim"

    @IsOptional()
    @ValidateNested()
    @Type(() => ClaimAccidentDto)
    accident?: ClaimAccident

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    billablePeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimCareTeamDto)
    careTeam?: ClaimCareTeam[]

    @IsNotEmpty()
    @IsString()
    created: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimDiagnosisDto)
    diagnosis?: ClaimDiagnosis[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    enterer?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    facility?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    fundsReserve?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimInsuranceDto)
    insurance: ClaimInsurance[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    insurer?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimItemDto)
    item?: ClaimItem[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    originalPrescription?: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ClaimPayeeDto)
    payee?: ClaimPayee

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    prescription?: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    priority: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimProcedureDto)
    procedure?: ClaimProcedure[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    provider: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    referral?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimRelatedDto)
    related?: ClaimRelated[]

    @IsNotEmpty()
    @IsIn(["active", "entered-in-error", "draft", "cancelled"])
    status: "active" | "entered-in-error" | "draft" | "cancelled"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    subType?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimSupportingInfoDto)
    supportingInfo?: ClaimSupportingInfo[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    total?: Money

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsNotEmpty()
    @IsIn(["claim", "preauthorization", "predetermination"])
    use: "claim" | "preauthorization" | "predetermination"

  }
  export class ClaimResponseItemAdjudicationDto implements ClaimResponseItemAdjudication {
    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    amount?: Money

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    reason?: CodeableConcept

    @IsOptional()
    @IsNumber()
    value?: number

  }
  export class ClaimResponseItemDetailSubDetailDto implements ClaimResponseItemDetailSubDetail {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimResponseItemAdjudicationDto)
    adjudication?: ClaimResponseItemAdjudication[]

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    noteNumber?: number[]

    @IsNotEmpty()
    @IsNumber()
    subDetailSequence: number

  }
  export class ClaimResponseItemDetailDto implements ClaimResponseItemDetail {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimResponseItemAdjudicationDto)
    adjudication: ClaimResponseItemAdjudication[]

    @IsNotEmpty()
    @IsNumber()
    detailSequence: number

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    noteNumber?: number[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimResponseItemDetailSubDetailDto)
    subDetail?: ClaimResponseItemDetailSubDetail[]

  }
  export class ClaimResponseItemDto implements ClaimResponseItem {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimResponseItemAdjudicationDto)
    adjudication: ClaimResponseItemAdjudication[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimResponseItemDetailDto)
    detail?: ClaimResponseItemDetail[]

    @IsNotEmpty()
    @IsNumber()
    itemSequence: number

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    noteNumber?: number[]

  }
  export class ClaimResponseAddItemDetailSubDetailDto implements ClaimResponseAddItemDetailSubDetail {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimResponseItemAdjudicationDto)
    adjudication: ClaimResponseItemAdjudication[]

    @IsOptional()
    @IsNumber()
    factor?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    modifier?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    net?: Money

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    noteNumber?: number[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrService: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    unitPrice?: Money

  }
  export class ClaimResponseAddItemDetailDto implements ClaimResponseAddItemDetail {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimResponseItemAdjudicationDto)
    adjudication: ClaimResponseItemAdjudication[]

    @IsOptional()
    @IsNumber()
    factor?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    modifier?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    net?: Money

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    noteNumber?: number[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrService: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimResponseAddItemDetailSubDetailDto)
    subDetail?: ClaimResponseAddItemDetailSubDetail[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    unitPrice?: Money

  }
  export class ClaimResponseAddItemDto implements ClaimResponseAddItem {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimResponseItemAdjudicationDto)
    adjudication: ClaimResponseItemAdjudication[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    bodySite?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimResponseAddItemDetailDto)
    detail?: ClaimResponseAddItemDetail[]

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    detailSequence?: number[]

    @IsOptional()
    @IsNumber()
    factor?: number

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    itemSequence?: number[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    locationCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    locationAddress?: Address

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    locationReference?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    modifier?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    net?: Money

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    noteNumber?: number[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrService: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    programCode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    provider?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @IsString()
    servicedDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    servicedPeriod?: Period

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    subdetailSequence?: number[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    subSite?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    unitPrice?: Money

  }
  export class ClaimResponseTotalDto implements ClaimResponseTotal {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => MoneyDto)
    amount: Money

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category: CodeableConcept

  }
  export class ClaimResponsePaymentDto implements ClaimResponsePayment {
    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    adjustment?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    adjustmentReason?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => MoneyDto)
    amount: Money

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class ClaimResponseProcessNoteDto implements ClaimResponseProcessNote {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    language?: CodeableConcept

    @IsOptional()
    @IsNumber()
    number?: number

    @IsNotEmpty()
    @IsString()
    text: string

    @IsNotEmpty()
    @IsIn(["display", "print", "printoper"])
    type: "display" | "print" | "printoper"

  }
  export class ClaimResponseInsuranceDto implements ClaimResponseInsurance {
    @IsOptional()
    @IsString()
    businessArrangement?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    claimResponse?: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    coverage: Reference

    @IsNotEmpty()
    @IsBoolean()
    focal: boolean

    @IsNotEmpty()
    @IsNumber()
    sequence: number

  }
  export class ClaimResponseErrorDto implements ClaimResponseError {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsOptional()
    @IsNumber()
    detailSequence?: number

    @IsOptional()
    @IsNumber()
    itemSequence?: number

    @IsOptional()
    @IsNumber()
    subDetailSequence?: number

  }
  export class ClaimResponseDto implements ClaimResponse {
    @IsNotEmpty()
    @IsIn(["ClaimResponse"])
    resourceType: "ClaimResponse"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimResponseAddItemDto)
    addItem?: ClaimResponseAddItem[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimResponseItemAdjudicationDto)
    adjudication?: ClaimResponseItemAdjudication[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    communicationRequest?: Reference[]

    @IsNotEmpty()
    @IsString()
    created: string

    @IsOptional()
    @IsString()
    disposition?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimResponseErrorDto)
    error?: ClaimResponseError[]

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    form?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    formCode?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    fundsReserve?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimResponseInsuranceDto)
    insurance?: ClaimResponseInsurance[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    insurer: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimResponseItemDto)
    item?: ClaimResponseItem[]

    @IsNotEmpty()
    @IsIn(["error", "queued", "complete", "partial"])
    outcome: "error" | "queued" | "complete" | "partial"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    payeeType?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ClaimResponsePaymentDto)
    payment?: ClaimResponsePayment

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    preAuthPeriod?: Period

    @IsOptional()
    @IsString()
    preAuthRef?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimResponseProcessNoteDto)
    processNote?: ClaimResponseProcessNote[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    request?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    requestor?: Reference

    @IsNotEmpty()
    @IsIn(["active", "entered-in-error", "draft", "cancelled"])
    status: "active" | "entered-in-error" | "draft" | "cancelled"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    subType?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClaimResponseTotalDto)
    total?: ClaimResponseTotal[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsNotEmpty()
    @IsIn(["claim", "preauthorization", "predetermination"])
    use: "claim" | "preauthorization" | "predetermination"

  }
  export class ClinicalImpressionInvestigationDto implements ClinicalImpressionInvestigation {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    item?: Reference[]

  }
  export class ClinicalImpressionFindingDto implements ClinicalImpressionFinding {
    @IsOptional()
    @IsString()
    basis?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    itemCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    itemReference?: Reference

  }
  export class ClinicalImpressionDto implements ClinicalImpression {
    @IsNotEmpty()
    @IsIn(["ClinicalImpression"])
    resourceType: "ClinicalImpression"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    assessor?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    effectiveDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClinicalImpressionFindingDto)
    finding?: ClinicalImpressionFinding[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClinicalImpressionInvestigationDto)
    investigation?: ClinicalImpressionInvestigation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    previous?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    problem?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    prognosisCodeableConcept?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    prognosisReference?: Reference[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    protocol?: string[]

    @IsNotEmpty()
    @IsIn(["entered-in-error", "in-progress", "completed"])
    status: "entered-in-error" | "in-progress" | "completed"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    statusReason?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

    @IsOptional()
    @IsString()
    summary?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    supportingInfo?: Reference[]

  }
  export class ClinicalUseDefinitionContraindicationOtherTherapyDto implements ClinicalUseDefinitionContraindicationOtherTherapy {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    relationshipType: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    therapy: CodeableReference

  }
  export class ClinicalUseDefinitionContraindicationDto implements ClinicalUseDefinitionContraindication {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    comorbidity?: CodeableReference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    diseaseStatus?: CodeableReference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    diseaseSymptomProcedure?: CodeableReference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    indication?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClinicalUseDefinitionContraindicationOtherTherapyDto)
    otherTherapy?: ClinicalUseDefinitionContraindicationOtherTherapy[]

  }
  export class ClinicalUseDefinitionIndicationDto implements ClinicalUseDefinitionIndication {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    comorbidity?: CodeableReference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    diseaseStatus?: CodeableReference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    diseaseSymptomProcedure?: CodeableReference

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    durationRange?: Range

    @IsOptional()
    @IsString()
    durationString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    intendedEffect?: CodeableReference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClinicalUseDefinitionContraindicationOtherTherapyDto)
    otherTherapy?: ClinicalUseDefinitionContraindicationOtherTherapy[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    undesirableEffect?: Reference[]

  }
  export class ClinicalUseDefinitionInteractionInteractantDto implements ClinicalUseDefinitionInteractionInteractant {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    itemReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    itemCodeableConcept?: CodeableConcept

  }
  export class ClinicalUseDefinitionInteractionDto implements ClinicalUseDefinitionInteraction {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    effect?: CodeableReference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    incidence?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ClinicalUseDefinitionInteractionInteractantDto)
    interactant?: ClinicalUseDefinitionInteractionInteractant[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    management?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class ClinicalUseDefinitionUndesirableEffectDto implements ClinicalUseDefinitionUndesirableEffect {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    classification?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    frequencyOfOccurrence?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    symptomConditionEffect?: CodeableReference

  }
  export class ClinicalUseDefinitionWarningDto implements ClinicalUseDefinitionWarning {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsString()
    description?: string

  }
  export class ClinicalUseDefinitionDto implements ClinicalUseDefinition {
    @IsNotEmpty()
    @IsIn(["ClinicalUseDefinition"])
    resourceType: "ClinicalUseDefinition"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ClinicalUseDefinitionContraindicationDto)
    contraindication?: ClinicalUseDefinitionContraindication

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ClinicalUseDefinitionIndicationDto)
    indication?: ClinicalUseDefinitionIndication

    @IsOptional()
    @ValidateNested()
    @Type(() => ClinicalUseDefinitionInteractionDto)
    interaction?: ClinicalUseDefinitionInteraction

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    population?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    status?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    subject?: Reference[]

    @IsNotEmpty()
    @IsIn(["warning", "indication", "contraindication", "interaction", "undesirable-effect"])
    type: "warning" | "indication" | "contraindication" | "interaction" | "undesirable-effect"

    @IsOptional()
    @ValidateNested()
    @Type(() => ClinicalUseDefinitionUndesirableEffectDto)
    undesirableEffect?: ClinicalUseDefinitionUndesirableEffect

    @IsOptional()
    @ValidateNested()
    @Type(() => ClinicalUseDefinitionWarningDto)
    warning?: ClinicalUseDefinitionWarning

  }
  export class CodeSystemFilterDto implements CodeSystemFilter {
    @IsNotEmpty()
    @IsString()
    code: string

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsArray()
    @IsIn(["exists", "in", "=", "is-a", "descendent-of", "is-not-a", "regex", "not-in", "generalizes"], { each: true })
    operator: ("exists" | "in" | "=" | "is-a" | "descendent-of" | "is-not-a" | "regex" | "not-in" | "generalizes")[]

    @IsNotEmpty()
    @IsString()
    value: string

  }
  export class CodeSystemPropertyDto implements CodeSystemProperty {
    @IsNotEmpty()
    @IsString()
    code: string

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsIn(["string", "boolean", "code", "Coding", "integer", "dateTime", "decimal"])
    type: "string" | "boolean" | "code" | "Coding" | "integer" | "dateTime" | "decimal"

    @IsOptional()
    @IsString()
    uri?: string

  }
  export class CodeSystemConceptDesignationDto implements CodeSystemConceptDesignation {
    @IsOptional()
    @IsString()
    language?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    use?: Coding

    @IsNotEmpty()
    @IsString()
    value: string

  }
  export class CodeSystemConceptPropertyDto implements CodeSystemConceptProperty {
    @IsNotEmpty()
    @IsString()
    code: string

    @IsOptional()
    @IsString()
    valueCode?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    valueCoding?: Coding

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsString()
    valueDateTime?: string

    @IsOptional()
    @IsNumber()
    valueDecimal?: number

  }
  export class CodeSystemConceptDto implements CodeSystemConcept {
    @IsNotEmpty()
    @IsString()
    code: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeSystemConceptDto)
    concept?: CodeSystemConcept[]

    @IsOptional()
    @IsString()
    definition?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeSystemConceptDesignationDto)
    designation?: CodeSystemConceptDesignation[]

    @IsOptional()
    @IsString()
    display?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeSystemConceptPropertyDto)
    property?: CodeSystemConceptProperty[]

  }
  export class CodeSystemDto implements CodeSystem {
    @IsNotEmpty()
    @IsIn(["CodeSystem"])
    resourceType: "CodeSystem"

    @IsNotEmpty()
    @IsBoolean()
    caseSensitive: boolean

    @IsNotEmpty()
    @IsBoolean()
    compositional: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeSystemConceptDto)
    concept?: CodeSystemConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsNotEmpty()
    @IsIn(["example", "complete", "not-present", "fragment", "supplement"])
    content: "example" | "complete" | "not-present" | "fragment" | "supplement"

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsNumber()
    count?: number

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeSystemFilterDto)
    filter?: CodeSystemFilter[]

    @IsNotEmpty()
    @IsIn(["is-a", "grouped-by", "part-of", "classified-with"])
    hierarchyMeaning: "is-a" | "grouped-by" | "part-of" | "classified-with"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeSystemPropertyDto)
    property?: CodeSystemProperty[]

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsNotEmpty()
    @IsIn(["active", "unknown", "draft", "retired"])
    status: "active" | "unknown" | "draft" | "retired"

    @IsOptional()
    @IsString()
    supplements?: string

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    valueSet?: string

    @IsOptional()
    @IsString()
    version?: string

    @IsNotEmpty()
    @IsBoolean()
    versionNeeded: boolean

  }
  export class CommunicationPayloadDto implements CommunicationPayload {
    @IsOptional()
    @IsString()
    contentString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    contentAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    contentReference?: Reference

  }
  export class CommunicationDto implements Communication {
    @IsNotEmpty()
    @IsIn(["Communication"])
    resourceType: "Communication"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    about?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    inResponseTo?: Reference[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesCanonical?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesUri?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    medium?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    partOf?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CommunicationPayloadDto)
    payload?: CommunicationPayload[]

    @IsNotEmpty()
    @IsIn(["routine", "urgent", "asap", "stat"])
    priority: "routine" | "urgent" | "asap" | "stat"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    reasonCode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    reasonReference?: Reference[]

    @IsOptional()
    @IsString()
    received?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    recipient?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    sender?: Reference

    @IsOptional()
    @IsString()
    sent?: string

    @IsNotEmpty()
    @IsIn(["entered-in-error", "on-hold", "unknown", "in-progress", "completed", "stopped", "preparation", "not-done"])
    status: "entered-in-error" | "on-hold" | "unknown" | "in-progress" | "completed" | "stopped" | "preparation" | "not-done"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    statusReason?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    topic?: CodeableConcept

  }
  export class CommunicationRequestPayloadDto implements CommunicationRequestPayload {
    @IsOptional()
    @IsString()
    contentString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    contentAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    contentReference?: Reference

  }
  export class CommunicationRequestDto implements CommunicationRequest {
    @IsNotEmpty()
    @IsIn(["CommunicationRequest"])
    resourceType: "CommunicationRequest"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    about?: Reference[]

    @IsOptional()
    @IsString()
    authoredOn?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsNotEmpty()
    @IsBoolean()
    doNotPerform: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    groupIdentifier?: Identifier

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    medium?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    occurrenceDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    occurrencePeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CommunicationRequestPayloadDto)
    payload?: CommunicationRequestPayload[]

    @IsNotEmpty()
    @IsIn(["routine", "urgent", "asap", "stat"])
    priority: "routine" | "urgent" | "asap" | "stat"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    reasonCode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    reasonReference?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    recipient?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    replaces?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    requester?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    sender?: Reference

    @IsNotEmpty()
    @IsIn(["active", "entered-in-error", "on-hold", "unknown", "draft", "completed", "revoked"])
    status: "active" | "entered-in-error" | "on-hold" | "unknown" | "draft" | "completed" | "revoked"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    statusReason?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

  }
  export class CompartmentDefinitionResourceDto implements CompartmentDefinitionResource {
    @IsNotEmpty()
    @IsString()
    code: string

    @IsOptional()
    @IsString()
    documentation?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    param?: string[]

  }
  export class CompartmentDefinitionDto implements CompartmentDefinition {
    @IsNotEmpty()
    @IsIn(["CompartmentDefinition"])
    resourceType: "CompartmentDefinition"

    @IsNotEmpty()
    @IsIn(["Patient", "Encounter", "RelatedPerson", "Practitioner", "Device"])
    code: "Patient" | "Encounter" | "RelatedPerson" | "Practitioner" | "Device"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CompartmentDefinitionResourceDto)
    resource?: CompartmentDefinitionResource[]

    @IsNotEmpty()
    @IsBoolean()
    search: boolean

    @IsNotEmpty()
    @IsIn(["active", "unknown", "draft", "retired"])
    status: "active" | "unknown" | "draft" | "retired"

    @IsNotEmpty()
    @IsString()
    url: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

  }
  export class CompositionAttesterDto implements CompositionAttester {
    @IsNotEmpty()
    @IsIn(["official", "personal", "professional", "legal"])
    mode: "official" | "personal" | "professional" | "legal"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    party?: Reference

    @IsOptional()
    @IsString()
    time?: string

  }
  export class CompositionRelatesToDto implements CompositionRelatesTo {
    @IsNotEmpty()
    @IsIn(["replaces", "transforms", "signs", "appends"])
    code: "replaces" | "transforms" | "signs" | "appends"

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    targetIdentifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    targetReference?: Reference

  }
  export class CompositionEventDto implements CompositionEvent {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    detail?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

  }
  export class CompositionSectionDto implements CompositionSection {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    author?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    emptyReason?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    entry?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    focus?: Reference

    @IsNotEmpty()
    @IsIn(["working", "snapshot", "changes"])
    mode: "working" | "snapshot" | "changes"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    orderedBy?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CompositionSectionDto)
    section?: CompositionSection[]

    @IsOptional()
    @ValidateNested()
    @Type(() => NarrativeDto)
    text?: Narrative

    @IsOptional()
    @IsString()
    title?: string

  }
  export class CompositionDto implements Composition {
    @IsNotEmpty()
    @IsIn(["Composition"])
    resourceType: "Composition"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CompositionAttesterDto)
    attester?: CompositionAttester[]

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    author: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsOptional()
    @IsString()
    confidentiality?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    custodian?: Reference

    @IsNotEmpty()
    @IsString()
    date: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CompositionEventDto)
    event?: CompositionEvent[]

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CompositionRelatesToDto)
    relatesTo?: CompositionRelatesTo[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CompositionSectionDto)
    section?: CompositionSection[]

    @IsNotEmpty()
    @IsIn(["entered-in-error", "preliminary", "final", "amended"])
    status: "entered-in-error" | "preliminary" | "final" | "amended"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

    @IsNotEmpty()
    @IsString()
    title: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class ConceptMapGroupElementTargetDependsOnDto implements ConceptMapGroupElementTargetDependsOn {
    @IsOptional()
    @IsString()
    display?: string

    @IsNotEmpty()
    @IsString()
    property: string

    @IsOptional()
    @IsString()
    system?: string

    @IsNotEmpty()
    @IsString()
    value: string

  }
  export class ConceptMapGroupElementTargetDto implements ConceptMapGroupElementTarget {
    @IsOptional()
    @IsString()
    code?: string

    @IsOptional()
    @IsString()
    comment?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ConceptMapGroupElementTargetDependsOnDto)
    dependsOn?: ConceptMapGroupElementTargetDependsOn[]

    @IsOptional()
    @IsString()
    display?: string

    @IsNotEmpty()
    @IsIn(["relatedto", "equivalent", "equal", "wider", "subsumes", "narrower", "specializes", "inexact", "unmatched", "disjoint"])
    equivalence: "relatedto" | "equivalent" | "equal" | "wider" | "subsumes" | "narrower" | "specializes" | "inexact" | "unmatched" | "disjoint"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ConceptMapGroupElementTargetDependsOnDto)
    product?: ConceptMapGroupElementTargetDependsOn[]

  }
  export class ConceptMapGroupElementDto implements ConceptMapGroupElement {
    @IsOptional()
    @IsString()
    code?: string

    @IsOptional()
    @IsString()
    display?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ConceptMapGroupElementTargetDto)
    target?: ConceptMapGroupElementTarget[]

  }
  export class ConceptMapGroupUnmappedDto implements ConceptMapGroupUnmapped {
    @IsOptional()
    @IsString()
    code?: string

    @IsOptional()
    @IsString()
    display?: string

    @IsNotEmpty()
    @IsIn(["provided", "fixed", "other-map"])
    mode: "provided" | "fixed" | "other-map"

    @IsOptional()
    @IsString()
    url?: string

  }
  export class ConceptMapGroupDto implements ConceptMapGroup {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ConceptMapGroupElementDto)
    element: ConceptMapGroupElement[]

    @IsOptional()
    @IsString()
    source?: string

    @IsOptional()
    @IsString()
    sourceVersion?: string

    @IsOptional()
    @IsString()
    target?: string

    @IsOptional()
    @IsString()
    targetVersion?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ConceptMapGroupUnmappedDto)
    unmapped?: ConceptMapGroupUnmapped

  }
  export class ConceptMapDto implements ConceptMap {
    @IsNotEmpty()
    @IsIn(["ConceptMap"])
    resourceType: "ConceptMap"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ConceptMapGroupDto)
    group?: ConceptMapGroup[]

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @IsString()
    sourceUri?: string

    @IsOptional()
    @IsString()
    sourceCanonical?: string

    @IsNotEmpty()
    @IsIn(["active", "unknown", "draft", "retired"])
    status: "active" | "unknown" | "draft" | "retired"

    @IsOptional()
    @IsString()
    targetUri?: string

    @IsOptional()
    @IsString()
    targetCanonical?: string

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

  }
  export class ConditionStageDto implements ConditionStage {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    assessment?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    summary?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class ConditionEvidenceDto implements ConditionEvidence {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    detail?: Reference[]

  }
  export class ConditionDto implements Condition {
    @IsNotEmpty()
    @IsIn(["Condition"])
    resourceType: "Condition"

    @IsOptional()
    @IsString()
    abatementDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    abatementAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    abatementPeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    abatementRange?: Range

    @IsOptional()
    @IsString()
    abatementString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    asserter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    bodySite?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    clinicalStatus?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ConditionEvidenceDto)
    evidence?: ConditionEvidence[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    onsetDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    onsetAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    onsetPeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    onsetRange?: Range

    @IsOptional()
    @IsString()
    onsetString?: string

    @IsOptional()
    @IsString()
    recordedDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    recorder?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    severity?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ConditionStageDto)
    stage?: ConditionStage[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    verificationStatus?: CodeableConcept

  }
  export class ConsentPolicyDto implements ConsentPolicy {
    @IsOptional()
    @IsString()
    authority?: string

    @IsOptional()
    @IsString()
    uri?: string

  }
  export class ConsentVerificationDto implements ConsentVerification {
    @IsOptional()
    @IsString()
    verificationDate?: string

    @IsNotEmpty()
    @IsBoolean()
    verified: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    verifiedWith?: Reference

  }
  export class ConsentProvisionActorDto implements ConsentProvisionActor {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    reference: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    role: CodeableConcept

  }
  export class ConsentProvisionDataDto implements ConsentProvisionData {
    @IsNotEmpty()
    @IsIn(["instance", "related", "dependents", "authoredby"])
    meaning: "instance" | "related" | "dependents" | "authoredby"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    reference: Reference

  }
  export class ConsentProvisionDto implements ConsentProvision {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    action?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ConsentProvisionActorDto)
    actor?: ConsentProvisionActor[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    class?: Coding[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ConsentProvisionDataDto)
    data?: ConsentProvisionData[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    dataPeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ConsentProvisionDto)
    provision?: ConsentProvision[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    purpose?: Coding[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    securityLabel?: Coding[]

    @IsNotEmpty()
    @IsIn(["deny", "permit"])
    type: "deny" | "permit"

  }
  export class ConsentDto implements Consent {
    @IsNotEmpty()
    @IsIn(["Consent"])
    resourceType: "Consent"

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category: CodeableConcept[]

    @IsOptional()
    @IsString()
    dateTime?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    organization?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    performer?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ConsentPolicyDto)
    policy?: ConsentPolicy[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    policyRule?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ConsentProvisionDto)
    provision?: ConsentProvision

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    scope: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    sourceAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    sourceReference?: Reference

    @IsNotEmpty()
    @IsIn(["active", "inactive", "entered-in-error", "draft", "proposed", "rejected"])
    status: "active" | "inactive" | "entered-in-error" | "draft" | "proposed" | "rejected"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ConsentVerificationDto)
    verification?: ConsentVerification[]

  }
  export class ContractContentDefinitionDto implements ContractContentDefinition {
    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    publicationDate?: string

    @IsNotEmpty()
    @IsIn(["entered-in-error", "cancelled", "revoked", "amended", "rejected", "appended", "disputed", "executable", "executed", "negotiable", "offered", "policy", "renewed", "resolved", "terminated"])
    publicationStatus: "entered-in-error" | "cancelled" | "revoked" | "amended" | "rejected" | "appended" | "disputed" | "executable" | "executed" | "negotiable" | "offered" | "policy" | "renewed" | "resolved" | "terminated"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    publisher?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    subType?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class ContractTermSecurityLabelDto implements ContractTermSecurityLabel {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    category?: Coding[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodingDto)
    classification: Coding

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    control?: Coding[]

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    number?: number[]

  }
  export class ContractTermOfferPartyDto implements ContractTermOfferParty {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    reference: Reference[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    role: CodeableConcept

  }
  export class ContractTermOfferAnswerDto implements ContractTermOfferAnswer {
    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsNumber()
    valueDecimal?: number

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsOptional()
    @IsString()
    valueDate?: string

    @IsOptional()
    @IsString()
    valueDateTime?: string

    @IsOptional()
    @IsString()
    valueTime?: string

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @IsString()
    valueUri?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    valueCoding?: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

  }
  export class ContractTermOfferDto implements ContractTermOffer {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContractTermOfferAnswerDto)
    answer?: ContractTermOfferAnswer[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    decision?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    decisionMode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    linkId?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContractTermOfferPartyDto)
    party?: ContractTermOfferParty[]

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    securityLabelNumber?: number[]

    @IsOptional()
    @IsString()
    text?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    topic?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class ContractTermAssetContextDto implements ContractTermAssetContext {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    reference?: Reference

    @IsOptional()
    @IsString()
    text?: string

  }
  export class ContractTermAssetValuedItemDto implements ContractTermAssetValuedItem {
    @IsOptional()
    @IsString()
    effectiveTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    entityCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    entityReference?: Reference

    @IsOptional()
    @IsNumber()
    factor?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    linkId?: string[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    net?: Money

    @IsOptional()
    @IsString()
    payment?: string

    @IsOptional()
    @IsString()
    paymentDate?: string

    @IsOptional()
    @IsNumber()
    points?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    recipient?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    responsible?: Reference

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    securityLabelNumber?: number[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    unitPrice?: Money

  }
  export class ContractTermAssetDto implements ContractTermAsset {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContractTermOfferAnswerDto)
    answer?: ContractTermOfferAnswer[]

    @IsOptional()
    @IsString()
    condition?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContractTermAssetContextDto)
    context?: ContractTermAssetContext[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    linkId?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PeriodDto)
    period?: Period[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    periodType?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    relationship?: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    scope?: CodeableConcept

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    securityLabelNumber?: number[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    subtype?: CodeableConcept[]

    @IsOptional()
    @IsString()
    text?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    typeReference?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PeriodDto)
    usePeriod?: Period[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContractTermAssetValuedItemDto)
    valuedItem?: ContractTermAssetValuedItem[]

  }
  export class ContractTermActionSubjectDto implements ContractTermActionSubject {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    reference: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    role?: CodeableConcept

  }
  export class ContractTermActionDto implements ContractTermAction {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    context?: Reference

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    contextLinkId?: string[]

    @IsNotEmpty()
    @IsBoolean()
    doNotPerform: boolean

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    intent: CodeableConcept

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    linkId?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    occurrenceDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    occurrencePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    occurrenceTiming?: Timing

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    performer?: Reference

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    performerLinkId?: string[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    performerRole?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    performerType?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    reason?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    reasonCode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    reasonLinkId?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    reasonReference?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    requester?: Reference[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    requesterLinkId?: string[]

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    securityLabelNumber?: number[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    status: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContractTermActionSubjectDto)
    subject?: ContractTermActionSubject[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class ContractTermDto implements ContractTerm {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContractTermActionDto)
    action?: ContractTermAction[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    applies?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContractTermAssetDto)
    asset?: ContractTermAsset[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContractTermDto)
    group?: ContractTerm[]

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsOptional()
    @IsString()
    issued?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ContractTermOfferDto)
    offer: ContractTermOffer

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContractTermSecurityLabelDto)
    securityLabel?: ContractTermSecurityLabel[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    subType?: CodeableConcept

    @IsOptional()
    @IsString()
    text?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    topicCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    topicReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class ContractSignerDto implements ContractSigner {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    party: Reference

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SignatureDto)
    signature: Signature[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodingDto)
    type: Coding

  }
  export class ContractFriendlyDto implements ContractFriendly {
    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    contentAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    contentReference?: Reference

  }
  export class ContractLegalDto implements ContractLegal {
    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    contentAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    contentReference?: Reference

  }
  export class ContractRuleDto implements ContractRule {
    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    contentAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    contentReference?: Reference

  }
  export class ContractDto implements Contract {
    @IsNotEmpty()
    @IsIn(["Contract"])
    resourceType: "Contract"

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    alias?: string[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    applies?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    author?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    authority?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ContractContentDefinitionDto)
    contentDefinition?: ContractContentDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    contentDerivative?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    domain?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    expirationType?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContractFriendlyDto)
    friendly?: ContractFriendly[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    instantiatesCanonical?: Reference

    @IsOptional()
    @IsString()
    instantiatesUri?: string

    @IsOptional()
    @IsString()
    issued?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContractLegalDto)
    legal?: ContractLegal[]

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    legallyBindingAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    legallyBindingReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    legalState?: CodeableConcept

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    relevantHistory?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContractRuleDto)
    rule?: ContractRule[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    scope?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContractSignerDto)
    signer?: ContractSigner[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    site?: Reference[]

    @IsNotEmpty()
    @IsIn(["entered-in-error", "cancelled", "revoked", "amended", "rejected", "appended", "disputed", "executable", "executed", "negotiable", "offered", "policy", "renewed", "resolved", "terminated"])
    status: "entered-in-error" | "cancelled" | "revoked" | "amended" | "rejected" | "appended" | "disputed" | "executable" | "executed" | "negotiable" | "offered" | "policy" | "renewed" | "resolved" | "terminated"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    subject?: Reference[]

    @IsOptional()
    @IsString()
    subtitle?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    subType?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    supportingInfo?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContractTermDto)
    term?: ContractTerm[]

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    topicCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    topicReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsString()
    version?: string

  }
  export class CoverageClassDto implements CoverageClass {
    @IsOptional()
    @IsString()
    name?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsNotEmpty()
    @IsString()
    value: string

  }
  export class CoverageCostToBeneficiaryExceptionDto implements CoverageCostToBeneficiaryException {
    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class CoverageCostToBeneficiaryDto implements CoverageCostToBeneficiary {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CoverageCostToBeneficiaryExceptionDto)
    exception?: CoverageCostToBeneficiaryException[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    valueMoney?: Money

  }
  export class CoverageDto implements Coverage {
    @IsNotEmpty()
    @IsIn(["Coverage"])
    resourceType: "Coverage"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    beneficiary: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CoverageClassDto)
    class?: CoverageClass[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    contract?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CoverageCostToBeneficiaryDto)
    costToBeneficiary?: CoverageCostToBeneficiary[]

    @IsOptional()
    @IsString()
    dependent?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsString()
    network?: string

    @IsOptional()
    @IsNumber()
    order?: number

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    payor: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    policyHolder?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    relationship?: CodeableConcept

    @IsNotEmpty()
    @IsIn(["active", "entered-in-error", "draft", "cancelled"])
    status: "active" | "entered-in-error" | "draft" | "cancelled"

    @IsNotEmpty()
    @IsBoolean()
    subrogation: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subscriber?: Reference

    @IsOptional()
    @IsString()
    subscriberId?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class CoverageEligibilityRequestSupportingInfoDto implements CoverageEligibilityRequestSupportingInfo {
    @IsNotEmpty()
    @IsBoolean()
    appliesToAll: boolean

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    information: Reference

    @IsNotEmpty()
    @IsNumber()
    sequence: number

  }
  export class CoverageEligibilityRequestInsuranceDto implements CoverageEligibilityRequestInsurance {
    @IsOptional()
    @IsString()
    businessArrangement?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    coverage: Reference

    @IsNotEmpty()
    @IsBoolean()
    focal: boolean

  }
  export class CoverageEligibilityRequestItemDiagnosisDto implements CoverageEligibilityRequestItemDiagnosis {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    diagnosisCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    diagnosisReference?: Reference

  }
  export class CoverageEligibilityRequestItemDto implements CoverageEligibilityRequestItem {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    detail?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CoverageEligibilityRequestItemDiagnosisDto)
    diagnosis?: CoverageEligibilityRequestItemDiagnosis[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    facility?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    modifier?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrService?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    provider?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    supportingInfoSequence?: number[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    unitPrice?: Money

  }
  export class CoverageEligibilityRequestDto implements CoverageEligibilityRequest {
    @IsNotEmpty()
    @IsIn(["CoverageEligibilityRequest"])
    resourceType: "CoverageEligibilityRequest"

    @IsNotEmpty()
    @IsString()
    created: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    enterer?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    facility?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CoverageEligibilityRequestInsuranceDto)
    insurance?: CoverageEligibilityRequestInsurance[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    insurer: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CoverageEligibilityRequestItemDto)
    item?: CoverageEligibilityRequestItem[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    priority?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    provider?: Reference

    @IsNotEmpty()
    @IsArray()
    @IsIn(["auth-requirements", "benefits", "discovery", "validation"], { each: true })
    purpose: ("auth-requirements" | "benefits" | "discovery" | "validation")[]

    @IsOptional()
    @IsString()
    servicedDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    servicedPeriod?: Period

    @IsNotEmpty()
    @IsIn(["active", "entered-in-error", "draft", "cancelled"])
    status: "active" | "entered-in-error" | "draft" | "cancelled"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CoverageEligibilityRequestSupportingInfoDto)
    supportingInfo?: CoverageEligibilityRequestSupportingInfo[]

  }
  export class CoverageEligibilityResponseInsuranceItemBenefitDto implements CoverageEligibilityResponseInsuranceItemBenefit {
    @IsOptional()
    @IsNumber()
    allowedUnsignedInt?: number

    @IsOptional()
    @IsString()
    allowedString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    allowedMoney?: Money

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @IsNumber()
    usedUnsignedInt?: number

    @IsOptional()
    @IsString()
    usedString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    usedMoney?: Money

  }
  export class CoverageEligibilityResponseInsuranceItemDto implements CoverageEligibilityResponseInsuranceItem {
    @IsNotEmpty()
    @IsBoolean()
    authorizationRequired: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    authorizationSupporting?: CodeableConcept[]

    @IsOptional()
    @IsString()
    authorizationUrl?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CoverageEligibilityResponseInsuranceItemBenefitDto)
    benefit?: CoverageEligibilityResponseInsuranceItemBenefit[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsBoolean()
    excluded: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    modifier?: CodeableConcept[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    network?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrService?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    provider?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    term?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    unit?: CodeableConcept

  }
  export class CoverageEligibilityResponseInsuranceDto implements CoverageEligibilityResponseInsurance {
    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    benefitPeriod?: Period

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    coverage: Reference

    @IsNotEmpty()
    @IsBoolean()
    inforce: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CoverageEligibilityResponseInsuranceItemDto)
    item?: CoverageEligibilityResponseInsuranceItem[]

  }
  export class CoverageEligibilityResponseErrorDto implements CoverageEligibilityResponseError {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

  }
  export class CoverageEligibilityResponseDto implements CoverageEligibilityResponse {
    @IsNotEmpty()
    @IsIn(["CoverageEligibilityResponse"])
    resourceType: "CoverageEligibilityResponse"

    @IsNotEmpty()
    @IsString()
    created: string

    @IsOptional()
    @IsString()
    disposition?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CoverageEligibilityResponseErrorDto)
    error?: CoverageEligibilityResponseError[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    form?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CoverageEligibilityResponseInsuranceDto)
    insurance?: CoverageEligibilityResponseInsurance[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    insurer: Reference

    @IsNotEmpty()
    @IsIn(["error", "queued", "complete", "partial"])
    outcome: "error" | "queued" | "complete" | "partial"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient: Reference

    @IsOptional()
    @IsString()
    preAuthRef?: string

    @IsNotEmpty()
    @IsArray()
    @IsIn(["auth-requirements", "benefits", "discovery", "validation"], { each: true })
    purpose: ("auth-requirements" | "benefits" | "discovery" | "validation")[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    request: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    requestor?: Reference

    @IsOptional()
    @IsString()
    servicedDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    servicedPeriod?: Period

    @IsNotEmpty()
    @IsIn(["active", "entered-in-error", "draft", "cancelled"])
    status: "active" | "entered-in-error" | "draft" | "cancelled"

  }
  export class DetectedIssueEvidenceDto implements DetectedIssueEvidence {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    detail?: Reference[]

  }
  export class DetectedIssueMitigationDto implements DetectedIssueMitigation {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    action: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    author?: Reference

    @IsOptional()
    @IsString()
    date?: string

  }
  export class DetectedIssueDto implements DetectedIssue {
    @IsNotEmpty()
    @IsIn(["DetectedIssue"])
    resourceType: "DetectedIssue"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    author?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsString()
    detail?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DetectedIssueEvidenceDto)
    evidence?: DetectedIssueEvidence[]

    @IsOptional()
    @IsString()
    identifiedDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    identifiedPeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    implicated?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DetectedIssueMitigationDto)
    mitigation?: DetectedIssueMitigation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient?: Reference

    @IsOptional()
    @IsString()
    reference?: string

    @IsNotEmpty()
    @IsIn(["moderate", "low", "high"])
    severity: "moderate" | "low" | "high"

    @IsNotEmpty()
    @IsIn(["entered-in-error", "unknown", "cancelled", "preliminary", "final", "amended", "registered", "corrected"])
    status: "entered-in-error" | "unknown" | "cancelled" | "preliminary" | "final" | "amended" | "registered" | "corrected"

  }
  export class DeviceUdiCarrierDto implements DeviceUdiCarrier {
    @IsOptional()
    @IsString()
    carrierAIDC?: string

    @IsOptional()
    @IsString()
    carrierHRF?: string

    @IsOptional()
    @IsString()
    deviceIdentifier?: string

    @IsNotEmpty()
    @IsIn(["unknown", "barcode", "rfid", "manual", "card", "self-reported"])
    entryType: "unknown" | "barcode" | "rfid" | "manual" | "card" | "self-reported"

    @IsOptional()
    @IsString()
    issuer?: string

    @IsOptional()
    @IsString()
    jurisdiction?: string

  }
  export class DeviceDeviceNameDto implements DeviceDeviceName {
    @IsNotEmpty()
    @IsString()
    name: string

    @IsNotEmpty()
    @IsIn(["other", "udi-label-name", "user-friendly-name", "patient-reported-name", "manufacturer-name", "model-name"])
    type: "other" | "udi-label-name" | "user-friendly-name" | "patient-reported-name" | "manufacturer-name" | "model-name"

  }
  export class DeviceSpecializationDto implements DeviceSpecialization {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    systemType: CodeableConcept

    @IsOptional()
    @IsString()
    version?: string

  }
  export class DeviceVersionDto implements DeviceVersion {
    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    component?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsNotEmpty()
    @IsString()
    value: string

  }
  export class DevicePropertyDto implements DeviceProperty {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    valueCode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => QuantityDto)
    valueQuantity?: Quantity[]

  }
  export class DeviceDto implements Device {
    @IsNotEmpty()
    @IsIn(["Device"])
    resourceType: "Device"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactPointDto)
    contact?: ContactPoint[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    definition?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DeviceDeviceNameDto)
    deviceName?: DeviceDeviceName[]

    @IsOptional()
    @IsString()
    distinctIdentifier?: string

    @IsOptional()
    @IsString()
    expirationDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    location?: Reference

    @IsOptional()
    @IsString()
    lotNumber?: string

    @IsOptional()
    @IsString()
    manufactureDate?: string

    @IsOptional()
    @IsString()
    manufacturer?: string

    @IsOptional()
    @IsString()
    modelNumber?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    owner?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    parent?: Reference

    @IsOptional()
    @IsString()
    partNumber?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DevicePropertyDto)
    property?: DeviceProperty[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    safety?: CodeableConcept[]

    @IsOptional()
    @IsString()
    serialNumber?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DeviceSpecializationDto)
    specialization?: DeviceSpecialization[]

    @IsNotEmpty()
    @IsIn(["active", "inactive", "entered-in-error", "unknown"])
    status: "active" | "inactive" | "entered-in-error" | "unknown"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    statusReason?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DeviceUdiCarrierDto)
    udiCarrier?: DeviceUdiCarrier[]

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DeviceVersionDto)
    version?: DeviceVersion[]

  }
  export class DeviceDefinitionUdiDeviceIdentifierDto implements DeviceDefinitionUdiDeviceIdentifier {
    @IsNotEmpty()
    @IsString()
    deviceIdentifier: string

    @IsNotEmpty()
    @IsString()
    issuer: string

    @IsNotEmpty()
    @IsString()
    jurisdiction: string

  }
  export class DeviceDefinitionDeviceNameDto implements DeviceDefinitionDeviceName {
    @IsNotEmpty()
    @IsString()
    name: string

    @IsNotEmpty()
    @IsIn(["other", "udi-label-name", "user-friendly-name", "patient-reported-name", "manufacturer-name", "model-name"])
    type: "other" | "udi-label-name" | "user-friendly-name" | "patient-reported-name" | "manufacturer-name" | "model-name"

  }
  export class DeviceDefinitionSpecializationDto implements DeviceDefinitionSpecialization {
    @IsNotEmpty()
    @IsString()
    systemType: string

    @IsOptional()
    @IsString()
    version?: string

  }
  export class DeviceDefinitionCapabilityDto implements DeviceDefinitionCapability {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    description?: CodeableConcept[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class DeviceDefinitionPropertyDto implements DeviceDefinitionProperty {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    valueCode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => QuantityDto)
    valueQuantity?: Quantity[]

  }
  export class DeviceDefinitionMaterialDto implements DeviceDefinitionMaterial {
    @IsNotEmpty()
    @IsBoolean()
    allergenicIndicator: boolean

    @IsNotEmpty()
    @IsBoolean()
    alternate: boolean

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    substance: CodeableConcept

  }
  export class DeviceDefinitionDto implements DeviceDefinition {
    @IsNotEmpty()
    @IsIn(["DeviceDefinition"])
    resourceType: "DeviceDefinition"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DeviceDefinitionCapabilityDto)
    capability?: DeviceDefinitionCapability[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactPointDto)
    contact?: ContactPoint[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DeviceDefinitionDeviceNameDto)
    deviceName?: DeviceDefinitionDeviceName[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    languageCode?: CodeableConcept[]

    @IsOptional()
    @IsString()
    manufacturerString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    manufacturerReference?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DeviceDefinitionMaterialDto)
    material?: DeviceDefinitionMaterial[]

    @IsOptional()
    @IsString()
    modelNumber?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    onlineInformation?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    owner?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    parentDevice?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ProdCharacteristicDto)
    physicalCharacteristics?: ProdCharacteristic

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DeviceDefinitionPropertyDto)
    property?: DeviceDefinitionProperty[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    safety?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ProductShelfLifeDto)
    shelfLifeStorage?: ProductShelfLife[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DeviceDefinitionSpecializationDto)
    specialization?: DeviceDefinitionSpecialization[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DeviceDefinitionUdiDeviceIdentifierDto)
    udiDeviceIdentifier?: DeviceDefinitionUdiDeviceIdentifier[]

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    version?: string[]

  }
  export class DeviceMetricCalibrationDto implements DeviceMetricCalibration {
    @IsNotEmpty()
    @IsIn(["not-calibrated", "calibration-required", "calibrated", "unspecified"])
    state: "not-calibrated" | "calibration-required" | "calibrated" | "unspecified"

    @IsOptional()
    @IsString()
    time?: string

    @IsNotEmpty()
    @IsIn(["unspecified", "offset", "gain", "two-point"])
    type: "unspecified" | "offset" | "gain" | "two-point"

  }
  export class DeviceMetricDto implements DeviceMetric {
    @IsNotEmpty()
    @IsIn(["DeviceMetric"])
    resourceType: "DeviceMetric"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DeviceMetricCalibrationDto)
    calibration?: DeviceMetricCalibration[]

    @IsNotEmpty()
    @IsIn(["unspecified", "measurement", "setting", "calculation"])
    category: "unspecified" | "measurement" | "setting" | "calculation"

    @IsNotEmpty()
    @IsIn(["black", "red", "green", "yellow", "blue", "magenta", "cyan", "white"])
    color: "black" | "red" | "green" | "yellow" | "blue" | "magenta" | "cyan" | "white"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    measurementPeriod?: Timing

    @IsNotEmpty()
    @IsIn(["entered-in-error", "on", "off", "standby"])
    operationalStatus: "entered-in-error" | "on" | "off" | "standby"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    parent?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    source?: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    unit?: CodeableConcept

  }
  export class DeviceRequestParameterDto implements DeviceRequestParameter {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

  }
  export class DeviceRequestDto implements DeviceRequest {
    @IsNotEmpty()
    @IsIn(["DeviceRequest"])
    resourceType: "DeviceRequest"

    @IsOptional()
    @IsString()
    authoredOn?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    codeReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    codeCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    groupIdentifier?: Identifier

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesCanonical?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesUri?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    insurance?: Reference[]

    @IsNotEmpty()
    @IsIn(["proposal", "plan", "directive", "order", "original-order", "reflex-order", "filler-order", "instance-order", "option"])
    intent: "proposal" | "plan" | "directive" | "order" | "original-order" | "reflex-order" | "filler-order" | "instance-order" | "option"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    occurrenceDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    occurrencePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    occurrenceTiming?: Timing

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DeviceRequestParameterDto)
    parameter?: DeviceRequestParameter[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    performer?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    performerType?: CodeableConcept

    @IsNotEmpty()
    @IsIn(["routine", "urgent", "asap", "stat"])
    priority: "routine" | "urgent" | "asap" | "stat"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    priorRequest?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    reasonCode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    reasonReference?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    relevantHistory?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    requester?: Reference

    @IsNotEmpty()
    @IsIn(["active", "entered-in-error", "on-hold", "unknown", "draft", "completed", "revoked"])
    status: "active" | "entered-in-error" | "on-hold" | "unknown" | "draft" | "completed" | "revoked"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    supportingInfo?: Reference[]

  }
  export class DeviceUseStatementDto implements DeviceUseStatement {
    @IsNotEmpty()
    @IsIn(["DeviceUseStatement"])
    resourceType: "DeviceUseStatement"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    bodySite?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    derivedFrom?: Reference[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    device: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    reasonCode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    reasonReference?: Reference[]

    @IsOptional()
    @IsString()
    recordedOn?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    source?: Reference

    @IsNotEmpty()
    @IsIn(["active", "entered-in-error", "on-hold", "completed", "stopped", "intended"])
    status: "active" | "entered-in-error" | "on-hold" | "completed" | "stopped" | "intended"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    timingTiming?: Timing

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    timingPeriod?: Period

    @IsOptional()
    @IsString()
    timingDateTime?: string

  }
  export class DiagnosticReportMediaDto implements DiagnosticReportMedia {
    @IsOptional()
    @IsString()
    comment?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    link: Reference

  }
  export class DiagnosticReportDto implements DiagnosticReport {
    @IsNotEmpty()
    @IsIn(["DiagnosticReport"])
    resourceType: "DiagnosticReport"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsOptional()
    @IsString()
    conclusion?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    conclusionCode?: CodeableConcept[]

    @IsOptional()
    @IsString()
    effectiveDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    imagingStudy?: Reference[]

    @IsOptional()
    @IsString()
    issued?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DiagnosticReportMediaDto)
    media?: DiagnosticReportMedia[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    performer?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AttachmentDto)
    presentedForm?: Attachment[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    result?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    resultsInterpreter?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    specimen?: Reference[]

    @IsNotEmpty()
    @IsIn(["entered-in-error", "unknown", "cancelled", "partial", "preliminary", "final", "amended", "appended", "registered", "corrected"])
    status: "entered-in-error" | "unknown" | "cancelled" | "partial" | "preliminary" | "final" | "amended" | "appended" | "registered" | "corrected"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

  }
  export class DocumentManifestRelatedDto implements DocumentManifestRelated {
    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    ref?: Reference

  }
  export class DocumentManifestDto implements DocumentManifest {
    @IsNotEmpty()
    @IsIn(["DocumentManifest"])
    resourceType: "DocumentManifest"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    author?: Reference[]

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    content: Reference[]

    @IsOptional()
    @IsString()
    created?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    masterIdentifier?: Identifier

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    recipient?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DocumentManifestRelatedDto)
    related?: DocumentManifestRelated[]

    @IsOptional()
    @IsString()
    source?: string

    @IsNotEmpty()
    @IsIn(["entered-in-error", "current", "superseded"])
    status: "entered-in-error" | "current" | "superseded"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class DocumentReferenceRelatesToDto implements DocumentReferenceRelatesTo {
    @IsNotEmpty()
    @IsIn(["replaces", "transforms", "signs", "appends"])
    code: "replaces" | "transforms" | "signs" | "appends"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    target: Reference

  }
  export class DocumentReferenceContentDto implements DocumentReferenceContent {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => AttachmentDto)
    attachment: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    format?: Coding

  }
  export class DocumentReferenceContextDto implements DocumentReferenceContext {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    encounter?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    event?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    facilityType?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    practiceSetting?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    related?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    sourcePatientInfo?: Reference

  }
  export class DocumentReferenceDto implements DocumentReference {
    @IsNotEmpty()
    @IsIn(["DocumentReference"])
    resourceType: "DocumentReference"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    authenticator?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    author?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DocumentReferenceContentDto)
    content: DocumentReferenceContent[]

    @IsOptional()
    @ValidateNested()
    @Type(() => DocumentReferenceContextDto)
    context?: DocumentReferenceContext

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    custodian?: Reference

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsIn(["entered-in-error", "preliminary", "final", "amended"])
    docStatus: "entered-in-error" | "preliminary" | "final" | "amended"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    masterIdentifier?: Identifier

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DocumentReferenceRelatesToDto)
    relatesTo?: DocumentReferenceRelatesTo[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    securityLabel?: CodeableConcept[]

    @IsNotEmpty()
    @IsIn(["entered-in-error", "current", "superseded"])
    status: "entered-in-error" | "current" | "superseded"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class DomainResourceDto implements DomainResource {
    @IsNotEmpty()
    @IsString()
    resourceType: string

    @IsOptional()
    @IsArray()
    contained?: FhirResource[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExtensionDto)
    extension?: Extension[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExtensionDto)
    modifierExtension?: Extension[]

    @IsOptional()
    @ValidateNested()
    @Type(() => NarrativeDto)
    text?: Narrative

  }
  export class EncounterStatusHistoryDto implements EncounterStatusHistory {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => PeriodDto)
    period: Period

    @IsNotEmpty()
    @IsIn(["entered-in-error", "unknown", "arrived", "cancelled", "in-progress", "planned", "triaged", "onleave", "finished"])
    status: "entered-in-error" | "unknown" | "arrived" | "cancelled" | "in-progress" | "planned" | "triaged" | "onleave" | "finished"

  }
  export class EncounterClassHistoryDto implements EncounterClassHistory {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodingDto)
    class: Coding

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => PeriodDto)
    period: Period

  }
  export class EncounterParticipantDto implements EncounterParticipant {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    individual?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

  }
  export class EncounterDiagnosisDto implements EncounterDiagnosis {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    condition: Reference

    @IsOptional()
    @IsNumber()
    rank?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    use?: CodeableConcept

  }
  export class EncounterHospitalizationDto implements EncounterHospitalization {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    admitSource?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    destination?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    dietPreference?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    dischargeDisposition?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    origin?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    preAdmissionIdentifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    reAdmission?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    specialArrangement?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    specialCourtesy?: CodeableConcept[]

  }
  export class EncounterLocationDto implements EncounterLocation {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    location: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    physicalType?: CodeableConcept

    @IsNotEmpty()
    @IsIn(["active", "completed", "planned", "reserved"])
    status: "active" | "completed" | "planned" | "reserved"

  }
  export class EncounterDto implements Encounter {
    @IsNotEmpty()
    @IsIn(["Encounter"])
    resourceType: "Encounter"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    account?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    appointment?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodingDto)
    class: Coding

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EncounterClassHistoryDto)
    classHistory?: EncounterClassHistory[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EncounterDiagnosisDto)
    diagnosis?: EncounterDiagnosis[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    episodeOfCare?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => EncounterHospitalizationDto)
    hospitalization?: EncounterHospitalization

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    length?: Duration

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EncounterLocationDto)
    location?: EncounterLocation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EncounterParticipantDto)
    participant?: EncounterParticipant[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    partOf?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    priority?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    reasonCode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    reasonReference?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    serviceProvider?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    serviceType?: CodeableConcept

    @IsNotEmpty()
    @IsIn(["entered-in-error", "unknown", "arrived", "cancelled", "in-progress", "planned", "triaged", "onleave", "finished"])
    status: "entered-in-error" | "unknown" | "arrived" | "cancelled" | "in-progress" | "planned" | "triaged" | "onleave" | "finished"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EncounterStatusHistoryDto)
    statusHistory?: EncounterStatusHistory[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

  }
  export class EndpointDto implements Endpoint {
    @IsNotEmpty()
    @IsIn(["Endpoint"])
    resourceType: "Endpoint"

    @IsNotEmpty()
    @IsString()
    address: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodingDto)
    connectionType: Coding

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactPointDto)
    contact?: ContactPoint[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    header?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    managingOrganization?: Reference

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    payloadMimeType?: string[]

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    payloadType: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsNotEmpty()
    @IsIn(["error", "active", "entered-in-error", "suspended", "off", "test"])
    status: "error" | "active" | "entered-in-error" | "suspended" | "off" | "test"

  }
  export class EnrollmentRequestDto implements EnrollmentRequest {
    @IsNotEmpty()
    @IsIn(["EnrollmentRequest"])
    resourceType: "EnrollmentRequest"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    candidate?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    coverage?: Reference

    @IsOptional()
    @IsString()
    created?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    insurer?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    provider?: Reference

    @IsNotEmpty()
    @IsIn(["active", "entered-in-error", "draft", "cancelled"])
    status: "active" | "entered-in-error" | "draft" | "cancelled"

  }
  export class EnrollmentResponseDto implements EnrollmentResponse {
    @IsNotEmpty()
    @IsIn(["EnrollmentResponse"])
    resourceType: "EnrollmentResponse"

    @IsOptional()
    @IsString()
    created?: string

    @IsOptional()
    @IsString()
    disposition?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    organization?: Reference

    @IsNotEmpty()
    @IsIn(["error", "queued", "complete", "partial"])
    outcome: "error" | "queued" | "complete" | "partial"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    request?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    requestProvider?: Reference

    @IsNotEmpty()
    @IsIn(["active", "entered-in-error", "draft", "cancelled"])
    status: "active" | "entered-in-error" | "draft" | "cancelled"

  }
  export class EpisodeOfCareStatusHistoryDto implements EpisodeOfCareStatusHistory {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => PeriodDto)
    period: Period

    @IsNotEmpty()
    @IsIn(["active", "entered-in-error", "cancelled", "waitlist", "planned", "finished", "onhold"])
    status: "active" | "entered-in-error" | "cancelled" | "waitlist" | "planned" | "finished" | "onhold"

  }
  export class EpisodeOfCareDiagnosisDto implements EpisodeOfCareDiagnosis {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    condition: Reference

    @IsOptional()
    @IsNumber()
    rank?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    role?: CodeableConcept

  }
  export class EpisodeOfCareDto implements EpisodeOfCare {
    @IsNotEmpty()
    @IsIn(["EpisodeOfCare"])
    resourceType: "EpisodeOfCare"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    account?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    careManager?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EpisodeOfCareDiagnosisDto)
    diagnosis?: EpisodeOfCareDiagnosis[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    managingOrganization?: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    referralRequest?: Reference[]

    @IsNotEmpty()
    @IsIn(["active", "entered-in-error", "cancelled", "waitlist", "planned", "finished", "onhold"])
    status: "active" | "entered-in-error" | "cancelled" | "waitlist" | "planned" | "finished" | "onhold"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EpisodeOfCareStatusHistoryDto)
    statusHistory?: EpisodeOfCareStatusHistory[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    team?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

  }
  export class EventDefinitionDto implements EventDefinition {
    @IsNotEmpty()
    @IsIn(["EventDefinition"])
    resourceType: "EventDefinition"

    @IsOptional()
    @IsString()
    approvalDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    author?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    editor?: ContactDetail[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    endorser?: ContactDetail[]

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    lastReviewDate?: string

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    relatedArtifact?: RelatedArtifact[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    reviewer?: ContactDetail[]

    @IsNotEmpty()
    @IsIn(["active", "unknown", "draft", "retired"])
    status: "active" | "unknown" | "draft" | "retired"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    subjectCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subjectReference?: Reference

    @IsOptional()
    @IsString()
    subtitle?: string

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    topic?: CodeableConcept[]

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TriggerDefinitionDto)
    trigger: TriggerDefinition[]

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsString()
    usage?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

  }
  export class EvidenceVariableDefinitionDto implements EvidenceVariableDefinition {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    directnessMatch?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    intended?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    observed?: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    variableRole: CodeableConcept

  }
  export class EvidenceStatisticSampleSizeDto implements EvidenceStatisticSampleSize {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsNumber()
    knownDataCount?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsNumber()
    numberOfParticipants?: number

    @IsOptional()
    @IsNumber()
    numberOfStudies?: number

  }
  export class EvidenceStatisticAttributeEstimateDto implements EvidenceStatisticAttributeEstimate {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EvidenceStatisticAttributeEstimateDto)
    attributeEstimate?: EvidenceStatisticAttributeEstimate[]

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsNumber()
    level?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    range?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class EvidenceStatisticModelCharacteristicVariableDto implements EvidenceStatisticModelCharacteristicVariable {
    @IsNotEmpty()
    @IsIn(["continuous", "dichotomous", "ordinal", "polychotomous"])
    handling: "continuous" | "dichotomous" | "ordinal" | "polychotomous"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    valueCategory?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => QuantityDto)
    valueQuantity?: Quantity[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RangeDto)
    valueRange?: Range[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    variableDefinition: Reference

  }
  export class EvidenceStatisticModelCharacteristicDto implements EvidenceStatisticModelCharacteristic {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EvidenceStatisticAttributeEstimateDto)
    attributeEstimate?: EvidenceStatisticAttributeEstimate[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    value?: Quantity

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EvidenceStatisticModelCharacteristicVariableDto)
    variable?: EvidenceStatisticModelCharacteristicVariable[]

  }
  export class EvidenceStatisticDto implements EvidenceStatistic {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EvidenceStatisticAttributeEstimateDto)
    attributeEstimate?: EvidenceStatisticAttributeEstimate[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EvidenceStatisticModelCharacteristicDto)
    modelCharacteristic?: EvidenceStatisticModelCharacteristic[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsNumber()
    numberAffected?: number

    @IsOptional()
    @IsNumber()
    numberOfEvents?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => EvidenceStatisticSampleSizeDto)
    sampleSize?: EvidenceStatisticSampleSize

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    statisticType?: CodeableConcept

  }
  export class EvidenceCertaintyDto implements EvidenceCertainty {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    rater?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    rating?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EvidenceCertaintyDto)
    subcomponent?: EvidenceCertainty[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class EvidenceDto implements Evidence {
    @IsNotEmpty()
    @IsIn(["Evidence"])
    resourceType: "Evidence"

    @IsOptional()
    @IsString()
    approvalDate?: string

    @IsOptional()
    @IsString()
    assertion?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    author?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EvidenceCertaintyDto)
    certainty?: EvidenceCertainty[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    citeAsReference?: Reference

    @IsOptional()
    @IsString()
    citeAsMarkdown?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    editor?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    endorser?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsString()
    lastReviewDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    relatedArtifact?: RelatedArtifact[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    reviewer?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EvidenceStatisticDto)
    statistic?: EvidenceStatistic[]

    @IsNotEmpty()
    @IsIn(["active", "unknown", "draft", "retired"])
    status: "active" | "unknown" | "draft" | "retired"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    studyType?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    synthesisType?: CodeableConcept

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EvidenceVariableDefinitionDto)
    variableDefinition: EvidenceVariableDefinition[]

    @IsOptional()
    @IsString()
    version?: string

  }
  export class EvidenceReportSubjectCharacteristicDto implements EvidenceReportSubjectCharacteristic {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    exclude: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

  }
  export class EvidenceReportSubjectDto implements EvidenceReportSubject {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EvidenceReportSubjectCharacteristicDto)
    characteristic?: EvidenceReportSubjectCharacteristic[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

  }
  export class EvidenceReportRelatesToDto implements EvidenceReportRelatesTo {
    @IsNotEmpty()
    @IsIn(["replaces", "transforms", "appends", "amends", "replacedWith", "amendedWith", "appendedWith", "transformedWith"])
    code: "replaces" | "transforms" | "appends" | "amends" | "replacedWith" | "amendedWith" | "appendedWith" | "transformedWith"

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    targetIdentifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    targetReference?: Reference

  }
  export class EvidenceReportSectionDto implements EvidenceReportSection {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    author?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    emptyReason?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    entryClassifier?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => QuantityDto)
    entryQuantity?: Quantity[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    entryReference?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    focus?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    focusReference?: Reference

    @IsNotEmpty()
    @IsIn(["working", "snapshot", "changes"])
    mode: "working" | "snapshot" | "changes"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    orderedBy?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EvidenceReportSectionDto)
    section?: EvidenceReportSection[]

    @IsOptional()
    @ValidateNested()
    @Type(() => NarrativeDto)
    text?: Narrative

    @IsOptional()
    @IsString()
    title?: string

  }
  export class EvidenceReportDto implements EvidenceReport {
    @IsNotEmpty()
    @IsIn(["EvidenceReport"])
    resourceType: "EvidenceReport"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    author?: ContactDetail[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    citeAsReference?: Reference

    @IsOptional()
    @IsString()
    citeAsMarkdown?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    editor?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    endorser?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    relatedArtifact?: RelatedArtifact[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    relatedIdentifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EvidenceReportRelatesToDto)
    relatesTo?: EvidenceReportRelatesTo[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    reviewer?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EvidenceReportSectionDto)
    section?: EvidenceReportSection[]

    @IsNotEmpty()
    @IsIn(["active", "unknown", "draft", "retired"])
    status: "active" | "unknown" | "draft" | "retired"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => EvidenceReportSubjectDto)
    subject: EvidenceReportSubject

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

  }
  export class EvidenceVariableCharacteristicTimeFromStartDto implements EvidenceVariableCharacteristicTimeFromStart {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    range?: Range

  }
  export class EvidenceVariableCharacteristicDto implements EvidenceVariableCharacteristic {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    definitionReference?: Reference

    @IsOptional()
    @IsString()
    definitionCanonical?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    definitionCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    definitionExpression?: Expression

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    device?: Reference

    @IsNotEmpty()
    @IsBoolean()
    exclude: boolean

    @IsNotEmpty()
    @IsIn(["mean", "median", "mean-of-mean", "mean-of-median", "median-of-mean", "median-of-median"])
    groupMeasure: "mean" | "median" | "mean-of-mean" | "mean-of-median" | "median-of-mean" | "median-of-median"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    method?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => EvidenceVariableCharacteristicTimeFromStartDto)
    timeFromStart?: EvidenceVariableCharacteristicTimeFromStart

  }
  export class EvidenceVariableCategoryDto implements EvidenceVariableCategory {
    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

  }
  export class EvidenceVariableDto implements EvidenceVariable {
    @IsNotEmpty()
    @IsIn(["EvidenceVariable"])
    resourceType: "EvidenceVariable"

    @IsNotEmpty()
    @IsBoolean()
    actual: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    author?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EvidenceVariableCategoryDto)
    category?: EvidenceVariableCategory[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => EvidenceVariableCharacteristicDto)
    characteristic?: EvidenceVariableCharacteristic[]

    @IsNotEmpty()
    @IsIn(["intersection", "union"])
    characteristicCombination: "intersection" | "union"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    editor?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    endorser?: ContactDetail[]

    @IsNotEmpty()
    @IsIn(["continuous", "dichotomous", "ordinal", "polychotomous"])
    handling: "continuous" | "dichotomous" | "ordinal" | "polychotomous"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    relatedArtifact?: RelatedArtifact[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    reviewer?: ContactDetail[]

    @IsOptional()
    @IsString()
    shortTitle?: string

    @IsNotEmpty()
    @IsIn(["active", "unknown", "draft", "retired"])
    status: "active" | "unknown" | "draft" | "retired"

    @IsOptional()
    @IsString()
    subtitle?: string

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

  }
  export class ExampleScenarioActorDto implements ExampleScenarioActor {
    @IsNotEmpty()
    @IsString()
    actorId: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    name?: string

    @IsNotEmpty()
    @IsIn(["person", "entity"])
    type: "person" | "entity"

  }
  export class ExampleScenarioInstanceVersionDto implements ExampleScenarioInstanceVersion {
    @IsNotEmpty()
    @IsString()
    description: string

    @IsNotEmpty()
    @IsString()
    versionId: string

  }
  export class ExampleScenarioInstanceContainedInstanceDto implements ExampleScenarioInstanceContainedInstance {
    @IsNotEmpty()
    @IsString()
    resourceId: string

    @IsOptional()
    @IsString()
    versionId?: string

  }
  export class ExampleScenarioInstanceDto implements ExampleScenarioInstance {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExampleScenarioInstanceContainedInstanceDto)
    containedInstance?: ExampleScenarioInstanceContainedInstance[]

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    name?: string

    @IsNotEmpty()
    @IsString()
    resourceId: string

    @IsNotEmpty()
    @IsString()
    resourceType: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExampleScenarioInstanceVersionDto)
    version?: ExampleScenarioInstanceVersion[]

  }
  export class ExampleScenarioProcessStepOperationDto implements ExampleScenarioProcessStepOperation {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    initiator?: string

    @IsNotEmpty()
    @IsBoolean()
    initiatorActive: boolean

    @IsOptional()
    @IsString()
    name?: string

    @IsNotEmpty()
    @IsString()
    number: string

    @IsOptional()
    @IsString()
    receiver?: string

    @IsNotEmpty()
    @IsBoolean()
    receiverActive: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => ExampleScenarioInstanceContainedInstanceDto)
    request?: ExampleScenarioInstanceContainedInstance

    @IsOptional()
    @ValidateNested()
    @Type(() => ExampleScenarioInstanceContainedInstanceDto)
    response?: ExampleScenarioInstanceContainedInstance

    @IsOptional()
    @IsString()
    type?: string

  }
  export class ExampleScenarioProcessStepAlternativeDto implements ExampleScenarioProcessStepAlternative {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExampleScenarioProcessStepDto)
    step?: ExampleScenarioProcessStep[]

    @IsNotEmpty()
    @IsString()
    title: string

  }
  export class ExampleScenarioProcessStepDto implements ExampleScenarioProcessStep {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExampleScenarioProcessStepAlternativeDto)
    alternative?: ExampleScenarioProcessStepAlternative[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ExampleScenarioProcessStepOperationDto)
    operation?: ExampleScenarioProcessStepOperation

    @IsNotEmpty()
    @IsBoolean()
    pause: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExampleScenarioProcessDto)
    process?: ExampleScenarioProcess[]

  }
  export class ExampleScenarioProcessDto implements ExampleScenarioProcess {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    postConditions?: string

    @IsOptional()
    @IsString()
    preConditions?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExampleScenarioProcessStepDto)
    step?: ExampleScenarioProcessStep[]

    @IsNotEmpty()
    @IsString()
    title: string

  }
  export class ExampleScenarioDto implements ExampleScenario {
    @IsNotEmpty()
    @IsIn(["ExampleScenario"])
    resourceType: "ExampleScenario"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExampleScenarioActorDto)
    actor?: ExampleScenarioActor[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExampleScenarioInstanceDto)
    instance?: ExampleScenarioInstance[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExampleScenarioProcessDto)
    process?: ExampleScenarioProcess[]

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsNotEmpty()
    @IsIn(["active", "unknown", "draft", "retired"])
    status: "active" | "unknown" | "draft" | "retired"

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    workflow?: string[]

  }
  export class ExplanationOfBenefitRelatedDto implements ExplanationOfBenefitRelated {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    claim?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    reference?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    relationship?: CodeableConcept

  }
  export class ExplanationOfBenefitPayeeDto implements ExplanationOfBenefitPayee {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    party?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class ExplanationOfBenefitCareTeamDto implements ExplanationOfBenefitCareTeam {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    provider: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    qualification?: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    responsible: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    role?: CodeableConcept

    @IsNotEmpty()
    @IsNumber()
    sequence: number

  }
  export class ExplanationOfBenefitSupportingInfoDto implements ExplanationOfBenefitSupportingInfo {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    reason?: Coding

    @IsNotEmpty()
    @IsNumber()
    sequence: number

    @IsOptional()
    @IsString()
    timingDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    timingPeriod?: Period

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

  }
  export class ExplanationOfBenefitDiagnosisDto implements ExplanationOfBenefitDiagnosis {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    diagnosisCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    diagnosisReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    onAdmission?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    packageCode?: CodeableConcept

    @IsNotEmpty()
    @IsNumber()
    sequence: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

  }
  export class ExplanationOfBenefitProcedureDto implements ExplanationOfBenefitProcedure {
    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    procedureCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    procedureReference?: Reference

    @IsNotEmpty()
    @IsNumber()
    sequence: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    udi?: Reference[]

  }
  export class ExplanationOfBenefitInsuranceDto implements ExplanationOfBenefitInsurance {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    coverage: Reference

    @IsNotEmpty()
    @IsBoolean()
    focal: boolean

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    preAuthRef?: string[]

  }
  export class ExplanationOfBenefitAccidentDto implements ExplanationOfBenefitAccident {
    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    locationAddress?: Address

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    locationReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class ExplanationOfBenefitItemAdjudicationDto implements ExplanationOfBenefitItemAdjudication {
    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    amount?: Money

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    reason?: CodeableConcept

    @IsOptional()
    @IsNumber()
    value?: number

  }
  export class ExplanationOfBenefitItemDetailSubDetailDto implements ExplanationOfBenefitItemDetailSubDetail {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitItemAdjudicationDto)
    adjudication?: ExplanationOfBenefitItemAdjudication[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept

    @IsOptional()
    @IsNumber()
    factor?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    modifier?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    net?: Money

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    noteNumber?: number[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrService: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    programCode?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    revenue?: CodeableConcept

    @IsNotEmpty()
    @IsNumber()
    sequence: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    udi?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    unitPrice?: Money

  }
  export class ExplanationOfBenefitItemDetailDto implements ExplanationOfBenefitItemDetail {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitItemAdjudicationDto)
    adjudication?: ExplanationOfBenefitItemAdjudication[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept

    @IsOptional()
    @IsNumber()
    factor?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    modifier?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    net?: Money

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    noteNumber?: number[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrService: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    programCode?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    revenue?: CodeableConcept

    @IsNotEmpty()
    @IsNumber()
    sequence: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitItemDetailSubDetailDto)
    subDetail?: ExplanationOfBenefitItemDetailSubDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    udi?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    unitPrice?: Money

  }
  export class ExplanationOfBenefitItemDto implements ExplanationOfBenefitItem {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitItemAdjudicationDto)
    adjudication?: ExplanationOfBenefitItemAdjudication[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    bodySite?: CodeableConcept

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    careTeamSequence?: number[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitItemDetailDto)
    detail?: ExplanationOfBenefitItemDetail[]

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    diagnosisSequence?: number[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    encounter?: Reference[]

    @IsOptional()
    @IsNumber()
    factor?: number

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    informationSequence?: number[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    locationCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    locationAddress?: Address

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    locationReference?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    modifier?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    net?: Money

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    noteNumber?: number[]

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    procedureSequence?: number[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrService: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    programCode?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    revenue?: CodeableConcept

    @IsNotEmpty()
    @IsNumber()
    sequence: number

    @IsOptional()
    @IsString()
    servicedDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    servicedPeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    subSite?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    udi?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    unitPrice?: Money

  }
  export class ExplanationOfBenefitAddItemDetailSubDetailDto implements ExplanationOfBenefitAddItemDetailSubDetail {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitItemAdjudicationDto)
    adjudication?: ExplanationOfBenefitItemAdjudication[]

    @IsOptional()
    @IsNumber()
    factor?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    modifier?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    net?: Money

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    noteNumber?: number[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrService: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    unitPrice?: Money

  }
  export class ExplanationOfBenefitAddItemDetailDto implements ExplanationOfBenefitAddItemDetail {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitItemAdjudicationDto)
    adjudication?: ExplanationOfBenefitItemAdjudication[]

    @IsOptional()
    @IsNumber()
    factor?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    modifier?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    net?: Money

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    noteNumber?: number[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrService: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitAddItemDetailSubDetailDto)
    subDetail?: ExplanationOfBenefitAddItemDetailSubDetail[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    unitPrice?: Money

  }
  export class ExplanationOfBenefitAddItemDto implements ExplanationOfBenefitAddItem {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitItemAdjudicationDto)
    adjudication?: ExplanationOfBenefitItemAdjudication[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    bodySite?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitAddItemDetailDto)
    detail?: ExplanationOfBenefitAddItemDetail[]

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    detailSequence?: number[]

    @IsOptional()
    @IsNumber()
    factor?: number

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    itemSequence?: number[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    locationCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    locationAddress?: Address

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    locationReference?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    modifier?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    net?: Money

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    noteNumber?: number[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    productOrService: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    programCode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    provider?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @IsString()
    servicedDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    servicedPeriod?: Period

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    subDetailSequence?: number[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    subSite?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    unitPrice?: Money

  }
  export class ExplanationOfBenefitTotalDto implements ExplanationOfBenefitTotal {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => MoneyDto)
    amount: Money

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category: CodeableConcept

  }
  export class ExplanationOfBenefitPaymentDto implements ExplanationOfBenefitPayment {
    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    adjustment?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    adjustmentReason?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    amount?: Money

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class ExplanationOfBenefitProcessNoteDto implements ExplanationOfBenefitProcessNote {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    language?: CodeableConcept

    @IsOptional()
    @IsNumber()
    number?: number

    @IsOptional()
    @IsString()
    text?: string

    @IsNotEmpty()
    @IsIn(["display", "print", "printoper"])
    type: "display" | "print" | "printoper"

  }
  export class ExplanationOfBenefitBenefitBalanceFinancialDto implements ExplanationOfBenefitBenefitBalanceFinancial {
    @IsOptional()
    @IsNumber()
    allowedUnsignedInt?: number

    @IsOptional()
    @IsString()
    allowedString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    allowedMoney?: Money

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @IsNumber()
    usedUnsignedInt?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    usedMoney?: Money

  }
  export class ExplanationOfBenefitBenefitBalanceDto implements ExplanationOfBenefitBenefitBalance {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category: CodeableConcept

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsBoolean()
    excluded: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitBenefitBalanceFinancialDto)
    financial?: ExplanationOfBenefitBenefitBalanceFinancial[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    network?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    term?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    unit?: CodeableConcept

  }
  export class ExplanationOfBenefitDto implements ExplanationOfBenefit {
    @IsNotEmpty()
    @IsIn(["ExplanationOfBenefit"])
    resourceType: "ExplanationOfBenefit"

    @IsOptional()
    @ValidateNested()
    @Type(() => ExplanationOfBenefitAccidentDto)
    accident?: ExplanationOfBenefitAccident

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitAddItemDto)
    addItem?: ExplanationOfBenefitAddItem[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitItemAdjudicationDto)
    adjudication?: ExplanationOfBenefitItemAdjudication[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitBenefitBalanceDto)
    benefitBalance?: ExplanationOfBenefitBenefitBalance[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    benefitPeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    billablePeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitCareTeamDto)
    careTeam?: ExplanationOfBenefitCareTeam[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    claim?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    claimResponse?: Reference

    @IsNotEmpty()
    @IsString()
    created: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitDiagnosisDto)
    diagnosis?: ExplanationOfBenefitDiagnosis[]

    @IsOptional()
    @IsString()
    disposition?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    enterer?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    facility?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    form?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    formCode?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    fundsReserve?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    fundsReserveRequested?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitInsuranceDto)
    insurance: ExplanationOfBenefitInsurance[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    insurer: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitItemDto)
    item?: ExplanationOfBenefitItem[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    originalPrescription?: Reference

    @IsNotEmpty()
    @IsIn(["error", "queued", "complete", "partial"])
    outcome: "error" | "queued" | "complete" | "partial"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ExplanationOfBenefitPayeeDto)
    payee?: ExplanationOfBenefitPayee

    @IsOptional()
    @ValidateNested()
    @Type(() => ExplanationOfBenefitPaymentDto)
    payment?: ExplanationOfBenefitPayment

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    preAuthRef?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PeriodDto)
    preAuthRefPeriod?: Period[]

    @IsOptional()
    @IsNumber()
    precedence?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    prescription?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    priority?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitProcedureDto)
    procedure?: ExplanationOfBenefitProcedure[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitProcessNoteDto)
    processNote?: ExplanationOfBenefitProcessNote[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    provider: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    referral?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitRelatedDto)
    related?: ExplanationOfBenefitRelated[]

    @IsNotEmpty()
    @IsIn(["active", "entered-in-error", "draft", "cancelled"])
    status: "active" | "entered-in-error" | "draft" | "cancelled"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    subType?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitSupportingInfoDto)
    supportingInfo?: ExplanationOfBenefitSupportingInfo[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ExplanationOfBenefitTotalDto)
    total?: ExplanationOfBenefitTotal[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsNotEmpty()
    @IsIn(["claim", "preauthorization", "predetermination"])
    use: "claim" | "preauthorization" | "predetermination"

  }
  export class FamilyMemberHistoryConditionDto implements FamilyMemberHistoryCondition {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    contributedToDeath: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    onsetAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    onsetRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    onsetPeriod?: Period

    @IsOptional()
    @IsString()
    onsetString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    outcome?: CodeableConcept

  }
  export class FamilyMemberHistoryDto implements FamilyMemberHistory {
    @IsNotEmpty()
    @IsIn(["FamilyMemberHistory"])
    resourceType: "FamilyMemberHistory"

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    ageAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    ageRange?: Range

    @IsOptional()
    @IsString()
    ageString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    bornPeriod?: Period

    @IsOptional()
    @IsString()
    bornDate?: string

    @IsOptional()
    @IsString()
    bornString?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => FamilyMemberHistoryConditionDto)
    condition?: FamilyMemberHistoryCondition[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    dataAbsentReason?: CodeableConcept

    @IsOptional()
    @IsString()
    date?: string

    @IsNotEmpty()
    @IsBoolean()
    deceasedBoolean: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    deceasedAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    deceasedRange?: Range

    @IsOptional()
    @IsString()
    deceasedDate?: string

    @IsOptional()
    @IsString()
    deceasedString?: string

    @IsNotEmpty()
    @IsBoolean()
    estimatedAge: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesCanonical?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesUri?: string[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    reasonCode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    reasonReference?: Reference[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    relationship: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    sex?: CodeableConcept

    @IsNotEmpty()
    @IsIn(["entered-in-error", "completed", "partial", "health-unknown"])
    status: "entered-in-error" | "completed" | "partial" | "health-unknown"

  }
  export class FlagDto implements Flag {
    @IsNotEmpty()
    @IsIn(["Flag"])
    resourceType: "Flag"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    author?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsNotEmpty()
    @IsIn(["active", "inactive", "entered-in-error"])
    status: "active" | "inactive" | "entered-in-error"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

  }
  export class GoalTargetDto implements GoalTarget {
    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    detailQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    detailRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    detailCodeableConcept?: CodeableConcept

    @IsOptional()
    @IsString()
    detailString?: string

    @IsNotEmpty()
    @IsBoolean()
    detailBoolean: boolean

    @IsOptional()
    @IsNumber()
    detailInteger?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    detailRatio?: Ratio

    @IsOptional()
    @IsString()
    dueDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    dueDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    measure?: CodeableConcept

  }
  export class GoalDto implements Goal {
    @IsNotEmpty()
    @IsIn(["Goal"])
    resourceType: "Goal"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    achievementStatus?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    addresses?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    description: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    expressedBy?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsNotEmpty()
    @IsIn(["active", "entered-in-error", "on-hold", "accepted", "proposed", "cancelled", "completed", "planned", "rejected"])
    lifecycleStatus: "active" | "entered-in-error" | "on-hold" | "accepted" | "proposed" | "cancelled" | "completed" | "planned" | "rejected"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    outcomeCode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    outcomeReference?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    priority?: CodeableConcept

    @IsOptional()
    @IsString()
    startDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    startCodeableConcept?: CodeableConcept

    @IsOptional()
    @IsString()
    statusDate?: string

    @IsOptional()
    @IsString()
    statusReason?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => GoalTargetDto)
    target?: GoalTarget[]

  }
  export class GraphDefinitionLinkTargetCompartmentDto implements GraphDefinitionLinkTargetCompartment {
    @IsNotEmpty()
    @IsIn(["Patient", "Encounter", "RelatedPerson", "Practitioner", "Device"])
    code: "Patient" | "Encounter" | "RelatedPerson" | "Practitioner" | "Device"

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    expression?: string

    @IsNotEmpty()
    @IsIn(["identical", "matching", "different", "custom"])
    rule: "identical" | "matching" | "different" | "custom"

    @IsNotEmpty()
    @IsIn(["condition", "requirement"])
    use: "condition" | "requirement"

  }
  export class GraphDefinitionLinkTargetDto implements GraphDefinitionLinkTarget {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => GraphDefinitionLinkTargetCompartmentDto)
    compartment?: GraphDefinitionLinkTargetCompartment[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => GraphDefinitionLinkDto)
    link?: GraphDefinitionLink[]

    @IsOptional()
    @IsString()
    params?: string

    @IsOptional()
    @IsString()
    profile?: string

    @IsNotEmpty()
    @IsString()
    type: string

  }
  export class GraphDefinitionLinkDto implements GraphDefinitionLink {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    max?: string

    @IsOptional()
    @IsNumber()
    min?: number

    @IsOptional()
    @IsString()
    path?: string

    @IsOptional()
    @IsString()
    sliceName?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => GraphDefinitionLinkTargetDto)
    target?: GraphDefinitionLinkTarget[]

  }
  export class GraphDefinitionDto implements GraphDefinition {
    @IsNotEmpty()
    @IsIn(["GraphDefinition"])
    resourceType: "GraphDefinition"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => GraphDefinitionLinkDto)
    link?: GraphDefinitionLink[]

    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @IsString()
    profile?: string

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsNotEmpty()
    @IsString()
    start: string

    @IsNotEmpty()
    @IsIn(["active", "unknown", "draft", "retired"])
    status: "active" | "unknown" | "draft" | "retired"

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

  }
  export class GroupCharacteristicDto implements GroupCharacteristic {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    exclude: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

  }
  export class GroupMemberDto implements GroupMember {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    entity: Reference

    @IsNotEmpty()
    @IsBoolean()
    inactive: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

  }
  export class GroupDto implements Group {
    @IsNotEmpty()
    @IsIn(["Group"])
    resourceType: "Group"

    @IsNotEmpty()
    @IsBoolean()
    active: boolean

    @IsNotEmpty()
    @IsBoolean()
    actual: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => GroupCharacteristicDto)
    characteristic?: GroupCharacteristic[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    managingEntity?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => GroupMemberDto)
    member?: GroupMember[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsNumber()
    quantity?: number

    @IsNotEmpty()
    @IsIn(["practitioner", "device", "medication", "person", "animal", "substance"])
    type: "practitioner" | "device" | "medication" | "person" | "animal" | "substance"

  }
  export class GuidanceResponseDto implements GuidanceResponse {
    @IsNotEmpty()
    @IsIn(["GuidanceResponse"])
    resourceType: "GuidanceResponse"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DataRequirementDto)
    dataRequirement?: DataRequirement[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    evaluationMessage?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsString()
    moduleUri?: string

    @IsOptional()
    @IsString()
    moduleCanonical?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    moduleCodeableConcept?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    occurrenceDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    outputParameters?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    performer?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    reasonCode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    reasonReference?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    requestIdentifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    result?: Reference

    @IsNotEmpty()
    @IsIn(["entered-in-error", "in-progress", "success", "data-requested", "data-required", "failure"])
    status: "entered-in-error" | "in-progress" | "success" | "data-requested" | "data-required" | "failure"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

  }
  export class HealthcareServiceEligibilityDto implements HealthcareServiceEligibility {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsString()
    comment?: string

  }
  export class HealthcareServiceAvailableTimeDto implements HealthcareServiceAvailableTime {
    @IsNotEmpty()
    @IsBoolean()
    allDay: boolean

    @IsOptional()
    @IsString()
    availableEndTime?: string

    @IsOptional()
    @IsString()
    availableStartTime?: string

    @IsOptional()
    @IsArray()
    @IsIn(["mon", "tue", "wed", "thu", "fri", "sat", "sun"], { each: true })
    daysOfWeek?: ("mon" | "tue" | "wed" | "thu" | "fri" | "sat" | "sun")[]

  }
  export class HealthcareServiceNotAvailableDto implements HealthcareServiceNotAvailable {
    @IsNotEmpty()
    @IsString()
    description: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    during?: Period

  }
  export class HealthcareServiceDto implements HealthcareService {
    @IsNotEmpty()
    @IsIn(["HealthcareService"])
    resourceType: "HealthcareService"

    @IsNotEmpty()
    @IsBoolean()
    active: boolean

    @IsNotEmpty()
    @IsBoolean()
    appointmentRequired: boolean

    @IsOptional()
    @IsString()
    availabilityExceptions?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => HealthcareServiceAvailableTimeDto)
    availableTime?: HealthcareServiceAvailableTime[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    characteristic?: CodeableConcept[]

    @IsOptional()
    @IsString()
    comment?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    communication?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    coverageArea?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => HealthcareServiceEligibilityDto)
    eligibility?: HealthcareServiceEligibility[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    endpoint?: Reference[]

    @IsOptional()
    @IsString()
    extraDetails?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    location?: Reference[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => HealthcareServiceNotAvailableDto)
    notAvailable?: HealthcareServiceNotAvailable[]

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    photo?: Attachment

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    program?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    providedBy?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    referralMethod?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    serviceProvisionCode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    specialty?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactPointDto)
    telecom?: ContactPoint[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

  }
  export class ImagingStudySeriesPerformerDto implements ImagingStudySeriesPerformer {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    actor: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    function?: CodeableConcept

  }
  export class ImagingStudySeriesInstanceDto implements ImagingStudySeriesInstance {
    @IsOptional()
    @IsNumber()
    number?: number

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodingDto)
    sopClass: Coding

    @IsOptional()
    @IsString()
    title?: string

    @IsNotEmpty()
    @IsString()
    uid: string

  }
  export class ImagingStudySeriesDto implements ImagingStudySeries {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    bodySite?: Coding

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    endpoint?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImagingStudySeriesInstanceDto)
    instance?: ImagingStudySeriesInstance[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    laterality?: Coding

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodingDto)
    modality: Coding

    @IsOptional()
    @IsNumber()
    number?: number

    @IsOptional()
    @IsNumber()
    numberOfInstances?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImagingStudySeriesPerformerDto)
    performer?: ImagingStudySeriesPerformer[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    specimen?: Reference[]

    @IsOptional()
    @IsString()
    started?: string

    @IsNotEmpty()
    @IsString()
    uid: string

  }
  export class ImagingStudyDto implements ImagingStudy {
    @IsNotEmpty()
    @IsIn(["ImagingStudy"])
    resourceType: "ImagingStudy"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    endpoint?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    interpreter?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    location?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    modality?: Coding[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsNumber()
    numberOfInstances?: number

    @IsOptional()
    @IsNumber()
    numberOfSeries?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    procedureCode?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    procedureReference?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    reasonCode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    reasonReference?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    referrer?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImagingStudySeriesDto)
    series?: ImagingStudySeries[]

    @IsOptional()
    @IsString()
    started?: string

    @IsNotEmpty()
    @IsIn(["entered-in-error", "unknown", "cancelled", "available", "registered"])
    status: "entered-in-error" | "unknown" | "cancelled" | "available" | "registered"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

  }
  export class ImmunizationPerformerDto implements ImmunizationPerformer {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    actor: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    function?: CodeableConcept

  }
  export class ImmunizationEducationDto implements ImmunizationEducation {
    @IsOptional()
    @IsString()
    documentType?: string

    @IsOptional()
    @IsString()
    presentationDate?: string

    @IsOptional()
    @IsString()
    publicationDate?: string

    @IsOptional()
    @IsString()
    reference?: string

  }
  export class ImmunizationReactionDto implements ImmunizationReaction {
    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    detail?: Reference

    @IsNotEmpty()
    @IsBoolean()
    reported: boolean

  }
  export class ImmunizationProtocolAppliedDto implements ImmunizationProtocolApplied {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    authority?: Reference

    @IsOptional()
    @IsNumber()
    doseNumberPositiveInt?: number

    @IsOptional()
    @IsString()
    doseNumberString?: string

    @IsOptional()
    @IsString()
    series?: string

    @IsOptional()
    @IsNumber()
    seriesDosesPositiveInt?: number

    @IsOptional()
    @IsString()
    seriesDosesString?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    targetDisease?: CodeableConcept[]

  }
  export class ImmunizationDto implements Immunization {
    @IsNotEmpty()
    @IsIn(["Immunization"])
    resourceType: "Immunization"

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    doseQuantity?: Quantity

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImmunizationEducationDto)
    education?: ImmunizationEducation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsString()
    expirationDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    fundingSource?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsNotEmpty()
    @IsBoolean()
    isSubpotent: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    location?: Reference

    @IsOptional()
    @IsString()
    lotNumber?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    manufacturer?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    occurrenceDateTime?: string

    @IsOptional()
    @IsString()
    occurrenceString?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImmunizationPerformerDto)
    performer?: ImmunizationPerformer[]

    @IsNotEmpty()
    @IsBoolean()
    primarySource: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    programEligibility?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImmunizationProtocolAppliedDto)
    protocolApplied?: ImmunizationProtocolApplied[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImmunizationReactionDto)
    reaction?: ImmunizationReaction[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    reasonCode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    reasonReference?: Reference[]

    @IsOptional()
    @IsString()
    recorded?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    reportOrigin?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    route?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    site?: CodeableConcept

    @IsNotEmpty()
    @IsIn(["entered-in-error", "completed", "not-done"])
    status: "entered-in-error" | "completed" | "not-done"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    statusReason?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    subpotentReason?: CodeableConcept[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    vaccineCode: CodeableConcept

  }
  export class ImmunizationEvaluationDto implements ImmunizationEvaluation {
    @IsNotEmpty()
    @IsIn(["ImmunizationEvaluation"])
    resourceType: "ImmunizationEvaluation"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    authority?: Reference

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsNumber()
    doseNumberPositiveInt?: number

    @IsOptional()
    @IsString()
    doseNumberString?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    doseStatus: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    doseStatusReason?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    immunizationEvent: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient: Reference

    @IsOptional()
    @IsString()
    series?: string

    @IsOptional()
    @IsNumber()
    seriesDosesPositiveInt?: number

    @IsOptional()
    @IsString()
    seriesDosesString?: string

    @IsNotEmpty()
    @IsIn(["entered-in-error", "completed"])
    status: "entered-in-error" | "completed"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    targetDisease: CodeableConcept

  }
  export class ImmunizationRecommendationRecommendationDateCriterionDto implements ImmunizationRecommendationRecommendationDateCriterion {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsNotEmpty()
    @IsString()
    value: string

  }
  export class ImmunizationRecommendationRecommendationDto implements ImmunizationRecommendationRecommendation {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    contraindicatedVaccineCode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImmunizationRecommendationRecommendationDateCriterionDto)
    dateCriterion?: ImmunizationRecommendationRecommendationDateCriterion[]

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsNumber()
    doseNumberPositiveInt?: number

    @IsOptional()
    @IsString()
    doseNumberString?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    forecastReason?: CodeableConcept[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    forecastStatus: CodeableConcept

    @IsOptional()
    @IsString()
    series?: string

    @IsOptional()
    @IsNumber()
    seriesDosesPositiveInt?: number

    @IsOptional()
    @IsString()
    seriesDosesString?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    supportingImmunization?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    supportingPatientInformation?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    targetDisease?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    vaccineCode?: CodeableConcept[]

  }
  export class ImmunizationRecommendationDto implements ImmunizationRecommendation {
    @IsNotEmpty()
    @IsIn(["ImmunizationRecommendation"])
    resourceType: "ImmunizationRecommendation"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    authority?: Reference

    @IsNotEmpty()
    @IsString()
    date: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient: Reference

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImmunizationRecommendationRecommendationDto)
    recommendation: ImmunizationRecommendationRecommendation[]

  }
  export class ImplementationGuideDependsOnDto implements ImplementationGuideDependsOn {
    @IsOptional()
    @IsString()
    packageId?: string

    @IsNotEmpty()
    @IsString()
    uri: string

    @IsOptional()
    @IsString()
    version?: string

  }
  export class ImplementationGuideGlobalDto implements ImplementationGuideGlobal {
    @IsNotEmpty()
    @IsString()
    profile: string

    @IsNotEmpty()
    @IsString()
    type: string

  }
  export class ImplementationGuideDefinitionGroupingDto implements ImplementationGuideDefinitionGrouping {
    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsString()
    name: string

  }
  export class ImplementationGuideDefinitionResourceDto implements ImplementationGuideDefinitionResource {
    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsBoolean()
    exampleBoolean: boolean

    @IsOptional()
    @IsString()
    exampleCanonical?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    fhirVersion?: string[]

    @IsOptional()
    @IsString()
    groupingId?: string

    @IsOptional()
    @IsString()
    name?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    reference: Reference

  }
  export class ImplementationGuideDefinitionPageDto implements ImplementationGuideDefinitionPage {
    @IsNotEmpty()
    @IsIn(["generated", "html", "markdown", "xml"])
    generation: "generated" | "html" | "markdown" | "xml"

    @IsOptional()
    @IsString()
    nameUrl?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    nameReference?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImplementationGuideDefinitionPageDto)
    page?: ImplementationGuideDefinitionPage[]

    @IsNotEmpty()
    @IsString()
    title: string

  }
  export class ImplementationGuideDefinitionParameterDto implements ImplementationGuideDefinitionParameter {
    @IsNotEmpty()
    @IsIn(["apply", "path-resource", "path-pages", "path-tx-cache", "expansion-parameter", "rule-broken-links", "generate-xml", "generate-json", "generate-turtle", "html-template"])
    code: "apply" | "path-resource" | "path-pages" | "path-tx-cache" | "expansion-parameter" | "rule-broken-links" | "generate-xml" | "generate-json" | "generate-turtle" | "html-template"

    @IsNotEmpty()
    @IsString()
    value: string

  }
  export class ImplementationGuideDefinitionTemplateDto implements ImplementationGuideDefinitionTemplate {
    @IsNotEmpty()
    @IsString()
    code: string

    @IsOptional()
    @IsString()
    scope?: string

    @IsNotEmpty()
    @IsString()
    source: string

  }
  export class ImplementationGuideDefinitionDto implements ImplementationGuideDefinition {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImplementationGuideDefinitionGroupingDto)
    grouping?: ImplementationGuideDefinitionGrouping[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ImplementationGuideDefinitionPageDto)
    page?: ImplementationGuideDefinitionPage

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImplementationGuideDefinitionParameterDto)
    parameter?: ImplementationGuideDefinitionParameter[]

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImplementationGuideDefinitionResourceDto)
    resource: ImplementationGuideDefinitionResource[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImplementationGuideDefinitionTemplateDto)
    template?: ImplementationGuideDefinitionTemplate[]

  }
  export class ImplementationGuideManifestResourceDto implements ImplementationGuideManifestResource {
    @IsNotEmpty()
    @IsBoolean()
    exampleBoolean: boolean

    @IsOptional()
    @IsString()
    exampleCanonical?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    reference: Reference

    @IsOptional()
    @IsString()
    relativePath?: string

  }
  export class ImplementationGuideManifestPageDto implements ImplementationGuideManifestPage {
    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    anchor?: string[]

    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @IsString()
    title?: string

  }
  export class ImplementationGuideManifestDto implements ImplementationGuideManifest {
    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    image?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    other?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImplementationGuideManifestPageDto)
    page?: ImplementationGuideManifestPage[]

    @IsOptional()
    @IsString()
    rendering?: string

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImplementationGuideManifestResourceDto)
    resource: ImplementationGuideManifestResource[]

  }
  export class ImplementationGuideDto implements ImplementationGuide {
    @IsNotEmpty()
    @IsIn(["ImplementationGuide"])
    resourceType: "ImplementationGuide"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ImplementationGuideDefinitionDto)
    definition?: ImplementationGuideDefinition

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImplementationGuideDependsOnDto)
    dependsOn?: ImplementationGuideDependsOn[]

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsNotEmpty()
    @IsArray()
    @IsString({ each: true })
    fhirVersion: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ImplementationGuideGlobalDto)
    global?: ImplementationGuideGlobal[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    license?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ImplementationGuideManifestDto)
    manifest?: ImplementationGuideManifest

    @IsNotEmpty()
    @IsString()
    name: string

    @IsNotEmpty()
    @IsString()
    packageId: string

    @IsOptional()
    @IsString()
    publisher?: string

    @IsNotEmpty()
    @IsIn(["active", "unknown", "draft", "retired"])
    status: "active" | "unknown" | "draft" | "retired"

    @IsOptional()
    @IsString()
    title?: string

    @IsNotEmpty()
    @IsString()
    url: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

  }
  export class IngredientManufacturerDto implements IngredientManufacturer {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    manufacturer: Reference

    @IsNotEmpty()
    @IsIn(["actual", "allowed", "possible"])
    role: "actual" | "allowed" | "possible"

  }
  export class IngredientSubstanceStrengthReferenceStrengthDto implements IngredientSubstanceStrengthReferenceStrength {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    country?: CodeableConcept[]

    @IsOptional()
    @IsString()
    measurementPoint?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    strengthRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioRangeDto)
    strengthRatioRange?: RatioRange

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    substance?: CodeableReference

  }
  export class IngredientSubstanceStrengthDto implements IngredientSubstanceStrength {
    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    concentrationRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioRangeDto)
    concentrationRatioRange?: RatioRange

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    country?: CodeableConcept[]

    @IsOptional()
    @IsString()
    measurementPoint?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    presentationRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioRangeDto)
    presentationRatioRange?: RatioRange

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IngredientSubstanceStrengthReferenceStrengthDto)
    referenceStrength?: IngredientSubstanceStrengthReferenceStrength[]

    @IsOptional()
    @IsString()
    textConcentration?: string

    @IsOptional()
    @IsString()
    textPresentation?: string

  }
  export class IngredientSubstanceDto implements IngredientSubstance {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    code: CodeableReference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IngredientSubstanceStrengthDto)
    strength?: IngredientSubstanceStrength[]

  }
  export class IngredientDto implements Ingredient {
    @IsNotEmpty()
    @IsIn(["Ingredient"])
    resourceType: "Ingredient"

    @IsNotEmpty()
    @IsBoolean()
    allergenicIndicator: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    for?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    function?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IngredientManufacturerDto)
    manufacturer?: IngredientManufacturer[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    role: CodeableConcept

    @IsNotEmpty()
    @IsIn(["active", "unknown", "draft", "retired"])
    status: "active" | "unknown" | "draft" | "retired"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => IngredientSubstanceDto)
    substance: IngredientSubstance

  }
  export class InsurancePlanContactDto implements InsurancePlanContact {
    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    address?: Address

    @IsOptional()
    @ValidateNested()
    @Type(() => HumanNameDto)
    name?: HumanName

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    purpose?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactPointDto)
    telecom?: ContactPoint[]

  }
  export class InsurancePlanCoverageBenefitLimitDto implements InsurancePlanCoverageBenefitLimit {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    value?: Quantity

  }
  export class InsurancePlanCoverageBenefitDto implements InsurancePlanCoverageBenefit {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => InsurancePlanCoverageBenefitLimitDto)
    limit?: InsurancePlanCoverageBenefitLimit[]

    @IsOptional()
    @IsString()
    requirement?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class InsurancePlanCoverageDto implements InsurancePlanCoverage {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => InsurancePlanCoverageBenefitDto)
    benefit: InsurancePlanCoverageBenefit[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    network?: Reference[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class InsurancePlanPlanGeneralCostDto implements InsurancePlanPlanGeneralCost {
    @IsOptional()
    @IsString()
    comment?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    cost?: Money

    @IsOptional()
    @IsNumber()
    groupSize?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class InsurancePlanPlanSpecificCostBenefitCostDto implements InsurancePlanPlanSpecificCostBenefitCost {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    applicability?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    qualifiers?: CodeableConcept[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    value?: Quantity

  }
  export class InsurancePlanPlanSpecificCostBenefitDto implements InsurancePlanPlanSpecificCostBenefit {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => InsurancePlanPlanSpecificCostBenefitCostDto)
    cost?: InsurancePlanPlanSpecificCostBenefitCost[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class InsurancePlanPlanSpecificCostDto implements InsurancePlanPlanSpecificCost {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => InsurancePlanPlanSpecificCostBenefitDto)
    benefit?: InsurancePlanPlanSpecificCostBenefit[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category: CodeableConcept

  }
  export class InsurancePlanPlanDto implements InsurancePlanPlan {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    coverageArea?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => InsurancePlanPlanGeneralCostDto)
    generalCost?: InsurancePlanPlanGeneralCost[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    network?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => InsurancePlanPlanSpecificCostDto)
    specificCost?: InsurancePlanPlanSpecificCost[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class InsurancePlanDto implements InsurancePlan {
    @IsNotEmpty()
    @IsIn(["InsurancePlan"])
    resourceType: "InsurancePlan"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    administeredBy?: Reference

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    alias?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => InsurancePlanContactDto)
    contact?: InsurancePlanContact[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => InsurancePlanCoverageDto)
    coverage?: InsurancePlanCoverage[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    coverageArea?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    endpoint?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    network?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    ownedBy?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => InsurancePlanPlanDto)
    plan?: InsurancePlanPlan[]

    @IsNotEmpty()
    @IsIn(["active", "unknown", "draft", "retired"])
    status: "active" | "unknown" | "draft" | "retired"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

  }
  export class InvoiceParticipantDto implements InvoiceParticipant {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    actor: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    role?: CodeableConcept

  }
  export class InvoiceLineItemPriceComponentDto implements InvoiceLineItemPriceComponent {
    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    amount?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsNumber()
    factor?: number

    @IsNotEmpty()
    @IsIn(["base", "surcharge", "deduction", "discount", "tax", "informational"])
    type: "base" | "surcharge" | "deduction" | "discount" | "tax" | "informational"

  }
  export class InvoiceLineItemDto implements InvoiceLineItem {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    chargeItemReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    chargeItemCodeableConcept?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => InvoiceLineItemPriceComponentDto)
    priceComponent?: InvoiceLineItemPriceComponent[]

    @IsOptional()
    @IsNumber()
    sequence?: number

  }
  export class InvoiceDto implements Invoice {
    @IsNotEmpty()
    @IsIn(["Invoice"])
    resourceType: "Invoice"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    account?: Reference

    @IsOptional()
    @IsString()
    cancelledReason?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    issuer?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => InvoiceLineItemDto)
    lineItem?: InvoiceLineItem[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => InvoiceParticipantDto)
    participant?: InvoiceParticipant[]

    @IsOptional()
    @IsString()
    paymentTerms?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    recipient?: Reference

    @IsNotEmpty()
    @IsIn(["entered-in-error", "draft", "cancelled", "issued", "balanced"])
    status: "entered-in-error" | "draft" | "cancelled" | "issued" | "balanced"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    totalGross?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    totalNet?: Money

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => InvoiceLineItemPriceComponentDto)
    totalPriceComponent?: InvoiceLineItemPriceComponent[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class LibraryDto implements Library {
    @IsNotEmpty()
    @IsIn(["Library"])
    resourceType: "Library"

    @IsOptional()
    @IsString()
    approvalDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    author?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AttachmentDto)
    content?: Attachment[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DataRequirementDto)
    dataRequirement?: DataRequirement[]

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    editor?: ContactDetail[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    endorser?: ContactDetail[]

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    lastReviewDate?: string

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ParameterDefinitionDto)
    parameter?: ParameterDefinition[]

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    relatedArtifact?: RelatedArtifact[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    reviewer?: ContactDetail[]

    @IsNotEmpty()
    @IsIn(["active", "unknown", "draft", "retired"])
    status: "active" | "unknown" | "draft" | "retired"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    subjectCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subjectReference?: Reference

    @IsOptional()
    @IsString()
    subtitle?: string

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    topic?: CodeableConcept[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsString()
    usage?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

  }
  export class LinkageItemDto implements LinkageItem {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    resource: Reference

    @IsNotEmpty()
    @IsIn(["source", "alternate", "historical"])
    type: "source" | "alternate" | "historical"

  }
  export class LinkageDto implements Linkage {
    @IsNotEmpty()
    @IsIn(["Linkage"])
    resourceType: "Linkage"

    @IsNotEmpty()
    @IsBoolean()
    active: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    author?: Reference

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => LinkageItemDto)
    item: LinkageItem[]

  }
  export class ListEntryDto implements ListEntry {
    @IsOptional()
    @IsString()
    date?: string

    @IsNotEmpty()
    @IsBoolean()
    deleted: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    flag?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    item: Reference

  }
  export class ListDto implements List {
    @IsNotEmpty()
    @IsIn(["List"])
    resourceType: "List"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    emptyReason?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ListEntryDto)
    entry?: ListEntry[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsNotEmpty()
    @IsIn(["working", "snapshot", "changes"])
    mode: "working" | "snapshot" | "changes"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    orderedBy?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    source?: Reference

    @IsNotEmpty()
    @IsIn(["entered-in-error", "retired", "current"])
    status: "entered-in-error" | "retired" | "current"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

    @IsOptional()
    @IsString()
    title?: string

  }
  export class LocationPositionDto implements LocationPosition {
    @IsOptional()
    @IsNumber()
    altitude?: number

    @IsNotEmpty()
    @IsNumber()
    latitude: number

    @IsNotEmpty()
    @IsNumber()
    longitude: number

  }
  export class LocationHoursOfOperationDto implements LocationHoursOfOperation {
    @IsNotEmpty()
    @IsBoolean()
    allDay: boolean

    @IsOptional()
    @IsString()
    closingTime?: string

    @IsOptional()
    @IsArray()
    @IsIn(["mon", "tue", "wed", "thu", "fri", "sat", "sun"], { each: true })
    daysOfWeek?: ("mon" | "tue" | "wed" | "thu" | "fri" | "sat" | "sun")[]

    @IsOptional()
    @IsString()
    openingTime?: string

  }
  export class LocationDto implements Location {
    @IsNotEmpty()
    @IsIn(["Location"])
    resourceType: "Location"

    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    address?: Address

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    alias?: string[]

    @IsOptional()
    @IsString()
    availabilityExceptions?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    endpoint?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => LocationHoursOfOperationDto)
    hoursOfOperation?: LocationHoursOfOperation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    managingOrganization?: Reference

    @IsNotEmpty()
    @IsIn(["instance", "kind"])
    mode: "instance" | "kind"

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    operationalStatus?: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    partOf?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    physicalType?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => LocationPositionDto)
    position?: LocationPosition

    @IsNotEmpty()
    @IsIn(["active", "inactive", "suspended"])
    status: "active" | "inactive" | "suspended"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactPointDto)
    telecom?: ContactPoint[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

  }
  export class ManufacturedItemDefinitionPropertyDto implements ManufacturedItemDefinitionProperty {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @IsString()
    valueDate?: string

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

  }
  export class ManufacturedItemDefinitionDto implements ManufacturedItemDefinition {
    @IsNotEmpty()
    @IsIn(["ManufacturedItemDefinition"])
    resourceType: "ManufacturedItemDefinition"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    ingredient?: CodeableConcept[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    manufacturedDoseForm: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    manufacturer?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ManufacturedItemDefinitionPropertyDto)
    property?: ManufacturedItemDefinitionProperty[]

    @IsNotEmpty()
    @IsIn(["active", "unknown", "draft", "retired"])
    status: "active" | "unknown" | "draft" | "retired"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    unitOfPresentation?: CodeableConcept

  }
  export class MeasureGroupPopulationDto implements MeasureGroupPopulation {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ExpressionDto)
    criteria: Expression

    @IsOptional()
    @IsString()
    description?: string

  }
  export class MeasureGroupStratifierComponentDto implements MeasureGroupStratifierComponent {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ExpressionDto)
    criteria: Expression

    @IsOptional()
    @IsString()
    description?: string

  }
  export class MeasureGroupStratifierDto implements MeasureGroupStratifier {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MeasureGroupStratifierComponentDto)
    component?: MeasureGroupStratifierComponent[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    criteria?: Expression

    @IsOptional()
    @IsString()
    description?: string

  }
  export class MeasureGroupDto implements MeasureGroup {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MeasureGroupPopulationDto)
    population?: MeasureGroupPopulation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MeasureGroupStratifierDto)
    stratifier?: MeasureGroupStratifier[]

  }
  export class MeasureSupplementalDataDto implements MeasureSupplementalData {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ExpressionDto)
    criteria: Expression

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    usage?: CodeableConcept[]

  }
  export class MeasureDto implements Measure {
    @IsNotEmpty()
    @IsIn(["Measure"])
    resourceType: "Measure"

    @IsOptional()
    @IsString()
    approvalDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    author?: ContactDetail[]

    @IsOptional()
    @IsString()
    clinicalRecommendationStatement?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    compositeScoring?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    definition?: string[]

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    disclaimer?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    editor?: ContactDetail[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    endorser?: ContactDetail[]

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MeasureGroupDto)
    group?: MeasureGroup[]

    @IsOptional()
    @IsString()
    guidance?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    improvementNotation?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    lastReviewDate?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    library?: string[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @IsString()
    rateAggregation?: string

    @IsOptional()
    @IsString()
    rationale?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    relatedArtifact?: RelatedArtifact[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    reviewer?: ContactDetail[]

    @IsOptional()
    @IsString()
    riskAdjustment?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    scoring?: CodeableConcept

    @IsNotEmpty()
    @IsIn(["active", "unknown", "draft", "retired"])
    status: "active" | "unknown" | "draft" | "retired"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    subjectCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subjectReference?: Reference

    @IsOptional()
    @IsString()
    subtitle?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MeasureSupplementalDataDto)
    supplementalData?: MeasureSupplementalData[]

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    topic?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsString()
    usage?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

  }
  export class MeasureReportGroupPopulationDto implements MeasureReportGroupPopulation {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsNumber()
    count?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subjectResults?: Reference

  }
  export class MeasureReportGroupStratifierStratumComponentDto implements MeasureReportGroupStratifierStratumComponent {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    value: CodeableConcept

  }
  export class MeasureReportGroupStratifierStratumPopulationDto implements MeasureReportGroupStratifierStratumPopulation {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsNumber()
    count?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subjectResults?: Reference

  }
  export class MeasureReportGroupStratifierStratumDto implements MeasureReportGroupStratifierStratum {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MeasureReportGroupStratifierStratumComponentDto)
    component?: MeasureReportGroupStratifierStratumComponent[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    measureScore?: Quantity

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MeasureReportGroupStratifierStratumPopulationDto)
    population?: MeasureReportGroupStratifierStratumPopulation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    value?: CodeableConcept

  }
  export class MeasureReportGroupStratifierDto implements MeasureReportGroupStratifier {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MeasureReportGroupStratifierStratumDto)
    stratum?: MeasureReportGroupStratifierStratum[]

  }
  export class MeasureReportGroupDto implements MeasureReportGroup {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    measureScore?: Quantity

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MeasureReportGroupPopulationDto)
    population?: MeasureReportGroupPopulation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MeasureReportGroupStratifierDto)
    stratifier?: MeasureReportGroupStratifier[]

  }
  export class MeasureReportDto implements MeasureReport {
    @IsNotEmpty()
    @IsIn(["MeasureReport"])
    resourceType: "MeasureReport"

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    evaluatedResource?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MeasureReportGroupDto)
    group?: MeasureReportGroup[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    improvementNotation?: CodeableConcept

    @IsNotEmpty()
    @IsString()
    measure: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => PeriodDto)
    period: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    reporter?: Reference

    @IsNotEmpty()
    @IsIn(["error", "pending", "complete"])
    status: "error" | "pending" | "complete"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

    @IsNotEmpty()
    @IsIn(["individual", "subject-list", "summary", "data-collection"])
    type: "individual" | "subject-list" | "summary" | "data-collection"

  }
  export class MediaDto implements Media {
    @IsNotEmpty()
    @IsIn(["Media"])
    resourceType: "Media"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    bodySite?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => AttachmentDto)
    content: Attachment

    @IsOptional()
    @IsString()
    createdDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    createdPeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    device?: Reference

    @IsOptional()
    @IsString()
    deviceName?: string

    @IsOptional()
    @IsNumber()
    duration?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsNumber()
    frames?: number

    @IsOptional()
    @IsNumber()
    height?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsString()
    issued?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    modality?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    operator?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    partOf?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    reasonCode?: CodeableConcept[]

    @IsNotEmpty()
    @IsIn(["entered-in-error", "on-hold", "unknown", "in-progress", "completed", "stopped", "preparation", "not-done"])
    status: "entered-in-error" | "on-hold" | "unknown" | "in-progress" | "completed" | "stopped" | "preparation" | "not-done"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    view?: CodeableConcept

    @IsOptional()
    @IsNumber()
    width?: number

  }
  export class MedicationIngredientDto implements MedicationIngredient {
    @IsNotEmpty()
    @IsBoolean()
    isActive: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    itemCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    itemReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    strength?: Ratio

  }
  export class MedicationBatchDto implements MedicationBatch {
    @IsOptional()
    @IsString()
    expirationDate?: string

    @IsOptional()
    @IsString()
    lotNumber?: string

  }
  export class MedicationDto implements Medication {
    @IsNotEmpty()
    @IsIn(["Medication"])
    resourceType: "Medication"

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    amount?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => MedicationBatchDto)
    batch?: MedicationBatch

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    form?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationIngredientDto)
    ingredient?: MedicationIngredient[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    manufacturer?: Reference

    @IsNotEmpty()
    @IsIn(["active", "inactive", "entered-in-error"])
    status: "active" | "inactive" | "entered-in-error"

  }
  export class MedicationAdministrationPerformerDto implements MedicationAdministrationPerformer {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    actor: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    function?: CodeableConcept

  }
  export class MedicationAdministrationDosageDto implements MedicationAdministrationDosage {
    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    dose?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    method?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    rateRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    rateQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    route?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    site?: CodeableConcept

    @IsOptional()
    @IsString()
    text?: string

  }
  export class MedicationAdministrationDto implements MedicationAdministration {
    @IsNotEmpty()
    @IsIn(["MedicationAdministration"])
    resourceType: "MedicationAdministration"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    context?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    device?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MedicationAdministrationDosageDto)
    dosage?: MedicationAdministrationDosage

    @IsOptional()
    @IsString()
    effectiveDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    eventHistory?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiates?: string[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    medicationCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    medicationReference?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    partOf?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationAdministrationPerformerDto)
    performer?: MedicationAdministrationPerformer[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    reasonCode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    reasonReference?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    request?: Reference

    @IsNotEmpty()
    @IsIn(["entered-in-error", "on-hold", "unknown", "in-progress", "completed", "stopped", "not-done"])
    status: "entered-in-error" | "on-hold" | "unknown" | "in-progress" | "completed" | "stopped" | "not-done"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    statusReason?: CodeableConcept[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    supportingInformation?: Reference[]

  }
  export class MedicationDispensePerformerDto implements MedicationDispensePerformer {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    actor: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    function?: CodeableConcept

  }
  export class MedicationDispenseSubstitutionDto implements MedicationDispenseSubstitution {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    reason?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    responsibleParty?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    wasSubstituted: boolean

  }
  export class MedicationDispenseDto implements MedicationDispense {
    @IsNotEmpty()
    @IsIn(["MedicationDispense"])
    resourceType: "MedicationDispense"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    authorizingPrescription?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    context?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    daysSupply?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    destination?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    detectedIssue?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DosageDto)
    dosageInstruction?: Dosage[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    eventHistory?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    location?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    medicationCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    medicationReference?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    partOf?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationDispensePerformerDto)
    performer?: MedicationDispensePerformer[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    receiver?: Reference[]

    @IsNotEmpty()
    @IsIn(["entered-in-error", "on-hold", "unknown", "declined", "cancelled", "in-progress", "completed", "stopped", "preparation"])
    status: "entered-in-error" | "on-hold" | "unknown" | "declined" | "cancelled" | "in-progress" | "completed" | "stopped" | "preparation"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    statusReasonCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    statusReasonReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => MedicationDispenseSubstitutionDto)
    substitution?: MedicationDispenseSubstitution

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    supportingInformation?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsOptional()
    @IsString()
    whenHandedOver?: string

    @IsOptional()
    @IsString()
    whenPrepared?: string

  }
  export class MedicationKnowledgeRelatedMedicationKnowledgeDto implements MedicationKnowledgeRelatedMedicationKnowledge {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    reference: Reference[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class MedicationKnowledgeMonographDto implements MedicationKnowledgeMonograph {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    source?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class MedicationKnowledgeIngredientDto implements MedicationKnowledgeIngredient {
    @IsNotEmpty()
    @IsBoolean()
    isActive: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    itemCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    itemReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    strength?: Ratio

  }
  export class MedicationKnowledgeCostDto implements MedicationKnowledgeCost {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => MoneyDto)
    cost: Money

    @IsOptional()
    @IsString()
    source?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class MedicationKnowledgeMonitoringProgramDto implements MedicationKnowledgeMonitoringProgram {
    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class MedicationKnowledgeAdministrationGuidelinesDosageDto implements MedicationKnowledgeAdministrationGuidelinesDosage {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DosageDto)
    dosage: Dosage[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class MedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsDto implements MedicationKnowledgeAdministrationGuidelinesPatientCharacteristics {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    characteristicCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    characteristicQuantity?: Quantity

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    value?: string[]

  }
  export class MedicationKnowledgeAdministrationGuidelinesDto implements MedicationKnowledgeAdministrationGuidelines {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationKnowledgeAdministrationGuidelinesDosageDto)
    dosage?: MedicationKnowledgeAdministrationGuidelinesDosage[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    indicationCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    indicationReference?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsDto)
    patientCharacteristics?: MedicationKnowledgeAdministrationGuidelinesPatientCharacteristics[]

  }
  export class MedicationKnowledgeMedicineClassificationDto implements MedicationKnowledgeMedicineClassification {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    classification?: CodeableConcept[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class MedicationKnowledgePackagingDto implements MedicationKnowledgePackaging {
    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class MedicationKnowledgeDrugCharacteristicDto implements MedicationKnowledgeDrugCharacteristic {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @IsString()
    valueBase64Binary?: string

  }
  export class MedicationKnowledgeRegulatorySubstitutionDto implements MedicationKnowledgeRegulatorySubstitution {
    @IsNotEmpty()
    @IsBoolean()
    allowed: boolean

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class MedicationKnowledgeRegulatoryScheduleDto implements MedicationKnowledgeRegulatorySchedule {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    schedule: CodeableConcept

  }
  export class MedicationKnowledgeRegulatoryMaxDispenseDto implements MedicationKnowledgeRegulatoryMaxDispense {
    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    period?: Duration

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity: Quantity

  }
  export class MedicationKnowledgeRegulatoryDto implements MedicationKnowledgeRegulatory {
    @IsOptional()
    @ValidateNested()
    @Type(() => MedicationKnowledgeRegulatoryMaxDispenseDto)
    maxDispense?: MedicationKnowledgeRegulatoryMaxDispense

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    regulatoryAuthority: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationKnowledgeRegulatoryScheduleDto)
    schedule?: MedicationKnowledgeRegulatorySchedule[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationKnowledgeRegulatorySubstitutionDto)
    substitution?: MedicationKnowledgeRegulatorySubstitution[]

  }
  export class MedicationKnowledgeKineticsDto implements MedicationKnowledgeKinetics {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => QuantityDto)
    areaUnderCurve?: Quantity[]

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    halfLifePeriod?: Duration

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => QuantityDto)
    lethalDose50?: Quantity[]

  }
  export class MedicationKnowledgeDto implements MedicationKnowledge {
    @IsNotEmpty()
    @IsIn(["MedicationKnowledge"])
    resourceType: "MedicationKnowledge"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationKnowledgeAdministrationGuidelinesDto)
    administrationGuidelines?: MedicationKnowledgeAdministrationGuidelines[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    amount?: Quantity

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    associatedMedication?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    contraindication?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationKnowledgeCostDto)
    cost?: MedicationKnowledgeCost[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    doseForm?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationKnowledgeDrugCharacteristicDto)
    drugCharacteristic?: MedicationKnowledgeDrugCharacteristic[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationKnowledgeIngredientDto)
    ingredient?: MedicationKnowledgeIngredient[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    intendedRoute?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationKnowledgeKineticsDto)
    kinetics?: MedicationKnowledgeKinetics[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    manufacturer?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationKnowledgeMedicineClassificationDto)
    medicineClassification?: MedicationKnowledgeMedicineClassification[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationKnowledgeMonitoringProgramDto)
    monitoringProgram?: MedicationKnowledgeMonitoringProgram[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationKnowledgeMonographDto)
    monograph?: MedicationKnowledgeMonograph[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MedicationKnowledgePackagingDto)
    packaging?: MedicationKnowledgePackaging

    @IsOptional()
    @IsString()
    preparationInstruction?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    productType?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationKnowledgeRegulatoryDto)
    regulatory?: MedicationKnowledgeRegulatory[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicationKnowledgeRelatedMedicationKnowledgeDto)
    relatedMedicationKnowledge?: MedicationKnowledgeRelatedMedicationKnowledge[]

    @IsNotEmpty()
    @IsIn(["active", "inactive", "entered-in-error"])
    status: "active" | "inactive" | "entered-in-error"

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    synonym?: string[]

  }
  export class MedicationRequestDispenseRequestInitialFillDto implements MedicationRequestDispenseRequestInitialFill {
    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    duration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

  }
  export class MedicationRequestDispenseRequestDto implements MedicationRequestDispenseRequest {
    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    dispenseInterval?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    expectedSupplyDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => MedicationRequestDispenseRequestInitialFillDto)
    initialFill?: MedicationRequestDispenseRequestInitialFill

    @IsOptional()
    @IsNumber()
    numberOfRepeatsAllowed?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    performer?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    validityPeriod?: Period

  }
  export class MedicationRequestSubstitutionDto implements MedicationRequestSubstitution {
    @IsNotEmpty()
    @IsBoolean()
    allowedBoolean: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    allowedCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    reason?: CodeableConcept

  }
  export class MedicationRequestDto implements MedicationRequest {
    @IsNotEmpty()
    @IsIn(["MedicationRequest"])
    resourceType: "MedicationRequest"

    @IsOptional()
    @IsString()
    authoredOn?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    courseOfTherapyType?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    detectedIssue?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => MedicationRequestDispenseRequestDto)
    dispenseRequest?: MedicationRequestDispenseRequest

    @IsNotEmpty()
    @IsBoolean()
    doNotPerform: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DosageDto)
    dosageInstruction?: Dosage[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    eventHistory?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    groupIdentifier?: Identifier

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesCanonical?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesUri?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    insurance?: Reference[]

    @IsNotEmpty()
    @IsIn(["proposal", "plan", "order", "original-order", "reflex-order", "filler-order", "instance-order", "option"])
    intent: "proposal" | "plan" | "order" | "original-order" | "reflex-order" | "filler-order" | "instance-order" | "option"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    medicationCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    medicationReference?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    performer?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    performerType?: CodeableConcept

    @IsNotEmpty()
    @IsIn(["routine", "urgent", "asap", "stat"])
    priority: "routine" | "urgent" | "asap" | "stat"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    priorPrescription?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    reasonCode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    reasonReference?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    recorder?: Reference

    @IsNotEmpty()
    @IsBoolean()
    reportedBoolean: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    reportedReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    requester?: Reference

    @IsNotEmpty()
    @IsIn(["active", "entered-in-error", "on-hold", "unknown", "draft", "cancelled", "completed", "stopped"])
    status: "active" | "entered-in-error" | "on-hold" | "unknown" | "draft" | "cancelled" | "completed" | "stopped"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    statusReason?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => MedicationRequestSubstitutionDto)
    substitution?: MedicationRequestSubstitution

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    supportingInformation?: Reference[]

  }
  export class MedicationStatementDto implements MedicationStatement {
    @IsNotEmpty()
    @IsIn(["MedicationStatement"])
    resourceType: "MedicationStatement"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    context?: Reference

    @IsOptional()
    @IsString()
    dateAsserted?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    derivedFrom?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DosageDto)
    dosage?: Dosage[]

    @IsOptional()
    @IsString()
    effectiveDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    informationSource?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    medicationCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    medicationReference?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    partOf?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    reasonCode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    reasonReference?: Reference[]

    @IsNotEmpty()
    @IsIn(["active", "entered-in-error", "on-hold", "unknown", "completed", "stopped", "intended", "not-taken"])
    status: "active" | "entered-in-error" | "on-hold" | "unknown" | "completed" | "stopped" | "intended" | "not-taken"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    statusReason?: CodeableConcept[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

  }
  export class MedicinalProductDefinitionContactDto implements MedicinalProductDefinitionContact {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    contact: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class MedicinalProductDefinitionNameNamePartDto implements MedicinalProductDefinitionNameNamePart {
    @IsNotEmpty()
    @IsString()
    part: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class MedicinalProductDefinitionNameCountryLanguageDto implements MedicinalProductDefinitionNameCountryLanguage {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    country: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    language: CodeableConcept

  }
  export class MedicinalProductDefinitionNameDto implements MedicinalProductDefinitionName {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicinalProductDefinitionNameCountryLanguageDto)
    countryLanguage?: MedicinalProductDefinitionNameCountryLanguage[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicinalProductDefinitionNameNamePartDto)
    namePart?: MedicinalProductDefinitionNameNamePart[]

    @IsNotEmpty()
    @IsString()
    productName: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class MedicinalProductDefinitionCrossReferenceDto implements MedicinalProductDefinitionCrossReference {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    product: CodeableReference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class MedicinalProductDefinitionOperationDto implements MedicinalProductDefinitionOperation {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    confidentialityIndicator?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectiveDate?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    organization?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    type?: CodeableReference

  }
  export class MedicinalProductDefinitionCharacteristicDto implements MedicinalProductDefinitionCharacteristic {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @IsString()
    valueDate?: string

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

  }
  export class MedicinalProductDefinitionDto implements MedicinalProductDefinition {
    @IsNotEmpty()
    @IsIn(["MedicinalProductDefinition"])
    resourceType: "MedicinalProductDefinition"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    additionalMonitoringIndicator?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    attachedDocument?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicinalProductDefinitionCharacteristicDto)
    characteristic?: MedicinalProductDefinitionCharacteristic[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    classification?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    clinicalTrial?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    code?: Coding[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    combinedPharmaceuticalDoseForm?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicinalProductDefinitionContactDto)
    contact?: MedicinalProductDefinitionContact[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicinalProductDefinitionCrossReferenceDto)
    crossReference?: MedicinalProductDefinitionCrossReference[]

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    domain?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    impurity?: CodeableReference[]

    @IsOptional()
    @IsString()
    indication?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    ingredient?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    legalStatusOfSupply?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MarketingStatusDto)
    marketingStatus?: MarketingStatus[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    masterFile?: Reference[]

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicinalProductDefinitionNameDto)
    name: MedicinalProductDefinitionName[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MedicinalProductDefinitionOperationDto)
    operation?: MedicinalProductDefinitionOperation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    packagedMedicinalProduct?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    pediatricUseIndicator?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    route?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    specialMeasures?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    status?: CodeableConcept

    @IsOptional()
    @IsString()
    statusDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsOptional()
    @IsString()
    version?: string

  }
  export class MessageDefinitionFocusDto implements MessageDefinitionFocus {
    @IsNotEmpty()
    @IsString()
    code: string

    @IsOptional()
    @IsString()
    max?: string

    @IsNotEmpty()
    @IsNumber()
    min: number

    @IsOptional()
    @IsString()
    profile?: string

  }
  export class MessageDefinitionAllowedResponseDto implements MessageDefinitionAllowedResponse {
    @IsNotEmpty()
    @IsString()
    message: string

    @IsOptional()
    @IsString()
    situation?: string

  }
  export class MessageDefinitionDto implements MessageDefinition {
    @IsNotEmpty()
    @IsIn(["MessageDefinition"])
    resourceType: "MessageDefinition"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MessageDefinitionAllowedResponseDto)
    allowedResponse?: MessageDefinitionAllowedResponse[]

    @IsOptional()
    @IsString()
    base?: string

    @IsNotEmpty()
    @IsIn(["consequence", "currency", "notification"])
    category: "consequence" | "currency" | "notification"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsNotEmpty()
    @IsString()
    date: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    eventCoding?: Coding

    @IsOptional()
    @IsString()
    eventUri?: string

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MessageDefinitionFocusDto)
    focus?: MessageDefinitionFocus[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    graph?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    parent?: string[]

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    replaces?: string[]

    @IsNotEmpty()
    @IsIn(["always", "on-error", "never", "on-success"])
    responseRequired: "always" | "on-error" | "never" | "on-success"

    @IsNotEmpty()
    @IsIn(["active", "unknown", "draft", "retired"])
    status: "active" | "unknown" | "draft" | "retired"

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

  }
  export class MessageHeaderDestinationDto implements MessageHeaderDestination {
    @IsNotEmpty()
    @IsString()
    endpoint: string

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    receiver?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    target?: Reference

  }
  export class MessageHeaderSourceDto implements MessageHeaderSource {
    @IsOptional()
    @ValidateNested()
    @Type(() => ContactPointDto)
    contact?: ContactPoint

    @IsNotEmpty()
    @IsString()
    endpoint: string

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsString()
    software?: string

    @IsOptional()
    @IsString()
    version?: string

  }
  export class MessageHeaderResponseDto implements MessageHeaderResponse {
    @IsNotEmpty()
    @IsIn(["ok", "transient-error", "fatal-error"])
    code: "ok" | "transient-error" | "fatal-error"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    details?: Reference

    @IsNotEmpty()
    @IsString()
    identifier: string

  }
  export class MessageHeaderDto implements MessageHeader {
    @IsNotEmpty()
    @IsIn(["MessageHeader"])
    resourceType: "MessageHeader"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    author?: Reference

    @IsOptional()
    @IsString()
    definition?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MessageHeaderDestinationDto)
    destination?: MessageHeaderDestination[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    enterer?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    eventCoding?: Coding

    @IsOptional()
    @IsString()
    eventUri?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    focus?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    reason?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => MessageHeaderResponseDto)
    response?: MessageHeaderResponse

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    responsible?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    sender?: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => MessageHeaderSourceDto)
    source: MessageHeaderSource

  }
  export class MolecularSequenceReferenceSeqDto implements MolecularSequenceReferenceSeq {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    chromosome?: CodeableConcept

    @IsOptional()
    @IsString()
    genomeBuild?: string

    @IsNotEmpty()
    @IsIn(["sense", "antisense"])
    orientation: "sense" | "antisense"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    referenceSeqId?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    referenceSeqPointer?: Reference

    @IsOptional()
    @IsString()
    referenceSeqString?: string

    @IsNotEmpty()
    @IsIn(["watson", "crick"])
    strand: "watson" | "crick"

    @IsOptional()
    @IsNumber()
    windowEnd?: number

    @IsOptional()
    @IsNumber()
    windowStart?: number

  }
  export class MolecularSequenceVariantDto implements MolecularSequenceVariant {
    @IsOptional()
    @IsString()
    cigar?: string

    @IsOptional()
    @IsNumber()
    end?: number

    @IsOptional()
    @IsString()
    observedAllele?: string

    @IsOptional()
    @IsString()
    referenceAllele?: string

    @IsOptional()
    @IsNumber()
    start?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    variantPointer?: Reference

  }
  export class MolecularSequenceQualityRocDto implements MolecularSequenceQualityRoc {
    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    fMeasure?: number[]

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    numFN?: number[]

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    numFP?: number[]

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    numTP?: number[]

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    precision?: number[]

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    score?: number[]

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    sensitivity?: number[]

  }
  export class MolecularSequenceQualityDto implements MolecularSequenceQuality {
    @IsOptional()
    @IsNumber()
    end?: number

    @IsOptional()
    @IsNumber()
    fScore?: number

    @IsOptional()
    @IsNumber()
    gtFP?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    method?: CodeableConcept

    @IsOptional()
    @IsNumber()
    precision?: number

    @IsOptional()
    @IsNumber()
    queryFP?: number

    @IsOptional()
    @IsNumber()
    queryTP?: number

    @IsOptional()
    @IsNumber()
    recall?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => MolecularSequenceQualityRocDto)
    roc?: MolecularSequenceQualityRoc

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    score?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    standardSequence?: CodeableConcept

    @IsOptional()
    @IsNumber()
    start?: number

    @IsOptional()
    @IsNumber()
    truthFN?: number

    @IsOptional()
    @IsNumber()
    truthTP?: number

    @IsNotEmpty()
    @IsIn(["unknown", "indel", "snp"])
    type: "unknown" | "indel" | "snp"

  }
  export class MolecularSequenceRepositoryDto implements MolecularSequenceRepository {
    @IsOptional()
    @IsString()
    datasetId?: string

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsString()
    readsetId?: string

    @IsNotEmpty()
    @IsIn(["other", "directlink", "openapi", "login", "oauth"])
    type: "other" | "directlink" | "openapi" | "login" | "oauth"

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsString()
    variantsetId?: string

  }
  export class MolecularSequenceStructureVariantOuterDto implements MolecularSequenceStructureVariantOuter {
    @IsOptional()
    @IsNumber()
    end?: number

    @IsOptional()
    @IsNumber()
    start?: number

  }
  export class MolecularSequenceStructureVariantInnerDto implements MolecularSequenceStructureVariantInner {
    @IsOptional()
    @IsNumber()
    end?: number

    @IsOptional()
    @IsNumber()
    start?: number

  }
  export class MolecularSequenceStructureVariantDto implements MolecularSequenceStructureVariant {
    @IsNotEmpty()
    @IsBoolean()
    exact: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => MolecularSequenceStructureVariantInnerDto)
    inner?: MolecularSequenceStructureVariantInner

    @IsOptional()
    @IsNumber()
    length?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => MolecularSequenceStructureVariantOuterDto)
    outer?: MolecularSequenceStructureVariantOuter

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    variantType?: CodeableConcept

  }
  export class MolecularSequenceDto implements MolecularSequence {
    @IsNotEmpty()
    @IsIn(["MolecularSequence"])
    resourceType: "MolecularSequence"

    @IsNotEmpty()
    @IsNumber()
    coordinateSystem: number

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    device?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsString()
    observedSeq?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    performer?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    pointer?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MolecularSequenceQualityDto)
    quality?: MolecularSequenceQuality[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @IsNumber()
    readCoverage?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => MolecularSequenceReferenceSeqDto)
    referenceSeq?: MolecularSequenceReferenceSeq

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MolecularSequenceRepositoryDto)
    repository?: MolecularSequenceRepository[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    specimen?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MolecularSequenceStructureVariantDto)
    structureVariant?: MolecularSequenceStructureVariant[]

    @IsNotEmpty()
    @IsIn(["aa", "dna", "rna"])
    type: "aa" | "dna" | "rna"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MolecularSequenceVariantDto)
    variant?: MolecularSequenceVariant[]

  }
  export class NamingSystemUniqueIdDto implements NamingSystemUniqueId {
    @IsOptional()
    @IsString()
    comment?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsNotEmpty()
    @IsBoolean()
    preferred: boolean

    @IsNotEmpty()
    @IsIn(["other", "uri", "oid", "uuid"])
    type: "other" | "uri" | "oid" | "uuid"

    @IsNotEmpty()
    @IsString()
    value: string

  }
  export class NamingSystemDto implements NamingSystem {
    @IsNotEmpty()
    @IsIn(["NamingSystem"])
    resourceType: "NamingSystem"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsNotEmpty()
    @IsString()
    date: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsNotEmpty()
    @IsIn(["codesystem", "identifier", "root"])
    kind: "codesystem" | "identifier" | "root"

    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    responsible?: string

    @IsNotEmpty()
    @IsIn(["active", "unknown", "draft", "retired"])
    status: "active" | "unknown" | "draft" | "retired"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => NamingSystemUniqueIdDto)
    uniqueId: NamingSystemUniqueId[]

    @IsOptional()
    @IsString()
    usage?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

  }
  export class NutritionOrderOralDietNutrientDto implements NutritionOrderOralDietNutrient {
    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    amount?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    modifier?: CodeableConcept

  }
  export class NutritionOrderOralDietTextureDto implements NutritionOrderOralDietTexture {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    foodType?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    modifier?: CodeableConcept

  }
  export class NutritionOrderOralDietDto implements NutritionOrderOralDiet {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    fluidConsistencyType?: CodeableConcept[]

    @IsOptional()
    @IsString()
    instruction?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => NutritionOrderOralDietNutrientDto)
    nutrient?: NutritionOrderOralDietNutrient[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TimingDto)
    schedule?: Timing[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => NutritionOrderOralDietTextureDto)
    texture?: NutritionOrderOralDietTexture[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

  }
  export class NutritionOrderSupplementDto implements NutritionOrderSupplement {
    @IsOptional()
    @IsString()
    instruction?: string

    @IsOptional()
    @IsString()
    productName?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TimingDto)
    schedule?: Timing[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class NutritionOrderEnteralFormulaAdministrationDto implements NutritionOrderEnteralFormulaAdministration {
    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    rateQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    rateRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    schedule?: Timing

  }
  export class NutritionOrderEnteralFormulaDto implements NutritionOrderEnteralFormula {
    @IsOptional()
    @IsString()
    additiveProductName?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    additiveType?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => NutritionOrderEnteralFormulaAdministrationDto)
    administration?: NutritionOrderEnteralFormulaAdministration[]

    @IsOptional()
    @IsString()
    administrationInstruction?: string

    @IsOptional()
    @IsString()
    baseFormulaProductName?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    baseFormulaType?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    caloricDensity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    maxVolumeToDeliver?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    routeofAdministration?: CodeableConcept

  }
  export class NutritionOrderDto implements NutritionOrder {
    @IsNotEmpty()
    @IsIn(["NutritionOrder"])
    resourceType: "NutritionOrder"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    allergyIntolerance?: Reference[]

    @IsNotEmpty()
    @IsString()
    dateTime: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => NutritionOrderEnteralFormulaDto)
    enteralFormula?: NutritionOrderEnteralFormula

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    excludeFoodModifier?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    foodPreferenceModifier?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiates?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesCanonical?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesUri?: string[]

    @IsNotEmpty()
    @IsIn(["proposal", "plan", "directive", "order", "original-order", "reflex-order", "filler-order", "instance-order", "option"])
    intent: "proposal" | "plan" | "directive" | "order" | "original-order" | "reflex-order" | "filler-order" | "instance-order" | "option"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => NutritionOrderOralDietDto)
    oralDiet?: NutritionOrderOralDiet

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    orderer?: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient: Reference

    @IsNotEmpty()
    @IsIn(["active", "entered-in-error", "on-hold", "unknown", "draft", "completed", "revoked"])
    status: "active" | "entered-in-error" | "on-hold" | "unknown" | "draft" | "completed" | "revoked"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => NutritionOrderSupplementDto)
    supplement?: NutritionOrderSupplement[]

  }
  export class NutritionProductNutrientDto implements NutritionProductNutrient {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RatioDto)
    amount?: Ratio[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    item?: CodeableReference

  }
  export class NutritionProductIngredientDto implements NutritionProductIngredient {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RatioDto)
    amount?: Ratio[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    item: CodeableReference

  }
  export class NutritionProductProductCharacteristicDto implements NutritionProductProductCharacteristic {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @IsString()
    valueBase64Binary?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

  }
  export class NutritionProductInstanceDto implements NutritionProductInstance {
    @IsOptional()
    @IsString()
    expiry?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsString()
    lotNumber?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

    @IsOptional()
    @IsString()
    useBy?: string

  }
  export class NutritionProductDto implements NutritionProduct {
    @IsNotEmpty()
    @IsIn(["NutritionProduct"])
    resourceType: "NutritionProduct"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => NutritionProductIngredientDto)
    ingredient?: NutritionProductIngredient[]

    @IsOptional()
    @ValidateNested()
    @Type(() => NutritionProductInstanceDto)
    instance?: NutritionProductInstance

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableReferenceDto)
    knownAllergen?: CodeableReference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    manufacturer?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => NutritionProductNutrientDto)
    nutrient?: NutritionProductNutrient[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => NutritionProductProductCharacteristicDto)
    productCharacteristic?: NutritionProductProductCharacteristic[]

    @IsNotEmpty()
    @IsIn(["active", "inactive", "entered-in-error"])
    status: "active" | "inactive" | "entered-in-error"

  }
  export class ObservationReferenceRangeDto implements ObservationReferenceRange {
    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    age?: Range

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    appliesTo?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    high?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    low?: Quantity

    @IsOptional()
    @IsString()
    text?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class ObservationComponentDto implements ObservationComponent {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    dataAbsentReason?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    interpretation?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ObservationReferenceRangeDto)
    referenceRange?: ObservationReferenceRange[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @IsString()
    valueString?: string

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    valueRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => SampledDataDto)
    valueSampledData?: SampledData

    @IsOptional()
    @IsString()
    valueTime?: string

    @IsOptional()
    @IsString()
    valueDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    valuePeriod?: Period

  }
  export class ObservationDto implements Observation {
    @IsNotEmpty()
    @IsIn(["Observation"])
    resourceType: "Observation"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    bodySite?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ObservationComponentDto)
    component?: ObservationComponent[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    dataAbsentReason?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    derivedFrom?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    device?: Reference

    @IsOptional()
    @IsString()
    effectiveDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    effectiveTiming?: Timing

    @IsOptional()
    @IsString()
    effectiveInstant?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    focus?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    hasMember?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    interpretation?: CodeableConcept[]

    @IsOptional()
    @IsString()
    issued?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    method?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    partOf?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    performer?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ObservationReferenceRangeDto)
    referenceRange?: ObservationReferenceRange[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    specimen?: Reference

    @IsNotEmpty()
    @IsIn(["entered-in-error", "unknown", "cancelled", "preliminary", "final", "amended", "registered", "corrected"])
    status: "entered-in-error" | "unknown" | "cancelled" | "preliminary" | "final" | "amended" | "registered" | "corrected"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @IsString()
    valueString?: string

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    valueRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => SampledDataDto)
    valueSampledData?: SampledData

    @IsOptional()
    @IsString()
    valueTime?: string

    @IsOptional()
    @IsString()
    valueDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    valuePeriod?: Period

  }
  export class ObservationDefinitionQuantitativeDetailsDto implements ObservationDefinitionQuantitativeDetails {
    @IsOptional()
    @IsNumber()
    conversionFactor?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    customaryUnit?: CodeableConcept

    @IsOptional()
    @IsNumber()
    decimalPrecision?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    unit?: CodeableConcept

  }
  export class ObservationDefinitionQualifiedIntervalDto implements ObservationDefinitionQualifiedInterval {
    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    age?: Range

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    appliesTo?: CodeableConcept[]

    @IsNotEmpty()
    @IsIn(["reference", "critical", "absolute"])
    category: "reference" | "critical" | "absolute"

    @IsOptional()
    @IsString()
    condition?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    context?: CodeableConcept

    @IsNotEmpty()
    @IsIn(["other", "unknown", "male", "female"])
    gender: "other" | "unknown" | "male" | "female"

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    gestationalAge?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    range?: Range

  }
  export class ObservationDefinitionDto implements ObservationDefinition {
    @IsNotEmpty()
    @IsIn(["ObservationDefinition"])
    resourceType: "ObservationDefinition"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    abnormalCodedValueSet?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    criticalCodedValueSet?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    method?: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    multipleResultsAllowed: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    normalCodedValueSet?: Reference

    @IsOptional()
    @IsArray()
    @IsIn(["string", "boolean", "integer", "dateTime", "Quantity", "CodeableConcept", "Range", "Ratio", "SampledData", "time", "Period"], { each: true })
    permittedDataType?: ("string" | "boolean" | "integer" | "dateTime" | "Quantity" | "CodeableConcept" | "Range" | "Ratio" | "SampledData" | "time" | "Period")[]

    @IsOptional()
    @IsString()
    preferredReportName?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ObservationDefinitionQualifiedIntervalDto)
    qualifiedInterval?: ObservationDefinitionQualifiedInterval[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ObservationDefinitionQuantitativeDetailsDto)
    quantitativeDetails?: ObservationDefinitionQuantitativeDetails

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    validCodedValueSet?: Reference

  }
  export class OperationDefinitionParameterBindingDto implements OperationDefinitionParameterBinding {
    @IsNotEmpty()
    @IsIn(["required", "extensible", "preferred", "example"])
    strength: "required" | "extensible" | "preferred" | "example"

    @IsNotEmpty()
    @IsString()
    valueSet: string

  }
  export class OperationDefinitionParameterReferencedFromDto implements OperationDefinitionParameterReferencedFrom {
    @IsNotEmpty()
    @IsString()
    source: string

    @IsOptional()
    @IsString()
    sourceId?: string

  }
  export class OperationDefinitionParameterDto implements OperationDefinitionParameter {
    @IsOptional()
    @ValidateNested()
    @Type(() => OperationDefinitionParameterBindingDto)
    binding?: OperationDefinitionParameterBinding

    @IsOptional()
    @IsString()
    documentation?: string

    @IsNotEmpty()
    @IsString()
    max: string

    @IsNotEmpty()
    @IsNumber()
    min: number

    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => OperationDefinitionParameterDto)
    part?: OperationDefinitionParameter[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => OperationDefinitionParameterReferencedFromDto)
    referencedFrom?: OperationDefinitionParameterReferencedFrom[]

    @IsNotEmpty()
    @IsIn(["string", "number", "date", "token", "reference", "composite", "quantity", "uri", "special"])
    searchType: "string" | "number" | "date" | "token" | "reference" | "composite" | "quantity" | "uri" | "special"

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    targetProfile?: string[]

    @IsOptional()
    @IsString()
    type?: string

    @IsNotEmpty()
    @IsIn(["in", "out"])
    use: "in" | "out"

  }
  export class OperationDefinitionOverloadDto implements OperationDefinitionOverload {
    @IsOptional()
    @IsString()
    comment?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    parameterName?: string[]

  }
  export class OperationDefinitionDto implements OperationDefinition {
    @IsNotEmpty()
    @IsIn(["OperationDefinition"])
    resourceType: "OperationDefinition"

    @IsNotEmpty()
    @IsBoolean()
    affectsState: boolean

    @IsOptional()
    @IsString()
    base?: string

    @IsNotEmpty()
    @IsString()
    code: string

    @IsOptional()
    @IsString()
    comment?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsString()
    inputProfile?: string

    @IsNotEmpty()
    @IsBoolean()
    instance: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsNotEmpty()
    @IsIn(["operation", "query"])
    kind: "operation" | "query"

    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @IsString()
    outputProfile?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => OperationDefinitionOverloadDto)
    overload?: OperationDefinitionOverload[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => OperationDefinitionParameterDto)
    parameter?: OperationDefinitionParameter[]

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    resource?: string[]

    @IsNotEmpty()
    @IsIn(["active", "unknown", "draft", "retired"])
    status: "active" | "unknown" | "draft" | "retired"

    @IsNotEmpty()
    @IsBoolean()
    system: boolean

    @IsOptional()
    @IsString()
    title?: string

    @IsNotEmpty()
    @IsBoolean()
    type: boolean

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

  }
  export class OperationOutcomeIssueDto implements OperationOutcomeIssue {
    @IsNotEmpty()
    @IsString()
    code: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    details?: CodeableConcept

    @IsOptional()
    @IsString()
    diagnostics?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    expression?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    location?: string[]

    @IsNotEmpty()
    @IsIn(["error", "warning", "fatal", "information"])
    severity: "error" | "warning" | "fatal" | "information"

  }
  export class OperationOutcomeDto implements OperationOutcome {
    @IsNotEmpty()
    @IsIn(["OperationOutcome"])
    resourceType: "OperationOutcome"

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => OperationOutcomeIssueDto)
    issue: OperationOutcomeIssue[]

  }
  export class OrganizationContactDto implements OrganizationContact {
    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    address?: Address

    @IsOptional()
    @ValidateNested()
    @Type(() => HumanNameDto)
    name?: HumanName

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    purpose?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactPointDto)
    telecom?: ContactPoint[]

  }
  export class OrganizationDto implements Organization {
    @IsNotEmpty()
    @IsIn(["Organization"])
    resourceType: "Organization"

    @IsNotEmpty()
    @IsBoolean()
    active: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AddressDto)
    address?: Address[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    alias?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => OrganizationContactDto)
    contact?: OrganizationContact[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    endpoint?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    partOf?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactPointDto)
    telecom?: ContactPoint[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

  }
  export class OrganizationAffiliationDto implements OrganizationAffiliation {
    @IsNotEmpty()
    @IsIn(["OrganizationAffiliation"])
    resourceType: "OrganizationAffiliation"

    @IsNotEmpty()
    @IsBoolean()
    active: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    endpoint?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    healthcareService?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    location?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    network?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    organization?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    participatingOrganization?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    specialty?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactPointDto)
    telecom?: ContactPoint[]

  }
  export class PackagedProductDefinitionLegalStatusOfSupplyDto implements PackagedProductDefinitionLegalStatusOfSupply {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept

  }
  export class PackagedProductDefinitionPackageShelfLifeStorageDto implements PackagedProductDefinitionPackageShelfLifeStorage {
    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    periodDuration?: Duration

    @IsOptional()
    @IsString()
    periodString?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    specialPrecautionsForStorage?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class PackagedProductDefinitionPackagePropertyDto implements PackagedProductDefinitionPackageProperty {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @IsString()
    valueDate?: string

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

  }
  export class PackagedProductDefinitionPackageContainedItemDto implements PackagedProductDefinitionPackageContainedItem {
    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    amount?: Quantity

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    item: CodeableReference

  }
  export class PackagedProductDefinitionPackageDto implements PackagedProductDefinitionPackage {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    alternateMaterial?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PackagedProductDefinitionPackageContainedItemDto)
    containedItem?: PackagedProductDefinitionPackageContainedItem[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    manufacturer?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    material?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PackagedProductDefinitionPackageDto)
    package?: PackagedProductDefinitionPackage[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PackagedProductDefinitionPackagePropertyDto)
    property?: PackagedProductDefinitionPackageProperty[]

    @IsOptional()
    @IsNumber()
    quantity?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PackagedProductDefinitionPackageShelfLifeStorageDto)
    shelfLifeStorage?: PackagedProductDefinitionPackageShelfLifeStorage[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class PackagedProductDefinitionDto implements PackagedProductDefinition {
    @IsNotEmpty()
    @IsIn(["PackagedProductDefinition"])
    resourceType: "PackagedProductDefinition"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    characteristic?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => QuantityDto)
    containedItemQuantity?: Quantity[]

    @IsNotEmpty()
    @IsBoolean()
    copackagedIndicator: boolean

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PackagedProductDefinitionLegalStatusOfSupplyDto)
    legalStatusOfSupply?: PackagedProductDefinitionLegalStatusOfSupply[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    manufacturer?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => MarketingStatusDto)
    marketingStatus?: MarketingStatus[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PackagedProductDefinitionPackageDto)
    package?: PackagedProductDefinitionPackage

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    packageFor?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    status?: CodeableConcept

    @IsOptional()
    @IsString()
    statusDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class ParametersParameterDto implements ParametersParameter {
    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ParametersParameterDto)
    part?: ParametersParameter[]

    @IsNotEmpty()
    resource: Account | ActivityDefinition | AdministrableProductDefinition | AdverseEvent | AllergyIntolerance | Appointment | AppointmentResponse | AuditEvent | Basic | Binary | BiologicallyDerivedProduct | BodyStructure | Bundle<FhirResource> | CapabilityStatement | CarePlan | CareTeam | CatalogEntry | ChargeItem | ChargeItemDefinition | Citation | Claim | ClaimResponse | ClinicalImpression | ClinicalUseDefinition | CodeSystem | Communication | CommunicationRequest | CompartmentDefinition | Composition | ConceptMap | Condition | Consent | Contract | Coverage | CoverageEligibilityRequest | CoverageEligibilityResponse | DetectedIssue | Device | DeviceDefinition | DeviceMetric | DeviceRequest | DeviceUseStatement | DiagnosticReport | DocumentManifest | DocumentReference | Encounter | Endpoint | EnrollmentRequest | EnrollmentResponse | EpisodeOfCare | EventDefinition | Evidence | EvidenceReport | EvidenceVariable | ExampleScenario | ExplanationOfBenefit | FamilyMemberHistory | Flag | Goal | GraphDefinition | Group | GuidanceResponse | HealthcareService | ImagingStudy | Immunization | ImmunizationEvaluation | ImmunizationRecommendation | ImplementationGuide | Ingredient | InsurancePlan | Invoice | Library | Linkage | List | Location | ManufacturedItemDefinition | Measure | MeasureReport | Media | Medication | MedicationAdministration | MedicationDispense | MedicationKnowledge | MedicationRequest | MedicationStatement | MedicinalProductDefinition | MessageDefinition | MessageHeader | MolecularSequence | NamingSystem | NutritionOrder | NutritionProduct | Observation | ObservationDefinition | OperationDefinition | OperationOutcome | Organization | OrganizationAffiliation | PackagedProductDefinition | Parameters | Patient | PaymentNotice | PaymentReconciliation | Person | PlanDefinition | Practitioner | PractitionerRole | Procedure | Provenance | Questionnaire | QuestionnaireResponse | RegulatedAuthorization | RelatedPerson | RequestGroup | ResearchDefinition | ResearchElementDefinition | ResearchStudy | ResearchSubject | RiskAssessment | Schedule | SearchParameter | ServiceRequest | Slot | Specimen | SpecimenDefinition | StructureDefinition | StructureMap | Subscription | SubscriptionStatus | SubscriptionTopic | Substance | SubstanceDefinition | SupplyDelivery | SupplyRequest | Task | TerminologyCapabilities | TestReport | TestScript | ValueSet | VerificationResult | VisionPrescription

    @IsOptional()
    @IsString()
    valueBase64Binary?: string

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsString()
    valueCanonical?: string

    @IsOptional()
    @IsString()
    valueCode?: string

    @IsOptional()
    @IsString()
    valueDate?: string

    @IsOptional()
    @IsString()
    valueDateTime?: string

    @IsOptional()
    @IsNumber()
    valueDecimal?: number

    @IsOptional()
    @IsString()
    valueId?: string

    @IsOptional()
    @IsString()
    valueInstant?: string

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsOptional()
    @IsString()
    valueMarkdown?: string

    @IsOptional()
    @IsString()
    valueOid?: string

    @IsOptional()
    @IsNumber()
    valuePositiveInt?: number

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @IsString()
    valueTime?: string

    @IsOptional()
    @IsNumber()
    valueUnsignedInt?: number

    @IsOptional()
    @IsString()
    valueUri?: string

    @IsOptional()
    @IsString()
    valueUrl?: string

    @IsOptional()
    @IsString()
    valueUuid?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    valueAddress?: Address

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    valueAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => AnnotationDto)
    valueAnnotation?: Annotation

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    valueCoding?: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactPointDto)
    valueContactPoint?: ContactPoint

    @IsOptional()
    @ValidateNested()
    @Type(() => CountDto)
    valueCount?: Count

    @IsOptional()
    @ValidateNested()
    @Type(() => DistanceDto)
    valueDistance?: Distance

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    valueDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => HumanNameDto)
    valueHumanName?: HumanName

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    valueIdentifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    valueMoney?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    valuePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    valueRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => SampledDataDto)
    valueSampledData?: SampledData

    @IsOptional()
    @ValidateNested()
    @Type(() => SignatureDto)
    valueSignature?: Signature

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    valueTiming?: Timing

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactDetailDto)
    valueContactDetail?: ContactDetail

    @IsOptional()
    @ValidateNested()
    @Type(() => ContributorDto)
    valueContributor?: Contributor

    @IsOptional()
    @ValidateNested()
    @Type(() => DataRequirementDto)
    valueDataRequirement?: DataRequirement

    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    valueExpression?: Expression

    @IsOptional()
    @ValidateNested()
    @Type(() => ParameterDefinitionDto)
    valueParameterDefinition?: ParameterDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => RelatedArtifactDto)
    valueRelatedArtifact?: RelatedArtifact

    @IsOptional()
    @ValidateNested()
    @Type(() => TriggerDefinitionDto)
    valueTriggerDefinition?: TriggerDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => UsageContextDto)
    valueUsageContext?: UsageContext

    @IsOptional()
    @ValidateNested()
    @Type(() => DosageDto)
    valueDosage?: Dosage

    @IsOptional()
    @ValidateNested()
    @Type(() => MetaDto)
    valueMeta?: Meta

  }
  export class ParametersDto implements Parameters {
    @IsNotEmpty()
    @IsIn(["Parameters"])
    resourceType: "Parameters"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ParametersParameterDto)
    parameter?: ParametersParameter[]

  }
  export class PatientContactDto implements PatientContact {
    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    address?: Address

    @IsNotEmpty()
    @IsIn(["other", "unknown", "male", "female"])
    gender: "other" | "unknown" | "male" | "female"

    @IsOptional()
    @ValidateNested()
    @Type(() => HumanNameDto)
    name?: HumanName

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    organization?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    relationship?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactPointDto)
    telecom?: ContactPoint[]

  }
  export class PatientCommunicationDto implements PatientCommunication {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    language: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    preferred: boolean

  }
  export class PatientLinkDto implements PatientLink {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    other: Reference

    @IsNotEmpty()
    @IsIn(["replaces", "replaced-by", "refer", "seealso"])
    type: "replaces" | "replaced-by" | "refer" | "seealso"

  }
  export class PatientDto implements Patient {
    @IsNotEmpty()
    @IsIn(["Patient"])
    resourceType: "Patient"

    @IsNotEmpty()
    @IsBoolean()
    active: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AddressDto)
    address?: Address[]

    @IsOptional()
    @IsString()
    birthDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PatientCommunicationDto)
    communication?: PatientCommunication[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PatientContactDto)
    contact?: PatientContact[]

    @IsNotEmpty()
    @IsBoolean()
    deceasedBoolean: boolean

    @IsOptional()
    @IsString()
    deceasedDateTime?: string

    @IsNotEmpty()
    @IsIn(["other", "unknown", "male", "female"])
    gender: "other" | "unknown" | "male" | "female"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    generalPractitioner?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PatientLinkDto)
    link?: PatientLink[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    managingOrganization?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    maritalStatus?: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    multipleBirthBoolean: boolean

    @IsOptional()
    @IsNumber()
    multipleBirthInteger?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => HumanNameDto)
    name?: HumanName[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AttachmentDto)
    photo?: Attachment[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactPointDto)
    telecom?: ContactPoint[]

  }
  export class PaymentNoticeDto implements PaymentNotice {
    @IsNotEmpty()
    @IsIn(["PaymentNotice"])
    resourceType: "PaymentNotice"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => MoneyDto)
    amount: Money

    @IsNotEmpty()
    @IsString()
    created: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    payee?: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    payment: Reference

    @IsOptional()
    @IsString()
    paymentDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    paymentStatus?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    provider?: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    recipient: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    request?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    response?: Reference

    @IsNotEmpty()
    @IsIn(["active", "entered-in-error", "draft", "cancelled"])
    status: "active" | "entered-in-error" | "draft" | "cancelled"

  }
  export class PaymentReconciliationDetailDto implements PaymentReconciliationDetail {
    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    amount?: Money

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    payee?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    predecessor?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    request?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    response?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    responsible?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    submitter?: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class PaymentReconciliationProcessNoteDto implements PaymentReconciliationProcessNote {
    @IsOptional()
    @IsString()
    text?: string

    @IsNotEmpty()
    @IsIn(["display", "print", "printoper"])
    type: "display" | "print" | "printoper"

  }
  export class PaymentReconciliationDto implements PaymentReconciliation {
    @IsNotEmpty()
    @IsIn(["PaymentReconciliation"])
    resourceType: "PaymentReconciliation"

    @IsNotEmpty()
    @IsString()
    created: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PaymentReconciliationDetailDto)
    detail?: PaymentReconciliationDetail[]

    @IsOptional()
    @IsString()
    disposition?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    formCode?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsNotEmpty()
    @IsIn(["error", "queued", "complete", "partial"])
    outcome: "error" | "queued" | "complete" | "partial"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => MoneyDto)
    paymentAmount: Money

    @IsNotEmpty()
    @IsString()
    paymentDate: string

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    paymentIdentifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    paymentIssuer?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PaymentReconciliationProcessNoteDto)
    processNote?: PaymentReconciliationProcessNote[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    request?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    requestor?: Reference

    @IsNotEmpty()
    @IsIn(["active", "entered-in-error", "draft", "cancelled"])
    status: "active" | "entered-in-error" | "draft" | "cancelled"

  }
  export class PersonLinkDto implements PersonLink {
    @IsNotEmpty()
    @IsIn(["level1", "level2", "level3", "level4"])
    assurance: "level1" | "level2" | "level3" | "level4"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    target: Reference

  }
  export class PersonDto implements Person {
    @IsNotEmpty()
    @IsIn(["Person"])
    resourceType: "Person"

    @IsNotEmpty()
    @IsBoolean()
    active: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AddressDto)
    address?: Address[]

    @IsOptional()
    @IsString()
    birthDate?: string

    @IsNotEmpty()
    @IsIn(["other", "unknown", "male", "female"])
    gender: "other" | "unknown" | "male" | "female"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PersonLinkDto)
    link?: PersonLink[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    managingOrganization?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => HumanNameDto)
    name?: HumanName[]

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    photo?: Attachment

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactPointDto)
    telecom?: ContactPoint[]

  }
  export class PlanDefinitionGoalTargetDto implements PlanDefinitionGoalTarget {
    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    detailQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    detailRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    detailCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    due?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    measure?: CodeableConcept

  }
  export class PlanDefinitionGoalDto implements PlanDefinitionGoal {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    addresses?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    description: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    documentation?: RelatedArtifact[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    priority?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    start?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PlanDefinitionGoalTargetDto)
    target?: PlanDefinitionGoalTarget[]

  }
  export class PlanDefinitionActionConditionDto implements PlanDefinitionActionCondition {
    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    expression?: Expression

    @IsNotEmpty()
    @IsIn(["applicability", "start", "stop"])
    kind: "applicability" | "start" | "stop"

  }
  export class PlanDefinitionActionRelatedActionDto implements PlanDefinitionActionRelatedAction {
    @IsNotEmpty()
    @IsString()
    actionId: string

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    offsetDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    offsetRange?: Range

    @IsNotEmpty()
    @IsIn(["before-start", "before", "before-end", "concurrent-with-start", "concurrent", "concurrent-with-end", "after-start", "after", "after-end"])
    relationship: "before-start" | "before" | "before-end" | "concurrent-with-start" | "concurrent" | "concurrent-with-end" | "after-start" | "after" | "after-end"

  }
  export class PlanDefinitionActionParticipantDto implements PlanDefinitionActionParticipant {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    role?: CodeableConcept

    @IsNotEmpty()
    @IsIn(["patient", "practitioner", "related-person", "device"])
    type: "patient" | "practitioner" | "related-person" | "device"

  }
  export class PlanDefinitionActionDynamicValueDto implements PlanDefinitionActionDynamicValue {
    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    expression?: Expression

    @IsOptional()
    @IsString()
    path?: string

  }
  export class PlanDefinitionActionDto implements PlanDefinitionAction {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PlanDefinitionActionDto)
    action?: PlanDefinitionAction[]

    @IsNotEmpty()
    @IsIn(["single", "multiple"])
    cardinalityBehavior: "single" | "multiple"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PlanDefinitionActionConditionDto)
    condition?: PlanDefinitionActionCondition[]

    @IsOptional()
    @IsString()
    definitionCanonical?: string

    @IsOptional()
    @IsString()
    definitionUri?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    documentation?: RelatedArtifact[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PlanDefinitionActionDynamicValueDto)
    dynamicValue?: PlanDefinitionActionDynamicValue[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    goalId?: string[]

    @IsNotEmpty()
    @IsIn(["visual-group", "logical-group", "sentence-group"])
    groupingBehavior: "visual-group" | "logical-group" | "sentence-group"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DataRequirementDto)
    input?: DataRequirement[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => DataRequirementDto)
    output?: DataRequirement[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PlanDefinitionActionParticipantDto)
    participant?: PlanDefinitionActionParticipant[]

    @IsNotEmpty()
    @IsIn(["yes", "no"])
    precheckBehavior: "yes" | "no"

    @IsOptional()
    @IsString()
    prefix?: string

    @IsNotEmpty()
    @IsIn(["routine", "urgent", "asap", "stat"])
    priority: "routine" | "urgent" | "asap" | "stat"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    reason?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PlanDefinitionActionRelatedActionDto)
    relatedAction?: PlanDefinitionActionRelatedAction[]

    @IsNotEmpty()
    @IsIn(["must", "could", "must-unless-documented"])
    requiredBehavior: "must" | "could" | "must-unless-documented"

    @IsNotEmpty()
    @IsIn(["any", "all", "all-or-none", "exactly-one", "at-most-one", "one-or-more"])
    selectionBehavior: "any" | "all" | "all-or-none" | "exactly-one" | "at-most-one" | "one-or-more"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    subjectCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subjectReference?: Reference

    @IsOptional()
    @IsString()
    subjectCanonical?: string

    @IsOptional()
    @IsString()
    textEquivalent?: string

    @IsOptional()
    @IsString()
    timingDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    timingAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    timingPeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    timingDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    timingRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    timingTiming?: Timing

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsString()
    transform?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TriggerDefinitionDto)
    trigger?: TriggerDefinition[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class PlanDefinitionDto implements PlanDefinition {
    @IsNotEmpty()
    @IsIn(["PlanDefinition"])
    resourceType: "PlanDefinition"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PlanDefinitionActionDto)
    action?: PlanDefinitionAction[]

    @IsOptional()
    @IsString()
    approvalDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    author?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    editor?: ContactDetail[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    endorser?: ContactDetail[]

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PlanDefinitionGoalDto)
    goal?: PlanDefinitionGoal[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    lastReviewDate?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    library?: string[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    relatedArtifact?: RelatedArtifact[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    reviewer?: ContactDetail[]

    @IsNotEmpty()
    @IsIn(["active", "unknown", "draft", "retired"])
    status: "active" | "unknown" | "draft" | "retired"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    subjectCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subjectReference?: Reference

    @IsOptional()
    @IsString()
    subjectCanonical?: string

    @IsOptional()
    @IsString()
    subtitle?: string

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    topic?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsString()
    usage?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

  }
  export class PractitionerQualificationDto implements PractitionerQualification {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    issuer?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

  }
  export class PractitionerDto implements Practitioner {
    @IsNotEmpty()
    @IsIn(["Practitioner"])
    resourceType: "Practitioner"

    @IsNotEmpty()
    @IsBoolean()
    active: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AddressDto)
    address?: Address[]

    @IsOptional()
    @IsString()
    birthDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    communication?: CodeableConcept[]

    @IsNotEmpty()
    @IsIn(["other", "unknown", "male", "female"])
    gender: "other" | "unknown" | "male" | "female"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => HumanNameDto)
    name?: HumanName[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AttachmentDto)
    photo?: Attachment[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PractitionerQualificationDto)
    qualification?: PractitionerQualification[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactPointDto)
    telecom?: ContactPoint[]

  }
  export class PractitionerRoleAvailableTimeDto implements PractitionerRoleAvailableTime {
    @IsNotEmpty()
    @IsBoolean()
    allDay: boolean

    @IsOptional()
    @IsString()
    availableEndTime?: string

    @IsOptional()
    @IsString()
    availableStartTime?: string

    @IsOptional()
    @IsArray()
    @IsIn(["mon", "tue", "wed", "thu", "fri", "sat", "sun"], { each: true })
    daysOfWeek?: ("mon" | "tue" | "wed" | "thu" | "fri" | "sat" | "sun")[]

  }
  export class PractitionerRoleNotAvailableDto implements PractitionerRoleNotAvailable {
    @IsNotEmpty()
    @IsString()
    description: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    during?: Period

  }
  export class PractitionerRoleDto implements PractitionerRole {
    @IsNotEmpty()
    @IsIn(["PractitionerRole"])
    resourceType: "PractitionerRole"

    @IsNotEmpty()
    @IsBoolean()
    active: boolean

    @IsOptional()
    @IsString()
    availabilityExceptions?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PractitionerRoleAvailableTimeDto)
    availableTime?: PractitionerRoleAvailableTime[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    endpoint?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    healthcareService?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    location?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PractitionerRoleNotAvailableDto)
    notAvailable?: PractitionerRoleNotAvailable[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    organization?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    practitioner?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    specialty?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactPointDto)
    telecom?: ContactPoint[]

  }
  export class ProcedurePerformerDto implements ProcedurePerformer {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    actor: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    function?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    onBehalfOf?: Reference

  }
  export class ProcedureFocalDeviceDto implements ProcedureFocalDevice {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    action?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    manipulated: Reference

  }
  export class ProcedureDto implements Procedure {
    @IsNotEmpty()
    @IsIn(["Procedure"])
    resourceType: "Procedure"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    asserter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    bodySite?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    complication?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    complicationDetail?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ProcedureFocalDeviceDto)
    focalDevice?: ProcedureFocalDevice[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    followUp?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesCanonical?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesUri?: string[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    location?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    outcome?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    partOf?: Reference[]

    @IsOptional()
    @IsString()
    performedDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    performedPeriod?: Period

    @IsOptional()
    @IsString()
    performedString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    performedAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    performedRange?: Range

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ProcedurePerformerDto)
    performer?: ProcedurePerformer[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    reasonCode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    reasonReference?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    recorder?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    report?: Reference[]

    @IsNotEmpty()
    @IsIn(["entered-in-error", "on-hold", "unknown", "in-progress", "completed", "stopped", "preparation", "not-done"])
    status: "entered-in-error" | "on-hold" | "unknown" | "in-progress" | "completed" | "stopped" | "preparation" | "not-done"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    statusReason?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    usedCode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    usedReference?: Reference[]

  }
  export class ProvenanceAgentDto implements ProvenanceAgent {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    onBehalfOf?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    role?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    who: Reference

  }
  export class ProvenanceEntityDto implements ProvenanceEntity {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ProvenanceAgentDto)
    agent?: ProvenanceAgent[]

    @IsNotEmpty()
    @IsIn(["source", "derivation", "revision", "quotation", "removal"])
    role: "source" | "derivation" | "revision" | "quotation" | "removal"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    what: Reference

  }
  export class ProvenanceDto implements Provenance {
    @IsNotEmpty()
    @IsIn(["Provenance"])
    resourceType: "Provenance"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    activity?: CodeableConcept

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ProvenanceAgentDto)
    agent: ProvenanceAgent[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ProvenanceEntityDto)
    entity?: ProvenanceEntity[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    location?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    occurredPeriod?: Period

    @IsOptional()
    @IsString()
    occurredDateTime?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    policy?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    reason?: CodeableConcept[]

    @IsNotEmpty()
    @IsString()
    recorded: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SignatureDto)
    signature?: Signature[]

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    target: Reference[]

  }
  export class QuestionnaireItemEnableWhenDto implements QuestionnaireItemEnableWhen {
    @IsNotEmpty()
    @IsBoolean()
    answerBoolean: boolean

    @IsOptional()
    @IsNumber()
    answerDecimal?: number

    @IsOptional()
    @IsNumber()
    answerInteger?: number

    @IsOptional()
    @IsString()
    answerDate?: string

    @IsOptional()
    @IsString()
    answerDateTime?: string

    @IsOptional()
    @IsString()
    answerTime?: string

    @IsOptional()
    @IsString()
    answerString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    answerCoding?: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    answerQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    answerReference?: Reference

    @IsNotEmpty()
    @IsIn(["exists", "<", "<=", ">=", ">", "=", "!="])
    operator: "exists" | "<" | "<=" | ">=" | ">" | "=" | "!="

    @IsNotEmpty()
    @IsString()
    question: string

  }
  export class QuestionnaireItemAnswerOptionDto implements QuestionnaireItemAnswerOption {
    @IsNotEmpty()
    @IsBoolean()
    initialSelected: boolean

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsOptional()
    @IsString()
    valueDate?: string

    @IsOptional()
    @IsString()
    valueTime?: string

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    valueCoding?: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

  }
  export class QuestionnaireItemInitialDto implements QuestionnaireItemInitial {
    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsNumber()
    valueDecimal?: number

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsOptional()
    @IsString()
    valueDate?: string

    @IsOptional()
    @IsString()
    valueDateTime?: string

    @IsOptional()
    @IsString()
    valueTime?: string

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @IsString()
    valueUri?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    valueCoding?: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

  }
  export class QuestionnaireItemDto implements QuestionnaireItem {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => QuestionnaireItemAnswerOptionDto)
    answerOption?: QuestionnaireItemAnswerOption[]

    @IsOptional()
    @IsString()
    answerValueSet?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    code?: Coding[]

    @IsOptional()
    @IsString()
    definition?: string

    @IsNotEmpty()
    @IsIn(["any", "all"])
    enableBehavior: "any" | "all"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => QuestionnaireItemEnableWhenDto)
    enableWhen?: QuestionnaireItemEnableWhen[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => QuestionnaireItemInitialDto)
    initial?: QuestionnaireItemInitial[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => QuestionnaireItemDto)
    item?: QuestionnaireItem[]

    @IsNotEmpty()
    @IsString()
    linkId: string

    @IsOptional()
    @IsNumber()
    maxLength?: number

    @IsOptional()
    @IsString()
    prefix?: string

    @IsNotEmpty()
    @IsBoolean()
    readOnly: boolean

    @IsNotEmpty()
    @IsBoolean()
    repeats: boolean

    @IsNotEmpty()
    @IsBoolean()
    required: boolean

    @IsOptional()
    @IsString()
    text?: string

    @IsNotEmpty()
    @IsIn(["string", "boolean", "url", "date", "reference", "quantity", "display", "integer", "dateTime", "decimal", "time", "group", "question", "text", "choice", "open-choice", "attachment"])
    type: "string" | "boolean" | "url" | "date" | "reference" | "quantity" | "display" | "integer" | "dateTime" | "decimal" | "time" | "group" | "question" | "text" | "choice" | "open-choice" | "attachment"

  }
  export class QuestionnaireDto implements Questionnaire {
    @IsNotEmpty()
    @IsIn(["Questionnaire"])
    resourceType: "Questionnaire"

    @IsOptional()
    @IsString()
    approvalDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    code?: Coding[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    derivedFrom?: string[]

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => QuestionnaireItemDto)
    item?: QuestionnaireItem[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    lastReviewDate?: string

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsNotEmpty()
    @IsIn(["active", "unknown", "draft", "retired"])
    status: "active" | "unknown" | "draft" | "retired"

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    subjectType?: string[]

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

  }
  export class QuestionnaireResponseItemAnswerDto implements QuestionnaireResponseItemAnswer {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => QuestionnaireResponseItemDto)
    item?: QuestionnaireResponseItem[]

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsNumber()
    valueDecimal?: number

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsOptional()
    @IsString()
    valueDate?: string

    @IsOptional()
    @IsString()
    valueDateTime?: string

    @IsOptional()
    @IsString()
    valueTime?: string

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @IsString()
    valueUri?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    valueCoding?: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

  }
  export class QuestionnaireResponseItemDto implements QuestionnaireResponseItem {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => QuestionnaireResponseItemAnswerDto)
    answer?: QuestionnaireResponseItemAnswer[]

    @IsOptional()
    @IsString()
    definition?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => QuestionnaireResponseItemDto)
    item?: QuestionnaireResponseItem[]

    @IsNotEmpty()
    @IsString()
    linkId: string

    @IsOptional()
    @IsString()
    text?: string

  }
  export class QuestionnaireResponseDto implements QuestionnaireResponse {
    @IsNotEmpty()
    @IsIn(["QuestionnaireResponse"])
    resourceType: "QuestionnaireResponse"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    author?: Reference

    @IsOptional()
    @IsString()
    authored?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => QuestionnaireResponseItemDto)
    item?: QuestionnaireResponseItem[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    partOf?: Reference[]

    @IsOptional()
    @IsString()
    questionnaire?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    source?: Reference

    @IsNotEmpty()
    @IsIn(["entered-in-error", "in-progress", "completed", "stopped", "amended"])
    status: "entered-in-error" | "in-progress" | "completed" | "stopped" | "amended"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

  }
  export class RegulatedAuthorizationCaseDto implements RegulatedAuthorizationCase {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RegulatedAuthorizationCaseDto)
    application?: RegulatedAuthorizationCase[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    datePeriod?: Period

    @IsOptional()
    @IsString()
    dateDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    status?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class RegulatedAuthorizationDto implements RegulatedAuthorization {
    @IsNotEmpty()
    @IsIn(["RegulatedAuthorization"])
    resourceType: "RegulatedAuthorization"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    basis?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => RegulatedAuthorizationCaseDto)
    case?: RegulatedAuthorizationCase

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    holder?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableReferenceDto)
    indication?: CodeableReference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    intendedUse?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    region?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    regulator?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    status?: CodeableConcept

    @IsOptional()
    @IsString()
    statusDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    subject?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    validityPeriod?: Period

  }
  export class RelatedPersonCommunicationDto implements RelatedPersonCommunication {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    language: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    preferred: boolean

  }
  export class RelatedPersonDto implements RelatedPerson {
    @IsNotEmpty()
    @IsIn(["RelatedPerson"])
    resourceType: "RelatedPerson"

    @IsNotEmpty()
    @IsBoolean()
    active: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AddressDto)
    address?: Address[]

    @IsOptional()
    @IsString()
    birthDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedPersonCommunicationDto)
    communication?: RelatedPersonCommunication[]

    @IsNotEmpty()
    @IsIn(["other", "unknown", "male", "female"])
    gender: "other" | "unknown" | "male" | "female"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => HumanNameDto)
    name?: HumanName[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AttachmentDto)
    photo?: Attachment[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    relationship?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactPointDto)
    telecom?: ContactPoint[]

  }
  export class RequestGroupActionConditionDto implements RequestGroupActionCondition {
    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    expression?: Expression

    @IsNotEmpty()
    @IsIn(["applicability", "start", "stop"])
    kind: "applicability" | "start" | "stop"

  }
  export class RequestGroupActionRelatedActionDto implements RequestGroupActionRelatedAction {
    @IsNotEmpty()
    @IsString()
    actionId: string

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    offsetDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    offsetRange?: Range

    @IsNotEmpty()
    @IsIn(["before-start", "before", "before-end", "concurrent-with-start", "concurrent", "concurrent-with-end", "after-start", "after", "after-end"])
    relationship: "before-start" | "before" | "before-end" | "concurrent-with-start" | "concurrent" | "concurrent-with-end" | "after-start" | "after" | "after-end"

  }
  export class RequestGroupActionDto implements RequestGroupAction {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RequestGroupActionDto)
    action?: RequestGroupAction[]

    @IsNotEmpty()
    @IsIn(["single", "multiple"])
    cardinalityBehavior: "single" | "multiple"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RequestGroupActionConditionDto)
    condition?: RequestGroupActionCondition[]

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    documentation?: RelatedArtifact[]

    @IsNotEmpty()
    @IsIn(["visual-group", "logical-group", "sentence-group"])
    groupingBehavior: "visual-group" | "logical-group" | "sentence-group"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    participant?: Reference[]

    @IsNotEmpty()
    @IsIn(["yes", "no"])
    precheckBehavior: "yes" | "no"

    @IsOptional()
    @IsString()
    prefix?: string

    @IsNotEmpty()
    @IsIn(["routine", "urgent", "asap", "stat"])
    priority: "routine" | "urgent" | "asap" | "stat"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RequestGroupActionRelatedActionDto)
    relatedAction?: RequestGroupActionRelatedAction[]

    @IsNotEmpty()
    @IsIn(["must", "could", "must-unless-documented"])
    requiredBehavior: "must" | "could" | "must-unless-documented"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    resource?: Reference

    @IsNotEmpty()
    @IsIn(["any", "all", "all-or-none", "exactly-one", "at-most-one", "one-or-more"])
    selectionBehavior: "any" | "all" | "all-or-none" | "exactly-one" | "at-most-one" | "one-or-more"

    @IsOptional()
    @IsString()
    textEquivalent?: string

    @IsOptional()
    @IsString()
    timingDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    timingAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    timingPeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    timingDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    timingRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    timingTiming?: Timing

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class RequestGroupDto implements RequestGroup {
    @IsNotEmpty()
    @IsIn(["RequestGroup"])
    resourceType: "RequestGroup"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RequestGroupActionDto)
    action?: RequestGroupAction[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    author?: Reference

    @IsOptional()
    @IsString()
    authoredOn?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    groupIdentifier?: Identifier

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesCanonical?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesUri?: string[]

    @IsNotEmpty()
    @IsIn(["proposal", "plan", "directive", "order", "original-order", "reflex-order", "filler-order", "instance-order", "option"])
    intent: "proposal" | "plan" | "directive" | "order" | "original-order" | "reflex-order" | "filler-order" | "instance-order" | "option"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsNotEmpty()
    @IsIn(["routine", "urgent", "asap", "stat"])
    priority: "routine" | "urgent" | "asap" | "stat"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    reasonCode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    reasonReference?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    replaces?: Reference[]

    @IsNotEmpty()
    @IsIn(["active", "entered-in-error", "on-hold", "unknown", "draft", "completed", "revoked"])
    status: "active" | "entered-in-error" | "on-hold" | "unknown" | "draft" | "completed" | "revoked"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

  }
  export class ResearchDefinitionDto implements ResearchDefinition {
    @IsNotEmpty()
    @IsIn(["ResearchDefinition"])
    resourceType: "ResearchDefinition"

    @IsOptional()
    @IsString()
    approvalDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    author?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    comment?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    editor?: ContactDetail[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    endorser?: ContactDetail[]

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    exposure?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    exposureAlternative?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    lastReviewDate?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    library?: string[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    outcome?: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    population: Reference

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    relatedArtifact?: RelatedArtifact[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    reviewer?: ContactDetail[]

    @IsOptional()
    @IsString()
    shortTitle?: string

    @IsNotEmpty()
    @IsIn(["active", "unknown", "draft", "retired"])
    status: "active" | "unknown" | "draft" | "retired"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    subjectCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subjectReference?: Reference

    @IsOptional()
    @IsString()
    subtitle?: string

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    topic?: CodeableConcept[]

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsString()
    usage?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

  }
  export class ResearchElementDefinitionCharacteristicDto implements ResearchElementDefinitionCharacteristic {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    definitionCodeableConcept?: CodeableConcept

    @IsOptional()
    @IsString()
    definitionCanonical?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    definitionExpression?: Expression

    @IsOptional()
    @ValidateNested()
    @Type(() => DataRequirementDto)
    definitionDataRequirement?: DataRequirement

    @IsNotEmpty()
    @IsBoolean()
    exclude: boolean

    @IsOptional()
    @IsString()
    participantEffectiveDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    participantEffectivePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    participantEffectiveDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    participantEffectiveTiming?: Timing

    @IsOptional()
    @IsString()
    participantEffectiveDescription?: string

    @IsNotEmpty()
    @IsIn(["mean", "median", "mean-of-mean", "mean-of-median", "median-of-mean", "median-of-median"])
    participantEffectiveGroupMeasure: "mean" | "median" | "mean-of-mean" | "mean-of-median" | "median-of-mean" | "median-of-median"

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    participantEffectiveTimeFromStart?: Duration

    @IsOptional()
    @IsString()
    studyEffectiveDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    studyEffectivePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    studyEffectiveDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    studyEffectiveTiming?: Timing

    @IsOptional()
    @IsString()
    studyEffectiveDescription?: string

    @IsNotEmpty()
    @IsIn(["mean", "median", "mean-of-mean", "mean-of-median", "median-of-mean", "median-of-median"])
    studyEffectiveGroupMeasure: "mean" | "median" | "mean-of-mean" | "mean-of-median" | "median-of-mean" | "median-of-median"

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    studyEffectiveTimeFromStart?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    unitOfMeasure?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    usageContext?: UsageContext[]

  }
  export class ResearchElementDefinitionDto implements ResearchElementDefinition {
    @IsNotEmpty()
    @IsIn(["ResearchElementDefinition"])
    resourceType: "ResearchElementDefinition"

    @IsOptional()
    @IsString()
    approvalDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    author?: ContactDetail[]

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ResearchElementDefinitionCharacteristicDto)
    characteristic: ResearchElementDefinitionCharacteristic[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    comment?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    editor?: ContactDetail[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    endorser?: ContactDetail[]

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    lastReviewDate?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    library?: string[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    relatedArtifact?: RelatedArtifact[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    reviewer?: ContactDetail[]

    @IsOptional()
    @IsString()
    shortTitle?: string

    @IsNotEmpty()
    @IsIn(["active", "unknown", "draft", "retired"])
    status: "active" | "unknown" | "draft" | "retired"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    subjectCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subjectReference?: Reference

    @IsOptional()
    @IsString()
    subtitle?: string

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    topic?: CodeableConcept[]

    @IsNotEmpty()
    @IsIn(["outcome", "population", "exposure"])
    type: "outcome" | "population" | "exposure"

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsString()
    usage?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsNotEmpty()
    @IsIn(["continuous", "dichotomous", "descriptive"])
    variableType: "continuous" | "dichotomous" | "descriptive"

    @IsOptional()
    @IsString()
    version?: string

  }
  export class ResearchStudyArmDto implements ResearchStudyArm {
    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class ResearchStudyObjectiveDto implements ResearchStudyObjective {
    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class ResearchStudyDto implements ResearchStudy {
    @IsNotEmpty()
    @IsIn(["ResearchStudy"])
    resourceType: "ResearchStudy"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ResearchStudyArmDto)
    arm?: ResearchStudyArm[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    condition?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    enrollment?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    focus?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    keyword?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    location?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ResearchStudyObjectiveDto)
    objective?: ResearchStudyObjective[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    partOf?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    phase?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    primaryPurposeType?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    principalInvestigator?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    protocol?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    reasonStopped?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RelatedArtifactDto)
    relatedArtifact?: RelatedArtifact[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    site?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    sponsor?: Reference

    @IsNotEmpty()
    @IsIn(["active", "completed", "administratively-completed", "approved", "closed-to-accrual", "closed-to-accrual-and-intervention", "disapproved", "in-review", "temporarily-closed-to-accrual", "temporarily-closed-to-accrual-and-intervention", "withdrawn"])
    status: "active" | "completed" | "administratively-completed" | "approved" | "closed-to-accrual" | "closed-to-accrual-and-intervention" | "disapproved" | "in-review" | "temporarily-closed-to-accrual" | "temporarily-closed-to-accrual-and-intervention" | "withdrawn"

    @IsOptional()
    @IsString()
    title?: string

  }
  export class ResearchSubjectDto implements ResearchSubject {
    @IsNotEmpty()
    @IsIn(["ResearchSubject"])
    resourceType: "ResearchSubject"

    @IsOptional()
    @IsString()
    actualArm?: string

    @IsOptional()
    @IsString()
    assignedArm?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    consent?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    individual: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsNotEmpty()
    @IsIn(["withdrawn", "candidate", "eligible", "follow-up", "ineligible", "not-registered", "off-study", "on-study", "on-study-intervention", "on-study-observation", "pending-on-study", "potential-candidate", "screening"])
    status: "withdrawn" | "candidate" | "eligible" | "follow-up" | "ineligible" | "not-registered" | "off-study" | "on-study" | "on-study-intervention" | "on-study-observation" | "pending-on-study" | "potential-candidate" | "screening"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    study: Reference

  }
  export class ResourceDto implements Resource {
    @IsNotEmpty()
    @IsString()
    resourceType: string

    @IsOptional()
    @IsString()
    id?: string

    @IsOptional()
    @IsString()
    implicitRules?: string

    @IsOptional()
    @IsString()
    language?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => MetaDto)
    meta?: Meta

  }
  export class RiskAssessmentPredictionDto implements RiskAssessmentPrediction {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    outcome?: CodeableConcept

    @IsOptional()
    @IsNumber()
    probabilityDecimal?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    probabilityRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    qualitativeRisk?: CodeableConcept

    @IsOptional()
    @IsString()
    rationale?: string

    @IsOptional()
    @IsNumber()
    relativeRisk?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    whenPeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    whenRange?: Range

  }
  export class RiskAssessmentDto implements RiskAssessment {
    @IsNotEmpty()
    @IsIn(["RiskAssessment"])
    resourceType: "RiskAssessment"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    basedOn?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basis?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    condition?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    method?: CodeableConcept

    @IsOptional()
    @IsString()
    mitigation?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    occurrenceDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    occurrencePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    parent?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    performer?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => RiskAssessmentPredictionDto)
    prediction?: RiskAssessmentPrediction[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    reasonCode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    reasonReference?: Reference[]

    @IsNotEmpty()
    @IsIn(["entered-in-error", "unknown", "cancelled", "preliminary", "final", "amended", "registered", "corrected"])
    status: "entered-in-error" | "unknown" | "cancelled" | "preliminary" | "final" | "amended" | "registered" | "corrected"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

  }
  export class ScheduleDto implements Schedule {
    @IsNotEmpty()
    @IsIn(["Schedule"])
    resourceType: "Schedule"

    @IsNotEmpty()
    @IsBoolean()
    active: boolean

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    actor: Reference[]

    @IsOptional()
    @IsString()
    comment?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    planningHorizon?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    serviceCategory?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    serviceType?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    specialty?: CodeableConcept[]

  }
  export class SearchParameterComponentDto implements SearchParameterComponent {
    @IsNotEmpty()
    @IsString()
    definition: string

    @IsNotEmpty()
    @IsString()
    expression: string

  }
  export class SearchParameterDto implements SearchParameter {
    @IsNotEmpty()
    @IsIn(["SearchParameter"])
    resourceType: "SearchParameter"

    @IsNotEmpty()
    @IsArray()
    @IsString({ each: true })
    base: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    chain?: string[]

    @IsNotEmpty()
    @IsString()
    code: string

    @IsOptional()
    @IsArray()
    @IsIn(["eq", "ne", "gt", "lt", "ge", "le", "sa", "eb", "ap"], { each: true })
    comparator?: ("eq" | "ne" | "gt" | "lt" | "ge" | "le" | "sa" | "eb" | "ap")[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SearchParameterComponentDto)
    component?: SearchParameterComponent[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    derivedFrom?: string

    @IsNotEmpty()
    @IsString()
    description: string

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsString()
    expression?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @IsIn(["type", "in", "not-in", "identifier", "text", "missing", "exact", "contains", "not", "below", "above", "ofType"], { each: true })
    modifier?: ("type" | "in" | "not-in" | "identifier" | "text" | "missing" | "exact" | "contains" | "not" | "below" | "above" | "ofType")[]

    @IsNotEmpty()
    @IsBoolean()
    multipleAnd: boolean

    @IsNotEmpty()
    @IsBoolean()
    multipleOr: boolean

    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsNotEmpty()
    @IsIn(["active", "unknown", "draft", "retired"])
    status: "active" | "unknown" | "draft" | "retired"

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    target?: string[]

    @IsNotEmpty()
    @IsIn(["string", "number", "date", "token", "reference", "composite", "quantity", "uri", "special"])
    type: "string" | "number" | "date" | "token" | "reference" | "composite" | "quantity" | "uri" | "special"

    @IsNotEmpty()
    @IsString()
    url: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

    @IsOptional()
    @IsString()
    xpath?: string

    @IsNotEmpty()
    @IsIn(["other", "normal", "phonetic", "nearby", "distance"])
    xpathUsage: "other" | "normal" | "phonetic" | "nearby" | "distance"

  }
  export class ServiceRequestDto implements ServiceRequest {
    @IsNotEmpty()
    @IsIn(["ServiceRequest"])
    resourceType: "ServiceRequest"

    @IsNotEmpty()
    @IsBoolean()
    asNeededBoolean: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    asNeededCodeableConcept?: CodeableConcept

    @IsOptional()
    @IsString()
    authoredOn?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    bodySite?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    doNotPerform: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesCanonical?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    instantiatesUri?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    insurance?: Reference[]

    @IsNotEmpty()
    @IsIn(["proposal", "plan", "directive", "order", "original-order", "reflex-order", "filler-order", "instance-order", "option"])
    intent: "proposal" | "plan" | "directive" | "order" | "original-order" | "reflex-order" | "filler-order" | "instance-order" | "option"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    locationCode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    locationReference?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsString()
    occurrenceDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    occurrencePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    occurrenceTiming?: Timing

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    orderDetail?: CodeableConcept[]

    @IsOptional()
    @IsString()
    patientInstruction?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    performer?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    performerType?: CodeableConcept

    @IsNotEmpty()
    @IsIn(["routine", "urgent", "asap", "stat"])
    priority: "routine" | "urgent" | "asap" | "stat"

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantityQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    quantityRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    quantityRange?: Range

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    reasonCode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    reasonReference?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    relevantHistory?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    replaces?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    requester?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    requisition?: Identifier

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    specimen?: Reference[]

    @IsNotEmpty()
    @IsIn(["active", "entered-in-error", "on-hold", "unknown", "draft", "completed", "revoked"])
    status: "active" | "entered-in-error" | "on-hold" | "unknown" | "draft" | "completed" | "revoked"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    supportingInfo?: Reference[]

  }
  export class SlotDto implements Slot {
    @IsNotEmpty()
    @IsIn(["Slot"])
    resourceType: "Slot"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    appointmentType?: CodeableConcept

    @IsOptional()
    @IsString()
    comment?: string

    @IsNotEmpty()
    @IsString()
    end: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsNotEmpty()
    @IsBoolean()
    overbooked: boolean

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    schedule: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    serviceCategory?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    serviceType?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    specialty?: CodeableConcept[]

    @IsNotEmpty()
    @IsString()
    start: string

    @IsNotEmpty()
    @IsIn(["entered-in-error", "busy", "free", "busy-unavailable", "busy-tentative"])
    status: "entered-in-error" | "busy" | "free" | "busy-unavailable" | "busy-tentative"

  }
  export class SpecimenCollectionDto implements SpecimenCollection {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    bodySite?: CodeableConcept

    @IsOptional()
    @IsString()
    collectedDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    collectedPeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    collector?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    duration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    fastingStatusCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    fastingStatusDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    method?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

  }
  export class SpecimenProcessingDto implements SpecimenProcessing {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    additive?: Reference[]

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    procedure?: CodeableConcept

    @IsOptional()
    @IsString()
    timeDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    timePeriod?: Period

  }
  export class SpecimenContainerDto implements SpecimenContainer {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    additiveCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    additiveReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    capacity?: Quantity

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    specimenQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class SpecimenDto implements Specimen {
    @IsNotEmpty()
    @IsIn(["Specimen"])
    resourceType: "Specimen"

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    accessionIdentifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => SpecimenCollectionDto)
    collection?: SpecimenCollection

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    condition?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SpecimenContainerDto)
    container?: SpecimenContainer[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    parent?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SpecimenProcessingDto)
    processing?: SpecimenProcessing[]

    @IsOptional()
    @IsString()
    receivedTime?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    request?: Reference[]

    @IsNotEmpty()
    @IsIn(["entered-in-error", "available", "unavailable", "unsatisfactory"])
    status: "entered-in-error" | "available" | "unavailable" | "unsatisfactory"

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subject?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class SpecimenDefinitionTypeTestedContainerAdditiveDto implements SpecimenDefinitionTypeTestedContainerAdditive {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    additiveCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    additiveReference?: Reference

  }
  export class SpecimenDefinitionTypeTestedContainerDto implements SpecimenDefinitionTypeTestedContainer {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SpecimenDefinitionTypeTestedContainerAdditiveDto)
    additive?: SpecimenDefinitionTypeTestedContainerAdditive[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    cap?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    capacity?: Quantity

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    material?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    minimumVolumeQuantity?: Quantity

    @IsOptional()
    @IsString()
    minimumVolumeString?: string

    @IsOptional()
    @IsString()
    preparation?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class SpecimenDefinitionTypeTestedHandlingDto implements SpecimenDefinitionTypeTestedHandling {
    @IsOptional()
    @IsString()
    instruction?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    maxDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    temperatureQualifier?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    temperatureRange?: Range

  }
  export class SpecimenDefinitionTypeTestedDto implements SpecimenDefinitionTypeTested {
    @IsOptional()
    @ValidateNested()
    @Type(() => SpecimenDefinitionTypeTestedContainerDto)
    container?: SpecimenDefinitionTypeTestedContainer

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SpecimenDefinitionTypeTestedHandlingDto)
    handling?: SpecimenDefinitionTypeTestedHandling[]

    @IsNotEmpty()
    @IsBoolean()
    isDerived: boolean

    @IsNotEmpty()
    @IsIn(["preferred", "alternate"])
    preference: "preferred" | "alternate"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    rejectionCriterion?: CodeableConcept[]

    @IsOptional()
    @IsString()
    requirement?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    retentionTime?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class SpecimenDefinitionDto implements SpecimenDefinition {
    @IsNotEmpty()
    @IsIn(["SpecimenDefinition"])
    resourceType: "SpecimenDefinition"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    collection?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    patientPreparation?: CodeableConcept[]

    @IsOptional()
    @IsString()
    timeAspect?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    typeCollected?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SpecimenDefinitionTypeTestedDto)
    typeTested?: SpecimenDefinitionTypeTested[]

  }
  export class StructureDefinitionMappingDto implements StructureDefinitionMapping {
    @IsOptional()
    @IsString()
    comment?: string

    @IsNotEmpty()
    @IsString()
    identity: string

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsString()
    uri?: string

  }
  export class StructureDefinitionContextDto implements StructureDefinitionContext {
    @IsNotEmpty()
    @IsString()
    expression: string

    @IsNotEmpty()
    @IsIn(["fhirpath", "element", "extension"])
    type: "fhirpath" | "element" | "extension"

  }
  export class StructureDefinitionSnapshotDto implements StructureDefinitionSnapshot {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ElementDefinitionDto)
    element: ElementDefinition[]

  }
  export class StructureDefinitionDifferentialDto implements StructureDefinitionDifferential {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ElementDefinitionDto)
    element: ElementDefinition[]

  }
  export class StructureDefinitionDto implements StructureDefinition {
    @IsNotEmpty()
    @IsIn(["StructureDefinition"])
    resourceType: "StructureDefinition"

    @IsNotEmpty()
    @IsBoolean()
    abstract: boolean

    @IsOptional()
    @IsString()
    baseDefinition?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => StructureDefinitionContextDto)
    context?: StructureDefinitionContext[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    contextInvariant?: string[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsNotEmpty()
    @IsIn(["specialization", "constraint"])
    derivation: "specialization" | "constraint"

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => StructureDefinitionDifferentialDto)
    differential?: StructureDefinitionDifferential

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsString()
    fhirVersion?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodingDto)
    keyword?: Coding[]

    @IsNotEmpty()
    @IsIn(["logical", "primitive-type", "complex-type", "resource"])
    kind: "logical" | "primitive-type" | "complex-type" | "resource"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => StructureDefinitionMappingDto)
    mapping?: StructureDefinitionMapping[]

    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => StructureDefinitionSnapshotDto)
    snapshot?: StructureDefinitionSnapshot

    @IsNotEmpty()
    @IsIn(["active", "unknown", "draft", "retired"])
    status: "active" | "unknown" | "draft" | "retired"

    @IsOptional()
    @IsString()
    title?: string

    @IsNotEmpty()
    @IsString()
    type: string

    @IsNotEmpty()
    @IsString()
    url: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

  }
  export class StructureMapStructureDto implements StructureMapStructure {
    @IsOptional()
    @IsString()
    alias?: string

    @IsOptional()
    @IsString()
    documentation?: string

    @IsNotEmpty()
    @IsIn(["source", "queried", "target", "produced"])
    mode: "source" | "queried" | "target" | "produced"

    @IsNotEmpty()
    @IsString()
    url: string

  }
  export class StructureMapGroupInputDto implements StructureMapGroupInput {
    @IsOptional()
    @IsString()
    documentation?: string

    @IsNotEmpty()
    @IsIn(["source", "target"])
    mode: "source" | "target"

    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @IsString()
    type?: string

  }
  export class StructureMapGroupRuleSourceDto implements StructureMapGroupRuleSource {
    @IsOptional()
    @IsString()
    check?: string

    @IsOptional()
    @IsString()
    condition?: string

    @IsNotEmpty()
    @IsString()
    context: string

    @IsOptional()
    @IsString()
    defaultValueBase64Binary?: string

    @IsNotEmpty()
    @IsBoolean()
    defaultValueBoolean: boolean

    @IsOptional()
    @IsString()
    defaultValueCanonical?: string

    @IsOptional()
    @IsString()
    defaultValueCode?: string

    @IsOptional()
    @IsString()
    defaultValueDate?: string

    @IsOptional()
    @IsString()
    defaultValueDateTime?: string

    @IsOptional()
    @IsNumber()
    defaultValueDecimal?: number

    @IsOptional()
    @IsString()
    defaultValueId?: string

    @IsOptional()
    @IsString()
    defaultValueInstant?: string

    @IsOptional()
    @IsNumber()
    defaultValueInteger?: number

    @IsOptional()
    @IsString()
    defaultValueMarkdown?: string

    @IsOptional()
    @IsString()
    defaultValueOid?: string

    @IsOptional()
    @IsNumber()
    defaultValuePositiveInt?: number

    @IsOptional()
    @IsString()
    defaultValueString?: string

    @IsOptional()
    @IsString()
    defaultValueTime?: string

    @IsOptional()
    @IsNumber()
    defaultValueUnsignedInt?: number

    @IsOptional()
    @IsString()
    defaultValueUri?: string

    @IsOptional()
    @IsString()
    defaultValueUrl?: string

    @IsOptional()
    @IsString()
    defaultValueUuid?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    defaultValueAddress?: Address

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    defaultValueAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => AnnotationDto)
    defaultValueAnnotation?: Annotation

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    defaultValueAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    defaultValueCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    defaultValueCoding?: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactPointDto)
    defaultValueContactPoint?: ContactPoint

    @IsOptional()
    @ValidateNested()
    @Type(() => CountDto)
    defaultValueCount?: Count

    @IsOptional()
    @ValidateNested()
    @Type(() => DistanceDto)
    defaultValueDistance?: Distance

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    defaultValueDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => HumanNameDto)
    defaultValueHumanName?: HumanName

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    defaultValueIdentifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    defaultValueMoney?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    defaultValuePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    defaultValueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    defaultValueRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    defaultValueRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    defaultValueReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => SampledDataDto)
    defaultValueSampledData?: SampledData

    @IsOptional()
    @ValidateNested()
    @Type(() => SignatureDto)
    defaultValueSignature?: Signature

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    defaultValueTiming?: Timing

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactDetailDto)
    defaultValueContactDetail?: ContactDetail

    @IsOptional()
    @ValidateNested()
    @Type(() => ContributorDto)
    defaultValueContributor?: Contributor

    @IsOptional()
    @ValidateNested()
    @Type(() => DataRequirementDto)
    defaultValueDataRequirement?: DataRequirement

    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    defaultValueExpression?: Expression

    @IsOptional()
    @ValidateNested()
    @Type(() => ParameterDefinitionDto)
    defaultValueParameterDefinition?: ParameterDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => RelatedArtifactDto)
    defaultValueRelatedArtifact?: RelatedArtifact

    @IsOptional()
    @ValidateNested()
    @Type(() => TriggerDefinitionDto)
    defaultValueTriggerDefinition?: TriggerDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => UsageContextDto)
    defaultValueUsageContext?: UsageContext

    @IsOptional()
    @ValidateNested()
    @Type(() => DosageDto)
    defaultValueDosage?: Dosage

    @IsOptional()
    @ValidateNested()
    @Type(() => MetaDto)
    defaultValueMeta?: Meta

    @IsOptional()
    @IsString()
    element?: string

    @IsNotEmpty()
    @IsIn(["first", "not_first", "last", "not_last", "only_one"])
    listMode: "first" | "not_first" | "last" | "not_last" | "only_one"

    @IsOptional()
    @IsString()
    logMessage?: string

    @IsOptional()
    @IsString()
    max?: string

    @IsOptional()
    @IsNumber()
    min?: number

    @IsOptional()
    @IsString()
    type?: string

    @IsOptional()
    @IsString()
    variable?: string

  }
  export class StructureMapGroupRuleTargetParameterDto implements StructureMapGroupRuleTargetParameter {
    @IsOptional()
    @IsString()
    valueId?: string

    @IsOptional()
    @IsString()
    valueString?: string

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsOptional()
    @IsNumber()
    valueDecimal?: number

  }
  export class StructureMapGroupRuleTargetDto implements StructureMapGroupRuleTarget {
    @IsOptional()
    @IsString()
    context?: string

    @IsNotEmpty()
    @IsIn(["type", "variable"])
    contextType: "type" | "variable"

    @IsOptional()
    @IsString()
    element?: string

    @IsOptional()
    @IsArray()
    @IsIn(["first", "last", "share", "collate"], { each: true })
    listMode?: ("first" | "last" | "share" | "collate")[]

    @IsOptional()
    @IsString()
    listRuleId?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => StructureMapGroupRuleTargetParameterDto)
    parameter?: StructureMapGroupRuleTargetParameter[]

    @IsNotEmpty()
    @IsIn(["create", "reference", "uuid", "copy", "truncate", "escape", "cast", "append", "translate", "dateOp", "pointer", "evaluate", "cc", "c", "qty", "id", "cp"])
    transform: "create" | "reference" | "uuid" | "copy" | "truncate" | "escape" | "cast" | "append" | "translate" | "dateOp" | "pointer" | "evaluate" | "cc" | "c" | "qty" | "id" | "cp"

    @IsOptional()
    @IsString()
    variable?: string

  }
  export class StructureMapGroupRuleDependentDto implements StructureMapGroupRuleDependent {
    @IsNotEmpty()
    @IsString()
    name: string

    @IsNotEmpty()
    @IsArray()
    @IsString({ each: true })
    variable: string[]

  }
  export class StructureMapGroupRuleDto implements StructureMapGroupRule {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => StructureMapGroupRuleDependentDto)
    dependent?: StructureMapGroupRuleDependent[]

    @IsOptional()
    @IsString()
    documentation?: string

    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => StructureMapGroupRuleDto)
    rule?: StructureMapGroupRule[]

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => StructureMapGroupRuleSourceDto)
    source: StructureMapGroupRuleSource[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => StructureMapGroupRuleTargetDto)
    target?: StructureMapGroupRuleTarget[]

  }
  export class StructureMapGroupDto implements StructureMapGroup {
    @IsOptional()
    @IsString()
    documentation?: string

    @IsOptional()
    @IsString()
    extends?: string

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => StructureMapGroupInputDto)
    input: StructureMapGroupInput[]

    @IsNotEmpty()
    @IsString()
    name: string

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => StructureMapGroupRuleDto)
    rule: StructureMapGroupRule[]

    @IsNotEmpty()
    @IsIn(["none", "types", "type-and-types"])
    typeMode: "none" | "types" | "type-and-types"

  }
  export class StructureMapDto implements StructureMap {
    @IsNotEmpty()
    @IsIn(["StructureMap"])
    resourceType: "StructureMap"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => StructureMapGroupDto)
    group: StructureMapGroup[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    import?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsNotEmpty()
    @IsIn(["active", "unknown", "draft", "retired"])
    status: "active" | "unknown" | "draft" | "retired"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => StructureMapStructureDto)
    structure?: StructureMapStructure[]

    @IsOptional()
    @IsString()
    title?: string

    @IsNotEmpty()
    @IsString()
    url: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

  }
  export class SubscriptionChannelDto implements SubscriptionChannel {
    @IsOptional()
    @IsString()
    endpoint?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    header?: string[]

    @IsOptional()
    @IsString()
    payload?: string

    @IsNotEmpty()
    @IsIn(["email", "sms", "message", "rest-hook", "websocket"])
    type: "email" | "sms" | "message" | "rest-hook" | "websocket"

  }
  export class SubscriptionDto implements Subscription {
    @IsNotEmpty()
    @IsIn(["Subscription"])
    resourceType: "Subscription"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => SubscriptionChannelDto)
    channel: SubscriptionChannel

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactPointDto)
    contact?: ContactPoint[]

    @IsNotEmpty()
    @IsString()
    criteria: string

    @IsOptional()
    @IsString()
    end?: string

    @IsOptional()
    @IsString()
    error?: string

    @IsNotEmpty()
    @IsString()
    reason: string

    @IsNotEmpty()
    @IsIn(["error", "active", "off", "requested"])
    status: "error" | "active" | "off" | "requested"

  }
  export class SubscriptionStatusNotificationEventDto implements SubscriptionStatusNotificationEvent {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    additionalContext?: Reference[]

    @IsNotEmpty()
    @IsString()
    eventNumber: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    focus?: Reference

    @IsOptional()
    @IsString()
    timestamp?: string

  }
  export class SubscriptionStatusDto implements SubscriptionStatus {
    @IsNotEmpty()
    @IsIn(["SubscriptionStatus"])
    resourceType: "SubscriptionStatus"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    error?: CodeableConcept[]

    @IsOptional()
    @IsString()
    eventsSinceSubscriptionStart?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubscriptionStatusNotificationEventDto)
    notificationEvent?: SubscriptionStatusNotificationEvent[]

    @IsNotEmpty()
    @IsIn(["error", "active", "off", "requested"])
    status: "error" | "active" | "off" | "requested"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    subscription: Reference

    @IsOptional()
    @IsString()
    topic?: string

    @IsNotEmpty()
    @IsIn(["handshake", "heartbeat", "event-notification", "query-status", "query-event"])
    type: "handshake" | "heartbeat" | "event-notification" | "query-status" | "query-event"

  }
  export class SubscriptionTopicResourceTriggerQueryCriteriaDto implements SubscriptionTopicResourceTriggerQueryCriteria {
    @IsOptional()
    @IsString()
    current?: string

    @IsOptional()
    @IsString()
    previous?: string

    @IsNotEmpty()
    @IsBoolean()
    requireBoth: boolean

    @IsNotEmpty()
    @IsIn(["test-passes", "test-fails"])
    resultForCreate: "test-passes" | "test-fails"

    @IsNotEmpty()
    @IsIn(["test-passes", "test-fails"])
    resultForDelete: "test-passes" | "test-fails"

  }
  export class SubscriptionTopicResourceTriggerDto implements SubscriptionTopicResourceTrigger {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    fhirPathCriteria?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => SubscriptionTopicResourceTriggerQueryCriteriaDto)
    queryCriteria?: SubscriptionTopicResourceTriggerQueryCriteria

    @IsNotEmpty()
    @IsString()
    resource: string

    @IsOptional()
    @IsArray()
    @IsIn(["update", "delete", "create"], { each: true })
    supportedInteraction?: ("update" | "delete" | "create")[]

  }
  export class SubscriptionTopicEventTriggerDto implements SubscriptionTopicEventTrigger {
    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    event: CodeableConcept

    @IsNotEmpty()
    @IsString()
    resource: string

  }
  export class SubscriptionTopicCanFilterByDto implements SubscriptionTopicCanFilterBy {
    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    filterDefinition?: string

    @IsNotEmpty()
    @IsString()
    filterParameter: string

    @IsOptional()
    @IsArray()
    @IsIn(["in", "=", "not-in", "eq", "ne", "gt", "lt", "ge", "le", "sa", "eb", "ap", "below", "above", "of-type"], { each: true })
    modifier?: ("in" | "=" | "not-in" | "eq" | "ne" | "gt" | "lt" | "ge" | "le" | "sa" | "eb" | "ap" | "below" | "above" | "of-type")[]

    @IsOptional()
    @IsString()
    resource?: string

  }
  export class SubscriptionTopicNotificationShapeDto implements SubscriptionTopicNotificationShape {
    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    include?: string[]

    @IsNotEmpty()
    @IsString()
    resource: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    revInclude?: string[]

  }
  export class SubscriptionTopicDto implements SubscriptionTopic {
    @IsNotEmpty()
    @IsIn(["SubscriptionTopic"])
    resourceType: "SubscriptionTopic"

    @IsOptional()
    @IsString()
    approvalDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubscriptionTopicCanFilterByDto)
    canFilterBy?: SubscriptionTopicCanFilterBy[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    derivedFrom?: string[]

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    effectivePeriod?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubscriptionTopicEventTriggerDto)
    eventTrigger?: SubscriptionTopicEventTrigger[]

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    lastReviewDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubscriptionTopicNotificationShapeDto)
    notificationShape?: SubscriptionTopicNotificationShape[]

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubscriptionTopicResourceTriggerDto)
    resourceTrigger?: SubscriptionTopicResourceTrigger[]

    @IsNotEmpty()
    @IsIn(["active", "unknown", "draft", "retired"])
    status: "active" | "unknown" | "draft" | "retired"

    @IsOptional()
    @IsString()
    title?: string

    @IsNotEmpty()
    @IsString()
    url: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

  }
  export class SubstanceInstanceDto implements SubstanceInstance {
    @IsOptional()
    @IsString()
    expiry?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

  }
  export class SubstanceIngredientDto implements SubstanceIngredient {
    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    quantity?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    substanceCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    substanceReference?: Reference

  }
  export class SubstanceDto implements Substance {
    @IsNotEmpty()
    @IsIn(["Substance"])
    resourceType: "Substance"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code: CodeableConcept

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstanceIngredientDto)
    ingredient?: SubstanceIngredient[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstanceInstanceDto)
    instance?: SubstanceInstance[]

    @IsNotEmpty()
    @IsIn(["active", "inactive", "entered-in-error"])
    status: "active" | "inactive" | "entered-in-error"

  }
  export class SubstanceDefinitionMoietyDto implements SubstanceDefinitionMoiety {
    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    amountQuantity?: Quantity

    @IsOptional()
    @IsString()
    amountString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    measurementType?: CodeableConcept

    @IsOptional()
    @IsString()
    molecularFormula?: string

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    opticalActivity?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    role?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    stereochemistry?: CodeableConcept

  }
  export class SubstanceDefinitionPropertyDto implements SubstanceDefinitionProperty {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @IsString()
    valueDate?: string

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

  }
  export class SubstanceDefinitionMolecularWeightDto implements SubstanceDefinitionMolecularWeight {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => QuantityDto)
    amount: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    method?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class SubstanceDefinitionStructureRepresentationDto implements SubstanceDefinitionStructureRepresentation {
    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    document?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    format?: CodeableConcept

    @IsOptional()
    @IsString()
    representation?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class SubstanceDefinitionStructureDto implements SubstanceDefinitionStructure {
    @IsOptional()
    @IsString()
    molecularFormula?: string

    @IsOptional()
    @IsString()
    molecularFormulaByMoiety?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => SubstanceDefinitionMolecularWeightDto)
    molecularWeight?: SubstanceDefinitionMolecularWeight

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    opticalActivity?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstanceDefinitionStructureRepresentationDto)
    representation?: SubstanceDefinitionStructureRepresentation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    sourceDocument?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    stereochemistry?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    technique?: CodeableConcept[]

  }
  export class SubstanceDefinitionCodeDto implements SubstanceDefinitionCode {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    source?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    status?: CodeableConcept

    @IsOptional()
    @IsString()
    statusDate?: string

  }
  export class SubstanceDefinitionNameOfficialDto implements SubstanceDefinitionNameOfficial {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    authority?: CodeableConcept

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    status?: CodeableConcept

  }
  export class SubstanceDefinitionNameDto implements SubstanceDefinitionName {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    domain?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    language?: CodeableConcept[]

    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstanceDefinitionNameOfficialDto)
    official?: SubstanceDefinitionNameOfficial[]

    @IsNotEmpty()
    @IsBoolean()
    preferred: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    source?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    status?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstanceDefinitionNameDto)
    synonym?: SubstanceDefinitionName[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstanceDefinitionNameDto)
    translation?: SubstanceDefinitionName[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class SubstanceDefinitionRelationshipDto implements SubstanceDefinitionRelationship {
    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    amountQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    amountRatio?: Ratio

    @IsOptional()
    @IsString()
    amountString?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    comparator?: CodeableConcept

    @IsNotEmpty()
    @IsBoolean()
    isDefining: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    ratioHighLimitAmount?: Ratio

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    source?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    substanceDefinitionReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    substanceDefinitionCodeableConcept?: CodeableConcept

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

  }
  export class SubstanceDefinitionSourceMaterialDto implements SubstanceDefinitionSourceMaterial {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    countryOfOrigin?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    genus?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    part?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    species?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class SubstanceDefinitionDto implements SubstanceDefinition {
    @IsNotEmpty()
    @IsIn(["SubstanceDefinition"])
    resourceType: "SubstanceDefinition"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    classification?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstanceDefinitionCodeDto)
    code?: SubstanceDefinitionCode[]

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    domain?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    grade?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    informationSource?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    manufacturer?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstanceDefinitionMoietyDto)
    moiety?: SubstanceDefinitionMoiety[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstanceDefinitionMolecularWeightDto)
    molecularWeight?: SubstanceDefinitionMolecularWeight[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstanceDefinitionNameDto)
    name?: SubstanceDefinitionName[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstanceDefinitionPropertyDto)
    property?: SubstanceDefinitionProperty[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubstanceDefinitionRelationshipDto)
    relationship?: SubstanceDefinitionRelationship[]

    @IsOptional()
    @ValidateNested()
    @Type(() => SubstanceDefinitionSourceMaterialDto)
    sourceMaterial?: SubstanceDefinitionSourceMaterial

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    status?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => SubstanceDefinitionStructureDto)
    structure?: SubstanceDefinitionStructure

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    supplier?: Reference[]

    @IsOptional()
    @IsString()
    version?: string

  }
  export class SupplyDeliverySuppliedItemDto implements SupplyDeliverySuppliedItem {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    itemCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    itemReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity?: Quantity

  }
  export class SupplyDeliveryDto implements SupplyDelivery {
    @IsNotEmpty()
    @IsIn(["SupplyDelivery"])
    resourceType: "SupplyDelivery"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    destination?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsString()
    occurrenceDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    occurrencePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    occurrenceTiming?: Timing

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    partOf?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    receiver?: Reference[]

    @IsNotEmpty()
    @IsIn(["entered-in-error", "in-progress", "completed", "abandoned"])
    status: "entered-in-error" | "in-progress" | "completed" | "abandoned"

    @IsOptional()
    @ValidateNested()
    @Type(() => SupplyDeliverySuppliedItemDto)
    suppliedItem?: SupplyDeliverySuppliedItem

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    supplier?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept

  }
  export class SupplyRequestParameterDto implements SupplyRequestParameter {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

  }
  export class SupplyRequestDto implements SupplyRequest {
    @IsNotEmpty()
    @IsIn(["SupplyRequest"])
    resourceType: "SupplyRequest"

    @IsOptional()
    @IsString()
    authoredOn?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    category?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    deliverFrom?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    deliverTo?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    itemCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    itemReference?: Reference

    @IsOptional()
    @IsString()
    occurrenceDateTime?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    occurrencePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    occurrenceTiming?: Timing

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SupplyRequestParameterDto)
    parameter?: SupplyRequestParameter[]

    @IsNotEmpty()
    @IsIn(["routine", "urgent", "asap", "stat"])
    priority: "routine" | "urgent" | "asap" | "stat"

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => QuantityDto)
    quantity: Quantity

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    reasonCode?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    reasonReference?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    requester?: Reference

    @IsNotEmpty()
    @IsIn(["active", "entered-in-error", "unknown", "draft", "cancelled", "completed", "suspended"])
    status: "active" | "entered-in-error" | "unknown" | "draft" | "cancelled" | "completed" | "suspended"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    supplier?: Reference[]

  }
  export class TaskRestrictionDto implements TaskRestriction {
    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    period?: Period

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    recipient?: Reference[]

    @IsOptional()
    @IsNumber()
    repetitions?: number

  }
  export class TaskInputDto implements TaskInput {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @IsString()
    valueBase64Binary?: string

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsString()
    valueCanonical?: string

    @IsOptional()
    @IsString()
    valueCode?: string

    @IsOptional()
    @IsString()
    valueDate?: string

    @IsOptional()
    @IsString()
    valueDateTime?: string

    @IsOptional()
    @IsNumber()
    valueDecimal?: number

    @IsOptional()
    @IsString()
    valueId?: string

    @IsOptional()
    @IsString()
    valueInstant?: string

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsOptional()
    @IsString()
    valueMarkdown?: string

    @IsOptional()
    @IsString()
    valueOid?: string

    @IsOptional()
    @IsNumber()
    valuePositiveInt?: number

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @IsString()
    valueTime?: string

    @IsOptional()
    @IsNumber()
    valueUnsignedInt?: number

    @IsOptional()
    @IsString()
    valueUri?: string

    @IsOptional()
    @IsString()
    valueUrl?: string

    @IsOptional()
    @IsString()
    valueUuid?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    valueAddress?: Address

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    valueAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => AnnotationDto)
    valueAnnotation?: Annotation

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    valueCoding?: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactPointDto)
    valueContactPoint?: ContactPoint

    @IsOptional()
    @ValidateNested()
    @Type(() => CountDto)
    valueCount?: Count

    @IsOptional()
    @ValidateNested()
    @Type(() => DistanceDto)
    valueDistance?: Distance

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    valueDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => HumanNameDto)
    valueHumanName?: HumanName

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    valueIdentifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    valueMoney?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    valuePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    valueRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => SampledDataDto)
    valueSampledData?: SampledData

    @IsOptional()
    @ValidateNested()
    @Type(() => SignatureDto)
    valueSignature?: Signature

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    valueTiming?: Timing

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactDetailDto)
    valueContactDetail?: ContactDetail

    @IsOptional()
    @ValidateNested()
    @Type(() => ContributorDto)
    valueContributor?: Contributor

    @IsOptional()
    @ValidateNested()
    @Type(() => DataRequirementDto)
    valueDataRequirement?: DataRequirement

    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    valueExpression?: Expression

    @IsOptional()
    @ValidateNested()
    @Type(() => ParameterDefinitionDto)
    valueParameterDefinition?: ParameterDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => RelatedArtifactDto)
    valueRelatedArtifact?: RelatedArtifact

    @IsOptional()
    @ValidateNested()
    @Type(() => TriggerDefinitionDto)
    valueTriggerDefinition?: TriggerDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => UsageContextDto)
    valueUsageContext?: UsageContext

    @IsOptional()
    @ValidateNested()
    @Type(() => DosageDto)
    valueDosage?: Dosage

    @IsOptional()
    @ValidateNested()
    @Type(() => MetaDto)
    valueMeta?: Meta

  }
  export class TaskOutputDto implements TaskOutput {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    type: CodeableConcept

    @IsOptional()
    @IsString()
    valueBase64Binary?: string

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsString()
    valueCanonical?: string

    @IsOptional()
    @IsString()
    valueCode?: string

    @IsOptional()
    @IsString()
    valueDate?: string

    @IsOptional()
    @IsString()
    valueDateTime?: string

    @IsOptional()
    @IsNumber()
    valueDecimal?: number

    @IsOptional()
    @IsString()
    valueId?: string

    @IsOptional()
    @IsString()
    valueInstant?: string

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsOptional()
    @IsString()
    valueMarkdown?: string

    @IsOptional()
    @IsString()
    valueOid?: string

    @IsOptional()
    @IsNumber()
    valuePositiveInt?: number

    @IsOptional()
    @IsString()
    valueString?: string

    @IsOptional()
    @IsString()
    valueTime?: string

    @IsOptional()
    @IsNumber()
    valueUnsignedInt?: number

    @IsOptional()
    @IsString()
    valueUri?: string

    @IsOptional()
    @IsString()
    valueUrl?: string

    @IsOptional()
    @IsString()
    valueUuid?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => AddressDto)
    valueAddress?: Address

    @IsOptional()
    @ValidateNested()
    @Type(() => AgeDto)
    valueAge?: Age

    @IsOptional()
    @ValidateNested()
    @Type(() => AnnotationDto)
    valueAnnotation?: Annotation

    @IsOptional()
    @ValidateNested()
    @Type(() => AttachmentDto)
    valueAttachment?: Attachment

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    valueCodeableConcept?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    valueCoding?: Coding

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactPointDto)
    valueContactPoint?: ContactPoint

    @IsOptional()
    @ValidateNested()
    @Type(() => CountDto)
    valueCount?: Count

    @IsOptional()
    @ValidateNested()
    @Type(() => DistanceDto)
    valueDistance?: Distance

    @IsOptional()
    @ValidateNested()
    @Type(() => DurationDto)
    valueDuration?: Duration

    @IsOptional()
    @ValidateNested()
    @Type(() => HumanNameDto)
    valueHumanName?: HumanName

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    valueIdentifier?: Identifier

    @IsOptional()
    @ValidateNested()
    @Type(() => MoneyDto)
    valueMoney?: Money

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    valuePeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    valueQuantity?: Quantity

    @IsOptional()
    @ValidateNested()
    @Type(() => RangeDto)
    valueRange?: Range

    @IsOptional()
    @ValidateNested()
    @Type(() => RatioDto)
    valueRatio?: Ratio

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    valueReference?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => SampledDataDto)
    valueSampledData?: SampledData

    @IsOptional()
    @ValidateNested()
    @Type(() => SignatureDto)
    valueSignature?: Signature

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    valueTiming?: Timing

    @IsOptional()
    @ValidateNested()
    @Type(() => ContactDetailDto)
    valueContactDetail?: ContactDetail

    @IsOptional()
    @ValidateNested()
    @Type(() => ContributorDto)
    valueContributor?: Contributor

    @IsOptional()
    @ValidateNested()
    @Type(() => DataRequirementDto)
    valueDataRequirement?: DataRequirement

    @IsOptional()
    @ValidateNested()
    @Type(() => ExpressionDto)
    valueExpression?: Expression

    @IsOptional()
    @ValidateNested()
    @Type(() => ParameterDefinitionDto)
    valueParameterDefinition?: ParameterDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => RelatedArtifactDto)
    valueRelatedArtifact?: RelatedArtifact

    @IsOptional()
    @ValidateNested()
    @Type(() => TriggerDefinitionDto)
    valueTriggerDefinition?: TriggerDefinition

    @IsOptional()
    @ValidateNested()
    @Type(() => UsageContextDto)
    valueUsageContext?: UsageContext

    @IsOptional()
    @ValidateNested()
    @Type(() => DosageDto)
    valueDosage?: Dosage

    @IsOptional()
    @ValidateNested()
    @Type(() => MetaDto)
    valueMeta?: Meta

  }
  export class TaskDto implements Task {
    @IsNotEmpty()
    @IsIn(["Task"])
    resourceType: "Task"

    @IsOptional()
    @IsString()
    authoredOn?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    basedOn?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    businessStatus?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    code?: CodeableConcept

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => PeriodDto)
    executionPeriod?: Period

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    focus?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    for?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    groupIdentifier?: Identifier

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TaskInputDto)
    input?: TaskInput[]

    @IsOptional()
    @IsString()
    instantiatesCanonical?: string

    @IsOptional()
    @IsString()
    instantiatesUri?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    insurance?: Reference[]

    @IsNotEmpty()
    @IsIn(["unknown", "proposal", "plan", "order", "original-order", "reflex-order", "filler-order", "instance-order", "option"])
    intent: "unknown" | "proposal" | "plan" | "order" | "original-order" | "reflex-order" | "filler-order" | "instance-order" | "option"

    @IsOptional()
    @IsString()
    lastModified?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    location?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TaskOutputDto)
    output?: TaskOutput[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    owner?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    partOf?: Reference[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    performerType?: CodeableConcept[]

    @IsNotEmpty()
    @IsIn(["routine", "urgent", "asap", "stat"])
    priority: "routine" | "urgent" | "asap" | "stat"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    reasonCode?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    reasonReference?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    relevantHistory?: Reference[]

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    requester?: Reference

    @IsOptional()
    @ValidateNested()
    @Type(() => TaskRestrictionDto)
    restriction?: TaskRestriction

    @IsNotEmpty()
    @IsIn(["entered-in-error", "on-hold", "draft", "accepted", "cancelled", "in-progress", "completed", "rejected", "requested", "received", "ready", "failed"])
    status: "entered-in-error" | "on-hold" | "draft" | "accepted" | "cancelled" | "in-progress" | "completed" | "rejected" | "requested" | "received" | "ready" | "failed"

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    statusReason?: CodeableConcept

  }
  export class TerminologyCapabilitiesSoftwareDto implements TerminologyCapabilitiesSoftware {
    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @IsString()
    version?: string

  }
  export class TerminologyCapabilitiesImplementationDto implements TerminologyCapabilitiesImplementation {
    @IsNotEmpty()
    @IsString()
    description: string

    @IsOptional()
    @IsString()
    url?: string

  }
  export class TerminologyCapabilitiesCodeSystemVersionFilterDto implements TerminologyCapabilitiesCodeSystemVersionFilter {
    @IsNotEmpty()
    @IsString()
    code: string

    @IsNotEmpty()
    @IsArray()
    @IsString({ each: true })
    op: string[]

  }
  export class TerminologyCapabilitiesCodeSystemVersionDto implements TerminologyCapabilitiesCodeSystemVersion {
    @IsOptional()
    @IsString()
    code?: string

    @IsNotEmpty()
    @IsBoolean()
    compositional: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TerminologyCapabilitiesCodeSystemVersionFilterDto)
    filter?: TerminologyCapabilitiesCodeSystemVersionFilter[]

    @IsNotEmpty()
    @IsBoolean()
    isDefault: boolean

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    language?: string[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    property?: string[]

  }
  export class TerminologyCapabilitiesCodeSystemDto implements TerminologyCapabilitiesCodeSystem {
    @IsNotEmpty()
    @IsBoolean()
    subsumption: boolean

    @IsOptional()
    @IsString()
    uri?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TerminologyCapabilitiesCodeSystemVersionDto)
    version?: TerminologyCapabilitiesCodeSystemVersion[]

  }
  export class TerminologyCapabilitiesExpansionParameterDto implements TerminologyCapabilitiesExpansionParameter {
    @IsOptional()
    @IsString()
    documentation?: string

    @IsNotEmpty()
    @IsString()
    name: string

  }
  export class TerminologyCapabilitiesExpansionDto implements TerminologyCapabilitiesExpansion {
    @IsNotEmpty()
    @IsBoolean()
    hierarchical: boolean

    @IsNotEmpty()
    @IsBoolean()
    incomplete: boolean

    @IsNotEmpty()
    @IsBoolean()
    paging: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TerminologyCapabilitiesExpansionParameterDto)
    parameter?: TerminologyCapabilitiesExpansionParameter[]

    @IsOptional()
    @IsString()
    textFilter?: string

  }
  export class TerminologyCapabilitiesValidateCodeDto implements TerminologyCapabilitiesValidateCode {
    @IsNotEmpty()
    @IsBoolean()
    translations: boolean

  }
  export class TerminologyCapabilitiesTranslationDto implements TerminologyCapabilitiesTranslation {
    @IsNotEmpty()
    @IsBoolean()
    needsMap: boolean

  }
  export class TerminologyCapabilitiesClosureDto implements TerminologyCapabilitiesClosure {
    @IsNotEmpty()
    @IsBoolean()
    translation: boolean

  }
  export class TerminologyCapabilitiesDto implements TerminologyCapabilities {
    @IsNotEmpty()
    @IsIn(["TerminologyCapabilities"])
    resourceType: "TerminologyCapabilities"

    @IsOptional()
    @ValidateNested()
    @Type(() => TerminologyCapabilitiesClosureDto)
    closure?: TerminologyCapabilitiesClosure

    @IsNotEmpty()
    @IsIn(["all", "explicit"])
    codeSearch: "all" | "explicit"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TerminologyCapabilitiesCodeSystemDto)
    codeSystem?: TerminologyCapabilitiesCodeSystem[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsNotEmpty()
    @IsString()
    date: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => TerminologyCapabilitiesExpansionDto)
    expansion?: TerminologyCapabilitiesExpansion

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => TerminologyCapabilitiesImplementationDto)
    implementation?: TerminologyCapabilitiesImplementation

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsNotEmpty()
    @IsIn(["instance", "capability", "requirements"])
    kind: "instance" | "capability" | "requirements"

    @IsNotEmpty()
    @IsBoolean()
    lockedDate: boolean

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => TerminologyCapabilitiesSoftwareDto)
    software?: TerminologyCapabilitiesSoftware

    @IsNotEmpty()
    @IsIn(["active", "unknown", "draft", "retired"])
    status: "active" | "unknown" | "draft" | "retired"

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => TerminologyCapabilitiesTranslationDto)
    translation?: TerminologyCapabilitiesTranslation

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @ValidateNested()
    @Type(() => TerminologyCapabilitiesValidateCodeDto)
    validateCode?: TerminologyCapabilitiesValidateCode

    @IsOptional()
    @IsString()
    version?: string

  }
  export class TestReportParticipantDto implements TestReportParticipant {
    @IsOptional()
    @IsString()
    display?: string

    @IsNotEmpty()
    @IsIn(["client", "server", "test-engine"])
    type: "client" | "server" | "test-engine"

    @IsNotEmpty()
    @IsString()
    uri: string

  }
  export class TestReportSetupActionOperationDto implements TestReportSetupActionOperation {
    @IsOptional()
    @IsString()
    detail?: string

    @IsOptional()
    @IsString()
    message?: string

    @IsNotEmpty()
    @IsIn(["error", "warning", "pass", "skip", "fail"])
    result: "error" | "warning" | "pass" | "skip" | "fail"

  }
  export class TestReportSetupActionAssertDto implements TestReportSetupActionAssert {
    @IsOptional()
    @IsString()
    detail?: string

    @IsOptional()
    @IsString()
    message?: string

    @IsNotEmpty()
    @IsIn(["error", "warning", "pass", "skip", "fail"])
    result: "error" | "warning" | "pass" | "skip" | "fail"

  }
  export class TestReportSetupActionDto implements TestReportSetupAction {
    @IsOptional()
    @ValidateNested()
    @Type(() => TestReportSetupActionAssertDto)
    assert?: TestReportSetupActionAssert

    @IsOptional()
    @ValidateNested()
    @Type(() => TestReportSetupActionOperationDto)
    operation?: TestReportSetupActionOperation

  }
  export class TestReportSetupDto implements TestReportSetup {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestReportSetupActionDto)
    action: TestReportSetupAction[]

  }
  export class TestReportTestActionDto implements TestReportTestAction {
    @IsOptional()
    @ValidateNested()
    @Type(() => TestReportSetupActionAssertDto)
    assert?: TestReportSetupActionAssert

    @IsOptional()
    @ValidateNested()
    @Type(() => TestReportSetupActionOperationDto)
    operation?: TestReportSetupActionOperation

  }
  export class TestReportTestDto implements TestReportTest {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestReportTestActionDto)
    action: TestReportTestAction[]

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    name?: string

  }
  export class TestReportTeardownActionDto implements TestReportTeardownAction {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => TestReportSetupActionOperationDto)
    operation: TestReportSetupActionOperation

  }
  export class TestReportTeardownDto implements TestReportTeardown {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestReportTeardownActionDto)
    action: TestReportTeardownAction[]

  }
  export class TestReportDto implements TestReport {
    @IsNotEmpty()
    @IsIn(["TestReport"])
    resourceType: "TestReport"

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsOptional()
    @IsString()
    issued?: string

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestReportParticipantDto)
    participant?: TestReportParticipant[]

    @IsNotEmpty()
    @IsIn(["pending", "pass", "fail"])
    result: "pending" | "pass" | "fail"

    @IsOptional()
    @IsNumber()
    score?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => TestReportSetupDto)
    setup?: TestReportSetup

    @IsNotEmpty()
    @IsIn(["entered-in-error", "in-progress", "completed", "stopped", "waiting"])
    status: "entered-in-error" | "in-progress" | "completed" | "stopped" | "waiting"

    @IsOptional()
    @ValidateNested()
    @Type(() => TestReportTeardownDto)
    teardown?: TestReportTeardown

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestReportTestDto)
    test?: TestReportTest[]

    @IsOptional()
    @IsString()
    tester?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    testScript: Reference

  }
  export class TestScriptOriginDto implements TestScriptOrigin {
    @IsNotEmpty()
    @IsNumber()
    index: number

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodingDto)
    profile: Coding

  }
  export class TestScriptDestinationDto implements TestScriptDestination {
    @IsNotEmpty()
    @IsNumber()
    index: number

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodingDto)
    profile: Coding

  }
  export class TestScriptMetadataLinkDto implements TestScriptMetadataLink {
    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsString()
    url: string

  }
  export class TestScriptMetadataCapabilityDto implements TestScriptMetadataCapability {
    @IsNotEmpty()
    @IsString()
    capabilities: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsNumber()
    destination?: number

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    link?: string[]

    @IsOptional()
    @IsArray()
    @IsNumber({}, { each: true })
    origin?: number[]

    @IsNotEmpty()
    @IsBoolean()
    required: boolean

    @IsNotEmpty()
    @IsBoolean()
    validated: boolean

  }
  export class TestScriptMetadataDto implements TestScriptMetadata {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestScriptMetadataCapabilityDto)
    capability: TestScriptMetadataCapability[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestScriptMetadataLinkDto)
    link?: TestScriptMetadataLink[]

  }
  export class TestScriptFixtureDto implements TestScriptFixture {
    @IsNotEmpty()
    @IsBoolean()
    autocreate: boolean

    @IsNotEmpty()
    @IsBoolean()
    autodelete: boolean

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    resource?: Reference

  }
  export class TestScriptVariableDto implements TestScriptVariable {
    @IsOptional()
    @IsString()
    defaultValue?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    expression?: string

    @IsOptional()
    @IsString()
    headerField?: string

    @IsOptional()
    @IsString()
    hint?: string

    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @IsString()
    path?: string

    @IsOptional()
    @IsString()
    sourceId?: string

  }
  export class TestScriptSetupActionOperationRequestHeaderDto implements TestScriptSetupActionOperationRequestHeader {
    @IsNotEmpty()
    @IsString()
    field: string

    @IsNotEmpty()
    @IsString()
    value: string

  }
  export class TestScriptSetupActionOperationDto implements TestScriptSetupActionOperation {
    @IsOptional()
    @IsString()
    accept?: string

    @IsOptional()
    @IsString()
    contentType?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsNumber()
    destination?: number

    @IsNotEmpty()
    @IsBoolean()
    encodeRequestUrl: boolean

    @IsOptional()
    @IsString()
    label?: string

    @IsNotEmpty()
    @IsIn(["patch", "delete", "get", "options", "post", "put", "head"])
    method: "patch" | "delete" | "get" | "options" | "post" | "put" | "head"

    @IsOptional()
    @IsNumber()
    origin?: number

    @IsOptional()
    @IsString()
    params?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestScriptSetupActionOperationRequestHeaderDto)
    requestHeader?: TestScriptSetupActionOperationRequestHeader[]

    @IsOptional()
    @IsString()
    requestId?: string

    @IsOptional()
    @IsString()
    resource?: string

    @IsOptional()
    @IsString()
    responseId?: string

    @IsOptional()
    @IsString()
    sourceId?: string

    @IsOptional()
    @IsString()
    targetId?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    type?: Coding

    @IsOptional()
    @IsString()
    url?: string

  }
  export class TestScriptSetupActionAssertDto implements TestScriptSetupActionAssert {
    @IsOptional()
    @IsString()
    compareToSourceExpression?: string

    @IsOptional()
    @IsString()
    compareToSourceId?: string

    @IsOptional()
    @IsString()
    compareToSourcePath?: string

    @IsOptional()
    @IsString()
    contentType?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsNotEmpty()
    @IsIn(["response", "request"])
    direction: "response" | "request"

    @IsOptional()
    @IsString()
    expression?: string

    @IsOptional()
    @IsString()
    headerField?: string

    @IsOptional()
    @IsString()
    label?: string

    @IsOptional()
    @IsString()
    minimumId?: string

    @IsNotEmpty()
    @IsBoolean()
    navigationLinks: boolean

    @IsNotEmpty()
    @IsIn(["empty", "in", "contains", "equals", "notEquals", "notIn", "greaterThan", "lessThan", "notEmpty", "notContains", "eval"])
    operator: "empty" | "in" | "contains" | "equals" | "notEquals" | "notIn" | "greaterThan" | "lessThan" | "notEmpty" | "notContains" | "eval"

    @IsOptional()
    @IsString()
    path?: string

    @IsNotEmpty()
    @IsIn(["patch", "delete", "get", "options", "post", "put", "head"])
    requestMethod: "patch" | "delete" | "get" | "options" | "post" | "put" | "head"

    @IsOptional()
    @IsString()
    requestURL?: string

    @IsOptional()
    @IsString()
    resource?: string

    @IsNotEmpty()
    @IsIn(["okay", "created", "noContent", "notModified", "bad", "forbidden", "notFound", "methodNotAllowed", "conflict", "gone", "preconditionFailed", "unprocessable"])
    response: "okay" | "created" | "noContent" | "notModified" | "bad" | "forbidden" | "notFound" | "methodNotAllowed" | "conflict" | "gone" | "preconditionFailed" | "unprocessable"

    @IsOptional()
    @IsString()
    responseCode?: string

    @IsOptional()
    @IsString()
    sourceId?: string

    @IsOptional()
    @IsString()
    validateProfileId?: string

    @IsOptional()
    @IsString()
    value?: string

    @IsNotEmpty()
    @IsBoolean()
    warningOnly: boolean

  }
  export class TestScriptSetupActionDto implements TestScriptSetupAction {
    @IsOptional()
    @ValidateNested()
    @Type(() => TestScriptSetupActionAssertDto)
    assert?: TestScriptSetupActionAssert

    @IsOptional()
    @ValidateNested()
    @Type(() => TestScriptSetupActionOperationDto)
    operation?: TestScriptSetupActionOperation

  }
  export class TestScriptSetupDto implements TestScriptSetup {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestScriptSetupActionDto)
    action: TestScriptSetupAction[]

  }
  export class TestScriptTestActionDto implements TestScriptTestAction {
    @IsOptional()
    @ValidateNested()
    @Type(() => TestScriptSetupActionAssertDto)
    assert?: TestScriptSetupActionAssert

    @IsOptional()
    @ValidateNested()
    @Type(() => TestScriptSetupActionOperationDto)
    operation?: TestScriptSetupActionOperation

  }
  export class TestScriptTestDto implements TestScriptTest {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestScriptTestActionDto)
    action: TestScriptTestAction[]

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsString()
    name?: string

  }
  export class TestScriptTeardownActionDto implements TestScriptTeardownAction {
    @IsNotEmpty()
    @ValidateNested()
    @Type(() => TestScriptSetupActionOperationDto)
    operation: TestScriptSetupActionOperation

  }
  export class TestScriptTeardownDto implements TestScriptTeardown {
    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestScriptTeardownActionDto)
    action: TestScriptTeardownAction[]

  }
  export class TestScriptDto implements TestScript {
    @IsNotEmpty()
    @IsIn(["TestScript"])
    resourceType: "TestScript"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestScriptDestinationDto)
    destination?: TestScriptDestination[]

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestScriptFixtureDto)
    fixture?: TestScriptFixture[]

    @IsOptional()
    @ValidateNested()
    @Type(() => IdentifierDto)
    identifier?: Identifier

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => TestScriptMetadataDto)
    metadata?: TestScriptMetadata

    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestScriptOriginDto)
    origin?: TestScriptOrigin[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    profile?: Reference[]

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => TestScriptSetupDto)
    setup?: TestScriptSetup

    @IsNotEmpty()
    @IsIn(["active", "unknown", "draft", "retired"])
    status: "active" | "unknown" | "draft" | "retired"

    @IsOptional()
    @ValidateNested()
    @Type(() => TestScriptTeardownDto)
    teardown?: TestScriptTeardown

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestScriptTestDto)
    test?: TestScriptTest[]

    @IsOptional()
    @IsString()
    title?: string

    @IsNotEmpty()
    @IsString()
    url: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => TestScriptVariableDto)
    variable?: TestScriptVariable[]

    @IsOptional()
    @IsString()
    version?: string

  }
  export class ValueSetComposeIncludeConceptDesignationDto implements ValueSetComposeIncludeConceptDesignation {
    @IsOptional()
    @IsString()
    language?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodingDto)
    use?: Coding

    @IsNotEmpty()
    @IsString()
    value: string

  }
  export class ValueSetComposeIncludeConceptDto implements ValueSetComposeIncludeConcept {
    @IsNotEmpty()
    @IsString()
    code: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ValueSetComposeIncludeConceptDesignationDto)
    designation?: ValueSetComposeIncludeConceptDesignation[]

    @IsOptional()
    @IsString()
    display?: string

  }
  export class ValueSetComposeIncludeFilterDto implements ValueSetComposeIncludeFilter {
    @IsNotEmpty()
    @IsIn(["exists", "in", "=", "is-a", "descendent-of", "is-not-a", "regex", "not-in", "generalizes"])
    op: "exists" | "in" | "=" | "is-a" | "descendent-of" | "is-not-a" | "regex" | "not-in" | "generalizes"

    @IsNotEmpty()
    @IsString()
    property: string

    @IsNotEmpty()
    @IsString()
    value: string

  }
  export class ValueSetComposeIncludeDto implements ValueSetComposeInclude {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ValueSetComposeIncludeConceptDto)
    concept?: ValueSetComposeIncludeConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ValueSetComposeIncludeFilterDto)
    filter?: ValueSetComposeIncludeFilter[]

    @IsOptional()
    @IsString()
    system?: string

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    valueSet?: string[]

    @IsOptional()
    @IsString()
    version?: string

  }
  export class ValueSetComposeDto implements ValueSetCompose {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ValueSetComposeIncludeDto)
    exclude?: ValueSetComposeInclude[]

    @IsNotEmpty()
    @IsBoolean()
    inactive: boolean

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ValueSetComposeIncludeDto)
    include: ValueSetComposeInclude[]

    @IsOptional()
    @IsString()
    lockedDate?: string

  }
  export class ValueSetExpansionParameterDto implements ValueSetExpansionParameter {
    @IsNotEmpty()
    @IsString()
    name: string

    @IsOptional()
    @IsString()
    valueString?: string

    @IsNotEmpty()
    @IsBoolean()
    valueBoolean: boolean

    @IsOptional()
    @IsNumber()
    valueInteger?: number

    @IsOptional()
    @IsNumber()
    valueDecimal?: number

    @IsOptional()
    @IsString()
    valueUri?: string

    @IsOptional()
    @IsString()
    valueCode?: string

    @IsOptional()
    @IsString()
    valueDateTime?: string

  }
  export class ValueSetExpansionContainsDto implements ValueSetExpansionContains {
    @IsNotEmpty()
    @IsBoolean()
    abstract: boolean

    @IsOptional()
    @IsString()
    code?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ValueSetExpansionContainsDto)
    contains?: ValueSetExpansionContains[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ValueSetComposeIncludeConceptDesignationDto)
    designation?: ValueSetComposeIncludeConceptDesignation[]

    @IsOptional()
    @IsString()
    display?: string

    @IsNotEmpty()
    @IsBoolean()
    inactive: boolean

    @IsOptional()
    @IsString()
    system?: string

    @IsOptional()
    @IsString()
    version?: string

  }
  export class ValueSetExpansionDto implements ValueSetExpansion {
    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ValueSetExpansionContainsDto)
    contains?: ValueSetExpansionContains[]

    @IsOptional()
    @IsString()
    identifier?: string

    @IsOptional()
    @IsNumber()
    offset?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ValueSetExpansionParameterDto)
    parameter?: ValueSetExpansionParameter[]

    @IsNotEmpty()
    @IsString()
    timestamp: string

    @IsOptional()
    @IsNumber()
    total?: number

  }
  export class ValueSetDto implements ValueSet {
    @IsNotEmpty()
    @IsIn(["ValueSet"])
    resourceType: "ValueSet"

    @IsOptional()
    @ValidateNested()
    @Type(() => ValueSetComposeDto)
    compose?: ValueSetCompose

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ContactDetailDto)
    contact?: ContactDetail[]

    @IsOptional()
    @IsString()
    copyright?: string

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @IsString()
    description?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ValueSetExpansionDto)
    expansion?: ValueSetExpansion

    @IsNotEmpty()
    @IsBoolean()
    experimental: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsNotEmpty()
    @IsBoolean()
    immutable: boolean

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    jurisdiction?: CodeableConcept[]

    @IsOptional()
    @IsString()
    name?: string

    @IsOptional()
    @IsString()
    publisher?: string

    @IsOptional()
    @IsString()
    purpose?: string

    @IsNotEmpty()
    @IsIn(["active", "unknown", "draft", "retired"])
    status: "active" | "unknown" | "draft" | "retired"

    @IsOptional()
    @IsString()
    title?: string

    @IsOptional()
    @IsString()
    url?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => UsageContextDto)
    useContext?: UsageContext[]

    @IsOptional()
    @IsString()
    version?: string

  }
  export class VerificationResultPrimarySourceDto implements VerificationResultPrimarySource {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    canPushUpdates?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    communicationMethod?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    pushTypeAvailable?: CodeableConcept[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    type?: CodeableConcept[]

    @IsOptional()
    @IsString()
    validationDate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    validationStatus?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    who?: Reference

  }
  export class VerificationResultAttestationDto implements VerificationResultAttestation {
    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    communicationMethod?: CodeableConcept

    @IsOptional()
    @IsString()
    date?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    onBehalfOf?: Reference

    @IsOptional()
    @IsString()
    proxyIdentityCertificate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => SignatureDto)
    proxySignature?: Signature

    @IsOptional()
    @IsString()
    sourceIdentityCertificate?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => SignatureDto)
    sourceSignature?: Signature

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    who?: Reference

  }
  export class VerificationResultValidatorDto implements VerificationResultValidator {
    @IsOptional()
    @ValidateNested()
    @Type(() => SignatureDto)
    attestationSignature?: Signature

    @IsOptional()
    @IsString()
    identityCertificate?: string

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    organization: Reference

  }
  export class VerificationResultDto implements VerificationResult {
    @IsNotEmpty()
    @IsIn(["VerificationResult"])
    resourceType: "VerificationResult"

    @IsOptional()
    @ValidateNested()
    @Type(() => VerificationResultAttestationDto)
    attestation?: VerificationResultAttestation

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    failureAction?: CodeableConcept

    @IsOptional()
    @ValidateNested()
    @Type(() => TimingDto)
    frequency?: Timing

    @IsOptional()
    @IsString()
    lastPerformed?: string

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    need?: CodeableConcept

    @IsOptional()
    @IsString()
    nextScheduled?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => VerificationResultPrimarySourceDto)
    primarySource?: VerificationResultPrimarySource[]

    @IsNotEmpty()
    @IsIn(["attested", "validated", "in-process", "req-revalid", "val-fail", "reval-fail"])
    status: "attested" | "validated" | "in-process" | "req-revalid" | "val-fail" | "reval-fail"

    @IsOptional()
    @IsString()
    statusDate?: string

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ReferenceDto)
    target?: Reference[]

    @IsOptional()
    @IsArray()
    @IsString({ each: true })
    targetLocation?: string[]

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CodeableConceptDto)
    validationProcess?: CodeableConcept[]

    @IsOptional()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    validationType?: CodeableConcept

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => VerificationResultValidatorDto)
    validator?: VerificationResultValidator[]

  }
  export class VisionPrescriptionLensSpecificationPrismDto implements VisionPrescriptionLensSpecificationPrism {
    @IsNotEmpty()
    @IsNumber()
    amount: number

    @IsNotEmpty()
    @IsIn(["in", "out", "up", "down"])
    base: "in" | "out" | "up" | "down"

  }
  export class VisionPrescriptionLensSpecificationDto implements VisionPrescriptionLensSpecification {
    @IsOptional()
    @IsNumber()
    add?: number

    @IsOptional()
    @IsNumber()
    axis?: number

    @IsOptional()
    @IsNumber()
    backCurve?: number

    @IsOptional()
    @IsString()
    brand?: string

    @IsOptional()
    @IsString()
    color?: string

    @IsOptional()
    @IsNumber()
    cylinder?: number

    @IsOptional()
    @IsNumber()
    diameter?: number

    @IsOptional()
    @ValidateNested()
    @Type(() => QuantityDto)
    duration?: Quantity

    @IsNotEmpty()
    @IsIn(["right", "left"])
    eye: "right" | "left"

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => AnnotationDto)
    note?: Annotation[]

    @IsOptional()
    @IsNumber()
    power?: number

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => VisionPrescriptionLensSpecificationPrismDto)
    prism?: VisionPrescriptionLensSpecificationPrism[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => CodeableConceptDto)
    product: CodeableConcept

    @IsOptional()
    @IsNumber()
    sphere?: number

  }
  export class VisionPrescriptionDto implements VisionPrescription {
    @IsNotEmpty()
    @IsIn(["VisionPrescription"])
    resourceType: "VisionPrescription"

    @IsNotEmpty()
    @IsString()
    created: string

    @IsNotEmpty()
    @IsString()
    dateWritten: string

    @IsOptional()
    @ValidateNested()
    @Type(() => ReferenceDto)
    encounter?: Reference

    @IsOptional()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => IdentifierDto)
    identifier?: Identifier[]

    @IsNotEmpty()
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => VisionPrescriptionLensSpecificationDto)
    lensSpecification: VisionPrescriptionLensSpecification[]

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    patient: Reference

    @IsNotEmpty()
    @ValidateNested()
    @Type(() => ReferenceDto)
    prescriber: Reference

    @IsNotEmpty()
    @IsIn(["active", "entered-in-error", "draft", "cancelled"])
    status: "active" | "entered-in-error" | "draft" | "cancelled"

  }
}